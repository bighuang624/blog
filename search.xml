<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>初探人工智能</title>
    <url>/blog/start-to-know-AI/</url>
    <content><![CDATA[<p>一篇人工智能及相关概念（机器学习、深度学习、神经网络）的入门知识笔记。带一点点自己的思考。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>为什么作为一个前端学习者，我要对看似毫无关联的人工智能有所了解并进行学习？</p>
<ol>
<li>发挥科班优势。众所周知，机器学习等技术对数学的要求较高，对计算机组织与体系结构、操作系统等计算机基础知识也有一定要求。作为一个就读软件工程的本科生（而且还打算读研），应该充分利用自己的优势来规划职业生涯。</li>
<li>随着人工智能的飞速发展，即使是前端也可能与之发生密切的联系。目前相关方面和前端联系的最深的应该就是数据的挖掘及可视化。即使不如此，作为一名软件工程师，也应该要对最前沿的技术有所了解。</li>
<li>确实很有意思啊，科幻小说里的人工智能什么的。自己也有时以此为基础构思一些小说的点子。个人感觉，真正的人工智能确实是会对人类的未来造成巨大影响的事物。</li>
</ol>
<p>何况，我手上还有一本蔡恒进老师的《机器崛起前传——自我意识与人类智慧的开端》没读，带签名的。既然蔡老师赠给我了，还是要抽时间读一读的。</p>
<p>这不代表我放弃了前端的学习。在静下心来巩固 JavaScript 基础的同时，我希望自己学会放宽视野，在 20 岁之前。</p>
<p>不要拒绝未来的任何可能性。</p>
<span id="more"></span>

<h2 id="相关概念脑图"><a href="#相关概念脑图" class="headerlink" title="相关概念脑图"></a>相关概念脑图</h2><p>一直感觉纯文字的笔记比较难以记忆，导致自己的学习吸收率不高。看到别人的读书笔记是总结了一张脑图，条理比较清晰。这里也试着用 Xmind 总结一张相关概念的脑图（P.S.使用感觉百度脑图比 Xmind 条理清晰+好用）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a64a6eb143122930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="人工智能相关概念.png"></p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>学习算法的输入数据，叫<strong>“训练数据”</strong>。训练数据的每一行称为一个<strong>“训练样本”（Training Sample）</strong>，通常简称“样本”（Sample）。</p>
<p>样本的各种属性称为<strong>“特征”（Feature）</strong>。而希望学得的模型可以用来预判的信息称为样本的<strong>“标注”（Label）</strong>。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>机器学到的模型是一个映射。</p>
<h3 id="映射的输入"><a href="#映射的输入" class="headerlink" title="映射的输入"></a>映射的输入</h3><p>每个样本 xi 的特征组成一个**“特征向量” (Feature Vector)<strong>。所有特征向量的集合就是总的输入集合，称为</strong>“样本空间” (Sample Space)**。</p>
<h3 id="映射的输出"><a href="#映射的输出" class="headerlink" title="映射的输出"></a>映射的输出</h3><p>第 i 个样本的标注记作 yi。同理有**“标注空间”(Label Space)**。</p>
<h3 id="映射的表示"><a href="#映射的表示" class="headerlink" title="映射的表示"></a>映射的表示</h3><p>机器学习模型就是输入空间 X 到输出空间 Y 的一个映射，将映射用符号 g 表示，则模型记作 g: X -&gt; Y。</p>
<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p><strong>学习算法 (Learning Algorithm)</strong> 根据训练数据，从**假设集合 (Hypothesis Set) **中选出最优的那个映射 g 作为最终学得的模型，使得 g 越接近上帝真相 f 越好。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>不是所有的机器学习问题都需要标注。根据训练数据是否有标注，机器学习问题大致划分为<strong>监督学习（Supervised Learning）</strong>和<strong>无监督学习（Unsupervised Learning）</strong>两大类（还有半监督学习、增强学习等）。</p>
<ul>
<li>监督学习：每个输入样本都<strong>有标注</strong>。大致分成两类：<ol>
<li><strong>分类（Classification）</strong>问题：标注是<strong>离散值</strong>，比如用户”点击“和”不点击“。如果标注只有两个值，则称为二分类，如果标注有多个值，则称为多分类。</li>
<li><strong>回归（Regression）</strong>问题：标注是<strong>连续值</strong>，比如如果问题是预测北京市房屋的价格，价格作为标注就是一个连续值，属于回归问题。</li>
</ol>
</li>
<li>无监督学习：训练样本<strong>不需要标注</strong>。这类模型试图学习或是提取数据背后的结构，或从中抽取最为重要的特征。无监督学习解决的典型问题是<strong>聚类（clustering）问题</strong>，比如对一个网站的用户进行聚类，根据用户特征进行分组，看看这个网站用户的大致构成，分析下每类用户群的特点是什么。</li>
</ul>
<p>以上总结为脑图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e14be3cf5133d5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="机器学习.png"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>把听上去最高端的“神经网络”放到最后介绍。</p>
<h3 id="神经网络-1"><a href="#神经网络-1" class="headerlink" title="神经网络"></a>神经网络</h3><p>一组大致模仿人类大脑构造设计的算法，用于识别模式。神经网络通过机器感知系统解释传感器数据，能够对原始输入进行标记或聚类等操作。</p>
<p>神经网络所能识别的模式是数值形式，因此图像、声音、文本、时间序列等一切现实世界的数据必须转换为数值。</p>
<h3 id="感知器、权重与阈值"><a href="#感知器、权重与阈值" class="headerlink" title="感知器、权重与阈值"></a>感知器、权重与阈值</h3><p>大家都在高中的生物课上学过，人类大脑思考的基础是神经元（神经细胞）。如果能够人工制造神经元，就能组成人工神经网络来模拟思考。</p>
<p>上世纪六十年代，科学家们提出了最早的“人造神经元”，并将其称为<strong>“感知器”（perceptron）</strong>。感知器接受一些因素，这些因素根据不同的重要性（决定性因素与次要因素）获得不同的<strong>权重（weight）</strong>。因素的条件成立为 1，不成立为 0，乘以权重的总和大于指定的<strong>阈值（threshold）</strong>，感知器便输出 11，否则输出 0。</p>
<h3 id="决策模型"><a href="#决策模型" class="headerlink" title="决策模型"></a>决策模型</h3><p>单个的感知器构成一个简单的决策模型。而实际的决策模型是由多个感知器组成的多层网络。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071205.png" alt="多层网络"></p>
<p>每一个节点层在前一层输出的基础上学习识别一组特定的特征。随着神经网络深度增加，节点所能识别的特征也就越来越复杂，因为每一层会整合并重组前一层的特征。</p>
<p>而在“递归神经网络”中，上下层的感知器的输入与输出还可能发生循环传递。</p>
<h3 id="神经网络运作过程"><a href="#神经网络运作过程" class="headerlink" title="神经网络运作过程"></a>神经网络运作过程</h3><p>一个神经网络的搭建，需要满足三个条件：</p>
<ol>
<li>输入和输出</li>
<li>权重（w）和阈值（b）</li>
<li>多层感知器的结构</li>
</ol>
<p>最困难的部分就是确定权重和阈值。我们通过试错法，即保证其他参数不变，对 w 或 b 进行微小变动，然后观察输出的变化。通过不断重复这个过程来得到最精确的那组 w 和 b。这个过程即被称为<strong>模型的训练</strong>。</p>
<p>因此，神经网络的运作过程如下：</p>
<ol>
<li>确定输入和输出</li>
<li>找到一种或多种算法，可以从输入得到输出</li>
<li>找到一组已知答案的数据集，用来训练模型，估算 w 和 b</li>
<li>一旦新的数据产生，输入模型，就可以得到结果，同时对 w 和 b 进行校正</li>
</ol>
<p>整个过程需要海量计算，所以需要使用专门为机器学习定制的 GPU。</p>
<h3 id="输出的连续性"><a href="#输出的连续性" class="headerlink" title="输出的连续性"></a>输出的连续性</h3><p>为了保证模型的敏感，要将 0、1 输出改造为连续性函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z = wx + b</span><br><span class="line">σ(z) = 1 / (1 + e^(-z))</span><br></pre></td></tr></table></figure>

<p>这样，当 z 趋向正无穷（表示感知器强烈匹配）时，σ(z) → 1；如果 z 趋向负无穷（表示感知器强烈不匹配），σ(z) → 0。</p>
<p>同时，Δσ 满足下面的公式：</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png" alt="Δσ 公式"></p>
<p>即 Δσ 和 Δw 和 Δb 之间是线性关系，变化率是偏导数。这就有利于精确推算出 w 和 b 的值了。</p>
<h2 id="基于-JavaScript-的机器学习"><a href="#基于-JavaScript-的机器学习" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h2><p>尽管确实是第一选择，机器学习不一定要用 Python。为什么不试试神奇的 JavaScript 呢？</p>
<p>JavaScript 开发者们已经开源了不少基于 Node.js 的机器学习库：</p>
<ol>
<li><a href="https://github.com/harthur-org/brain.js">brain.js</a> (神经网络)</li>
<li><a href="https://github.com/cazala/synaptic">Synaptic</a> (神经网络)</li>
<li><a href="https://github.com/NaturalNode/natural">Natural</a> (自然语言处理)</li>
<li><a href="http://cs.stanford.edu/people/karpathy/convnetjs/">ConvNetJS</a> (卷积神经网络)</li>
<li><a href="https://github.com/mljs">mljs</a> (一系列具有多个函数方法的 AI 库)</li>
<li>Neataptic (神经网络)</li>
<li><a href="https://github.com/mil-tokyo/webdnn">Webdnn</a> (深度学习)</li>
</ol>
<p>你可以从 github 的这个项目：<a href="https://github.com/abhisheksoni27/machine-learning-with-js">abhisheksoni27/machine-learning-with-js</a> 中获得一些实例的源码，目前作者实现了线性规划和 KNN 算法。你也可以在参考资料的对应章节找到翻译版本进行阅读。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>emmm，如果你看了之后的参考资料中的每一篇，你会发现这篇博文只是一个拙劣的归纳总结。这是因为我确实对相关领域没有什么了解。但我对此兴致勃勃，也已经关注了不少数据挖掘和机器学习的知乎专栏及收藏夹。希望自己将来会有相关方面有价值的产出。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="相关概念部分"><a href="#相关概念部分" class="headerlink" title="相关概念部分"></a>相关概念部分</h3><ul>
<li><a href="http://blog.csdn.net/feichizhongwu888/article/details/52727958">简单理解：人工智能、数据挖掘、模式识别、机器学习、深度学习 - feichizhongwu888的博客 - CSDN博客</a></li>
<li><a href="http://36kr.com/p/5052482.html">一篇文章讲清楚人工智能、机器学习和深度学习的区别</a></li>
</ul>
<h3 id="数据、模型部分"><a href="#数据、模型部分" class="headerlink" title="数据、模型部分"></a>数据、模型部分</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25439997">写给大家看的机器学习书（第二篇） - 知乎专栏</a></li>
</ul>
<h3 id="神经网络部分"><a href="#神经网络部分" class="headerlink" title="神经网络部分"></a>神经网络部分</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/07/neural-network.html">神经网络入门 - 阮一峰的网络日志</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25358695">写给大家看的机器学习书（第三篇）</a></li>
</ul>
<h3 id="基于-JavaScript-的机器学习-1"><a href="#基于-JavaScript-的机器学习-1" class="headerlink" title="基于 JavaScript 的机器学习"></a>基于 JavaScript 的机器学习</h3><ul>
<li><a href="https://blog.fundebug.com/2017/07/03/javascript-machine-learning-regression/">JavaScript机器学习之线性回归</a></li>
<li><a href="https://blog.fundebug.com/2017/07/10/javascript-machine-learning-knn/">JavaScript机器学习之KNN算法</a></li>
</ul>
<h3 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h3><ul>
<li><a href="http://www.cnblogs.com/subconscious/p/5058741.html">神经网络浅讲：从神经元到深度学习</a></li>
<li><a href="https://yanqiangmiffy.github.io/2017/07/26/Python28-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BD%BF%E7%94%A8Python%E5%92%8CR%E4%BB%A3%E7%A0%81%EF%BC%89/">机器学习算法的基本知识（使用Python和R代码）</a>：带有 Python 和 R 语言代码实例</li>
<li><a href="https://exacity.github.io/deeplearningbook-chinese/">Deep Learning 中文翻译</a></li>
<li><a href="http://blog.csdn.net/baihuaxiu123/article/details/69488610">[机器学习]机器学习笔记整理全解</a></li>
<li><a href="https://zhuanlan.zhihu.com/dteratech">DT新纪元 - 知乎专栏</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 的异步操作 - Generator 和 async</title>
    <url>/blog/generator-and-async/</url>
    <content><![CDATA[<p>继续读《ECMAScript 6 入门》。在 ES6 之前，异步编程大概有四种方法：<strong>回调函数、事件监听器模式（发布/订阅模式）、流程控制库和 Promise/Deferred 模式</strong>。为了使异步操作更加清晰、简洁、方便，ES6 引入了 <strong>Generator 函数</strong>，而 ES2017 标准引入了 <strong>async 函数</strong>作为 Generator 函数的语法糖。</p>
<p>由于 JavaScript 是单线程，异步操作就显得格外重要。web 框架 koa 1.0 使用 Generator 实现异步，而基于 ES7 的 koa 2 完全使用 Promise 并配合 async 来实现异步。因此，在着手去了解这些基于 NodeJS 的 web 框架前，我决定先补充关于 ES6 的异步操作的知识。</p>
<p>本博文在 <a href="http://kyonhuang.top/promise/">Promise 对象 | 大黄菌的个人博客</a> 之后食用最佳。</p>
<p><strong>注</strong>：HTML 5 提出了 Web Worker 标准，允许 JS 脚本创建多个线程以充分利用多核 CPU 的计算能力。但子线程不得操作 DOM，且完全受主线程控制，因此此标准并没有改变 JavaScript 单线程的本质。</p>
<span id="more"></span>

<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-92dc7055c94c75cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Generator.png"></p>
<h3 id="Generator-与协程"><a href="#Generator-与协程" class="headerlink" title="Generator 与协程"></a>Generator 与协程</h3><p>一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为<strong>协程（coroutine）</strong>。</p>
<p>Generator 函数是 ES6 对协程的不完全实现，因为只有 Generator 函数的调用者才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<h3 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h3><p>Generator 是一个异步操作的容器。想让 Generator <strong>自动执行</strong>，即需要当异步操作有结果时能够自动交回执行权。两种方法：</p>
<ol>
<li>回调函数。将异步操作包装成 Thunk 函数，在回调函数里交回执行权。</li>
<li>Promise 对象。将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</li>
</ol>
<p>其中，JavaScript 中的 <strong>Thunk 函数</strong>指将多参数函数替换成的一个只接受回调函数作为参数的单参数函数。任何参数有回调函数的函数，都能写成 Thunk 函数的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 版本的简单 Thunk 函数转换器</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前者的实现可用 Thunkify 模块，后者可用 co 模块。了解更多请看 <a href="http://es6.ruanyifeng.com/#docs/generator-async#Thunk-%E5%87%BD%E6%95%B0">Generator 函数的异步应用 - ECMAScript 6入门</a>。暂时用不到的工具就不进一步消耗脑细胞了。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="通过-Generator-函数部署-Ajax-操作"><a href="#通过-Generator-函数部署-Ajax-操作" class="headerlink" title="通过 Generator 函数部署 Ajax 操作"></a>通过 Generator 函数部署 Ajax 操作</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">&#x27;http://some.url&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>

<h4 id="使用-yield-语句遍历完全二叉树"><a href="#使用-yield-语句遍历完全二叉树" class="headerlink" title="使用 yield* 语句遍历完全二叉树"></a>使用 yield* 语句遍历完全二叉树</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.left = left;</span><br><span class="line">  <span class="built_in">this</span>.label = label;</span><br><span class="line">  <span class="built_in">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序（inorder）遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* inoreder(t.left);</span><br><span class="line">    <span class="keyword">yield</span> t.label;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span>(array.length === <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = make([[[<span class="string">&#x27;a&#x27;</span>], <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>]], <span class="string">&#x27;d&#x27;</span>, [[<span class="string">&#x27;e&#x27;</span>], <span class="string">&#x27;f&#x27;</span>, [<span class="string">&#x27;g&#x27;</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> inoreder(tree))&#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="利用-Generator-函数部署-Iterator-接口"><a href="#利用-Generator-函数部署-Iterator-接口" class="headerlink" title="利用 Generator 函数部署 Iterator 接口"></a>利用 Generator 函数部署 Iterator 接口</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">7</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure>

<h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-532436b8fe3212f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="async+函数.png"></p>
<p>感觉前面的知识短时间内都消化不了，就没有看处于提案的异步遍历器。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h3 id="异步获取股票报价"><a href="#异步获取股票报价" class="headerlink" title="异步获取股票报价"></a>异步获取股票报价</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = <span class="keyword">await</span> getStockStmbol(name);</span><br><span class="line">  <span class="keyword">var</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">&#x27;goog&#x27;</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="并发发出远程请求"><a href="#并发发出远程请求" class="headerlink" title="并发发出远程请求"></a>并发发出远程请求</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInorder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程 URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过学习，我感觉 async 函数真的为一组资源依次异步加载等实际开发场景提供了一种非常简便的处理方案。不过想要运用好 async 函数，深究其实现原理，就必须也要对 Generator 函数有清晰的认知。</p>
<p>异步编程不管是在浏览器还是在服务器端的开发都很重要，知识量也很大，一时半会大概消化不过来。在总结完这些知识后，还需要时常复习，并在实际开发过程中探索更好的实践。</p>
<h2 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h2><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志</a>：帮助加深对同步、异步执行机制的认识。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScipt</tag>
        <tag>异步编程</tag>
        <tag>ES 6</tag>
        <tag>《ECMAScript 6 入门》</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 对象</title>
    <url>/blog/promise/</url>
    <content><![CDATA[<p>Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理和更强大。</p>
<p>特点：</p>
<ol>
<li><strong>对象的状态不受外界影响</strong>。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Fulfilled</code>（已完成，又称 Resolved）和<code>Rejected</code>（已失败）。只有异步操作的结果可以决定当前是哪一种状态。</li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。<code>Promise</code>对象的状态改变只有两种可能：从<code>Pending</code>变为<code>Fulfilled</code>和从<code>Pending</code>变为<code>Rejected</code>。</li>
</ol>
<p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>缺点：</p>
<ol>
<li>无法取消<code>Promise</code>，一旦新建就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，<code>Promise</code>内部抛出的错误不会反映到外部。</li>
<li>当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段（刚开始还是即将完成）。</li>
</ol>
<span id="more"></span>

<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>一个栗子🌰，用<code>Promise</code>对象实现 Ajax 操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystagechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.readyState !== <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">this</span>.status === <span class="number">200</span>)&#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">&quot;/post.json&quot;</span>).then(</span><br><span class="line">  <span class="function"><span class="params">json</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json), </span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>resolve</code>和<code>reject</code>函数由 JavaScript 引擎提供，不用自己部署。两者在改变 <code>Promise</code>对象的状态的同时，将异步操作的结果或报出的错误<strong>作为参数</strong>传递出去。</p>
<p><code>then</code>方法可以接受两个回调函数作为参数（可以说是处理 result 和 err 的回调）。第一个在<code>Promise</code>对象状态变为<code>Fulfilled</code>时调用，第二个（可省）在<code>Promise</code>对象状态变为<code>Rejected</code>时调用，都接受<code>Promise</code>对象传出的值作为参数。</p>
<p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个<code>Promise</code>实例（决定前一个<code>Promise</code>对象的状态），表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><code>then</code>方法会返回一个 Promise 实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outputPromise = promise.then(</span><br><span class="line">  <span class="function">(<span class="params">fulfilled</span>) =&gt;</span> &#123;...&#125;,</span><br><span class="line">  <span class="function">(<span class="params">rejected</span>) =&gt;</span> &#123;...&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这时，<code>outputPromise</code>变成了受<code>function(fulfilled)</code>或者 <code>function(rejected)</code>控制状态的 Promise 实例了：</p>
<ul>
<li>若<code>function(fulfilled)</code>或者 <code>function(rejected)</code>返回一个值（字符串、数组、对象等），那么<code>outputPromise</code>的状态变为<code>Resolved</code>；</li>
<li>若<code>function(fulfilled)</code>或者 <code>function(rejected)</code>抛出异常（<code>throw new Error(...)</code>），那么<code>outputPromise</code>的状态变为<code>Rejected</code>；</li>
<li>若<code>function(fulfilled)</code>或者 <code>function(rejected)</code>返回一个 Promise 实例，那么<code>outputPromise</code>就成为这个新的 Promise 实例。</li>
</ul>
<p>可以看 <a href="https://github.com/alsotang/node-lessons/tree/master/lesson17#promise%E7%9A%84%E4%BC%A0%E9%80%92">promise的传递</a> 的例子（使用了 q）加深理解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">&#x27;q&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> defer = Q.defer();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过defer获得promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInputPromise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> defer.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成fulfilled时，调用function(fulfilled)</span></span><br><span class="line"><span class="comment"> * 当inputPromise状态由未完成变成rejected时，调用function(rejected)</span></span><br><span class="line"><span class="comment"> * 将then返回的promise赋给outputPromise</span></span><br><span class="line"><span class="comment"> * function(fulfilled) 和 function(rejected) 通过返回字符串将outputPromise的状态由</span></span><br><span class="line"><span class="comment"> * 未完成改变为fulfilled</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@private</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> outputPromise = getInputPromise().then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">outputPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fulfilled</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;fulfilled: &#x27;</span> + fulfilled);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">rejected</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;rejected: &#x27;</span> + rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">defer.reject(); <span class="comment">// 输出 fulfilled: rejected</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// defer.resolve(); // 输出 fulfilled: fulfilled</span></span><br></pre></td></tr></table></figure>

<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>在创建新的 Promise 时，<strong>作为 Promise 参数传入的函数是会被立即执行</strong>的（而不是调用 then 时才执行），只是其中执行的代码可以是异步代码。</p>
<p>虽然 Promise 作为参数接收的函数是同步执行的，但是**<code>then</code>方法的回调函数执行<strong>是</strong>异步**的。</p>
<p>🌰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;create a promise&quot;</span>);</span><br><span class="line">  resolve(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;after new Promise&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;create a promise&quot;</span></span><br><span class="line"><span class="string">&quot;after new Promise&quot;</span></span><br><span class="line"><span class="string">&quot;success&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a><code>Promise.prototype.then()</code></h4><p><code>then</code>方法返回一个<strong>新的</strong><code>Promise</code>实例。链式写法调用<code>then</code>方法时，前一个回调函数将<strong>返回结果</strong>作为参数，传入第二个回调函数（前一个回调函数没有用<code>return</code>返回结果时，默认返回 undefined）。</p>
<h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a><code>Promise.prototype.catch()</code></h4><p><code>reject</code>方法的作用，等同于抛出错误。如果<code>Promise</code>状态已经变成<code>Fulfilled</code>，在<code>resolve</code>语句后再抛出错误是无效的，因为状态不会再改变了。</p>
<p>一般来说，不要在<code>then</code>方法中定义<code>Reject</code>状态的回调函数，<strong>总是使用<code>catch</code>方法</strong>。因为<code>catch</code>可以捕获之前所有<code>then</code>方法执行中的错误，也更接近同步的<code>try/catch</code>写法。</p>
<p><code>catch</code>方法返回的也是一个<code>Promise</code>对象。</p>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h4><p><code>Promise.all</code>方法用于将多个<code>Promise</code>实例（否则调用<code>Promise.resolve</code>方法再处理），包装成一个新的<code>Promise</code>实例。接受一个具有<code>Iterator</code>接口，且返回的每个成员都是<code>Promise</code>实例的参数（一般为数组）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>只有每个成员的状态都为<code>Fulfilled</code>，p 的状态才为<code>Fulfilled</code>，所有返回值组成一个参数传递给 p 的回调函数；否则只要有一个成员被<code>rejected</code>，p 的状态为<code>Rejected</code>，第一个被<code>reject</code>的实例的返回值被传递给 p 的回调函数。</p>
<p>如果作为参数的<code>Promise</code>实例自身定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p>
<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>p 的状态随第一个改变状态的成员而做相同改变，该成员返回值传递给 p 的回调函数。其他与<code>Promise.all</code>方法一致。</p>
<h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a><code>Promise.resolve()</code></h4><p>将现有对象转为<code>Promise</code>对象。根据参数分为四种情况：</p>
<ol>
<li><code>Promise</code>实例：不作任何修改，直接返回该实例；</li>
<li><code>thenable</code>对象（具有<code>then</code>方法的对象）：转为<code>Promise</code>对象，然后在立即调用其<code>then</code>方法的同时状态变为<code>Resolved</code>；</li>
<li>不符合以上情况的任何参数：返回状态为<code>Fulfilled</code>的<code>Promise</code>对象，参数传给回调函数；</li>
<li>不带有任何参数：返回状态为<code>Fulfilled</code>的<code>Promise</code>对象。</li>
</ol>
<p><strong>注意</strong>：当<code>Promise.resolve()</code>的<strong>参数是<code>Promise</code>实例</strong>时，<code>resolve</code>会“拆箱”获取这个 Promise 实例的状态和值，但这个过程是<strong>异步</strong>的。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a><code>Promise.reject()</code></h4><p>返回一个新的<code>Promise</code>实例，状态为<code>Rejected</code>。方法的参数会作为<code>reject</code>的理由，变成后续方法的参数。</p>
<p><code>reject</code>不具备“拆箱”能力。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>加载图片：加载完成时<code>Promise</code>的状态发生变化。</li>
<li>Generator 函数与 Promise 的结合：使用<code>Generator</code>函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>写作：</p>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/promise">Promise 对象 - ECMAScript 6入门</a></li>
<li><a href="https://juejin.im/post/597724c26fb9a06bb75260e8">八段代码彻底掌握 Promise</a></li>
</ul>
<p>进阶（之后阅读）：</p>
<ul>
<li><a href="http://liubin.org/promises-book/">JavaScript Promise迷你书（中文版）</a></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScipt</tag>
        <tag>异步编程</tag>
        <tag>ES 6</tag>
        <tag>《ECMAScript 6 入门》</tag>
      </tags>
  </entry>
  <entry>
    <title>Word2vec - 最经典的词嵌入学习算法</title>
    <url>/blog/Word2vec-intro/</url>
    <content><![CDATA[<p>如果想要开始研究基于深度学习的自然语言处理，你很难逃开 Word2vec 这一最为经典的词嵌入学习算法。然而，想要透彻理解 Word2vec 又并非易事。因此，我写这篇博文，力图叙述清楚 Word2vec 的原理，以对学到的知识做一个梳理。</p>
<span id="more"></span>

<h2 id="为什么要使用-Word2vec？"><a href="#为什么要使用-Word2vec？" class="headerlink" title="为什么要使用 Word2vec？"></a>为什么要使用 Word2vec？</h2><h3 id="One-Hot-Representation"><a href="#One-Hot-Representation" class="headerlink" title="One-Hot Representation"></a>One-Hot Representation</h3><p>自然语言处理（NLP）相关任务中，要将自然语言交给机器学习中的算法来处理，通常需要首先将语言数学化，因为机器没法理解自然语言。作为语言最细粒度的单位，词语被转换为数值形式的产物通常为词向量，顾名思义就是把一个词表示成一个向量。</p>
<p>最简单的词向量方式是 <strong>One-Hot Representation</strong>。简单来说，就是每个词向量的长度为词典大小，向量的分量只有一个 1，其他全为 0， 1 的位置对应该词在词典中的位置。这样的做法非常简单，也容易实现，只需要用哈希表给词典中的每个词语分配一个编号即可。NLP 领域的很多主流任务完全可以通过这种简洁的表示方法，配合其他的算法来完成。</p>
<p>但是，One-Hot Representation 有两个不可忽视的缺点：</p>
<ol>
<li>One-Hot Representation 的词向量是高维稀疏的。当数据的维度越高，要找到最优解甚至达到稍低维度时模型的同等表现，所需要的数据越多，而且呈指数型增长。此问题被称为“维度灾难”。</li>
<li>One-Hot Representation 无法体现词语间的相似度。因为每个单词都背表示为表示为完全独立的个体，不同词向量都是正交的。因此，词向量缺少语法和语义的信息。</li>
</ol>
<h3 id="Distributed-Representation"><a href="#Distributed-Representation" class="headerlink" title="Distributed Representation"></a>Distributed Representation</h3><p>因此，One-Hot Representation 已经逐渐不能满足需求，人们寻求在词向量表示上的新方法。之后，Hinton 在 1986 年提出了 Distributed Representation，基本思想是将每个词表达成 n 维稠密、连续的实数向量，每个分量通过训练得到。例如：<code>[0.792, −0.177, −0.107, 0.109, −0.542, ...]</code>。</p>
<p>这样，两个问题都迎刃而解：由于词向量维度较低，“维度灾难”难以出现；而两个词语义、语法上的相似性也可以通过计算两个词之间的“距离”来表示，因为所有词向量一起可以组成一个词向量空间，只要计算欧式距离或者 cos 距离即可。</p>
<h3 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h3><p>接下来，我们介绍语言模型。在统计自然语言处理中，<strong>语言模型（Language Model）</strong>指的是计算一个句子是否是自然语言的概率模型，通常用于在机器翻译、语音识别等任务得到若干候选答案后挑选一个比较正常的结果。例如，我们有 Bigram 模型，通过前一个词语已确定、后一个词语出现的概率来计算整句话遵循自然语言规则的概率：</p>
<p>$$P(w_1, w_2, …, w_n) = \prod^n_{i=2}P(w_i | w_{i-1})$$</p>
<p>大部分的有监督机器学习模型，都可以归结为<code>f(x)-&gt;y</code>。将语言模型看作<code>f</code>，<code>x</code>为一个句子里的一个词语，那么<code>y</code>就是这个词语的上下文词语。根据语言学中一个非常重要的假设——<strong>分布相似性</strong>，类似的词有相似的语境，即其上下文词语<code>y</code>应该相似。两个语义相似的词对应的向量也是相似的，具体反映在夹角或距离上。</p>
<p>Word2vec 就是源于以上思想。通过词语及其上下文，我们可以训练出一个模型<code>f</code>。在 Word2vec 中，我们关心<strong>神经网络训练完后得到的权重</strong>（即模型参数），这些向量化表示的权重就是我们需要的词向量，或者也被称为<strong>词嵌入（Word Embeddings）</strong>。当然，得到词嵌入的不止 Word2vec 一种算法，但 Word2vec 是提出时间较早并且比较经典的一种，因此值得花时间去透彻理解。</p>
<h2 id="Word2vec-的两种语言模型"><a href="#Word2vec-的两种语言模型" class="headerlink" title="Word2vec 的两种语言模型"></a>Word2vec 的两种语言模型</h2><p>Word2vec 是一种基于迭代的词嵌入学习算法，其包含两种语言模型：</p>
<ul>
<li><strong>Skip-gram</strong>：根据词预测目标上下文</li>
<li>**Continuous Bag of Words (CBOW)**：根据上下文预测目标词</li>
</ul>
<h3 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h3><p>在 Skip-gram 中，我们用当前词<code>x</code>来预测上下文<code>y</code>。一般的数学模型只接受数值型输入，因此<code>x</code>的原始输入形式就使用前文提到的 One-Hot Representation，每个词语都有自己的唯一表示。<code>y</code>使用的就是词典中每个词是正确上下文的概率。</p>
<p>当<code>y</code>只取<code>x</code>的下一个词时，网络结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/Word2vec-intro/Simple-Skip-gram.jpg"></p>
<p>设词典中词语数量为<code>V</code>，隐藏层节点数为<code>N</code>。当模型训练完后，当我们输入一个 One-Hot Representation 的向量作为<code>x</code>时，则在输入层到隐藏层的权重里，只有对应 1 这个位置的权重被激活，这些权重的个数为<code>N</code>，跟隐藏层节点数是一致的。由于每个词语的 One-Hot Representation 里 1 的位置是不同的，因此，对应 1 这个位置的权重组成的向量就可以作为该词的唯一表示。</p>
<p>同理，通过训练完后的隐藏层到输出层的权重同样可以得到另一种词向量。两种词向量分别称为“输入向量”和“输出向量”，一般我们使用“输入向量”。</p>
<p>由于<code>N</code>通常要远远小于<code>V</code>，因此我们通过 Word2vec 完成了对词向量的降维，以避免“维度灾难”的出现。</p>
<p>另外，<strong>隐藏层的激活函数其实是线性的</strong>，相当于没做任何处理。这是 Word2vec 相对于之前的语言模型的简化之处。在用反向传播算法训练神经网络时，本质上是<strong>链式求导</strong>。</p>
<p>更一般的情形下，上下文<code>y</code>应该有多个词，因此网络结构扩展如下图：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/Word2vec-intro/Multi-Skip-gram.jpg"></p>
<!--损失函数-->

<h3 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h3><p>在 CBOW 中，我们用上下文预测当前词。其他与 Skip-gram 相似，因此有网络结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/Word2vec-intro/CBOW.jpg"></p>
<p>具体步骤如下：</p>
<ol>
<li>生成所有的 One-Hot Representation；</li>
<li>根据上下文得到相对应的词向量；</li>
<li>将所有的上下文词向量求和后做一个平均，作为隐藏层的向量；</li>
<li>在隐藏层向量和输出向量相乘后，通过 Softmax 计算预测概率；</li>
<li>通过反向传播更新参数。</li>
</ol>
<p>损失函数为：</p>
<p>$$H(\hat y, y) = -\sum^V_{j=1}y_jlog(\hat y_j)$$</p>
<h3 id="训练技巧"><a href="#训练技巧" class="headerlink" title="训练技巧"></a>训练技巧</h3><p>Word2vec 本质上是一个语言模型，它的输出节点数是 V 个，对应了 V 个词语，本质上是一个多分类问题，但实际当中，词语的个数非常非常多，会给计算造成很大困难，所以需要用技巧来加速训练。对于 Word2vec，提出了两种训练技巧：</p>
<ul>
<li><strong>负采样（Negative Sampling）</strong>：采样负例。本质是预测总体类别的一个子集。</li>
<li><strong>分级的 Softmax（Hierarchical Softmax）</strong>：用一种有效的树结构来计算所有词汇的概率。本质是把 N 分类问题变成 log(N) 次二分类。</li>
</ul>
<p>因其不是 Word2vec 的精髓，在这篇文章中，暂时不对这两种训练技巧做过多的介绍了。有兴趣的同学可以在参考资料中选择阅读，或者等待下一篇文章。</p>
<h2 id="如何使用-Word2Vec？"><a href="#如何使用-Word2Vec？" class="headerlink" title="如何使用 Word2Vec？"></a>如何使用 Word2Vec？</h2><p>gensim 是一款开源的第三方 Python 工具包，包含 Word2vec 在内的多种主题模型算法。这里有一个<a href="https://github.com/bighuang624/Python-Learning/tree/master/code/word2vec-test">简单的 demo</a>来演示如何使用 gensim 中的 Word2vec。你也可以查阅 gensim 的官方文档来学习更多的用法。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Word2vec 作为最经典的词嵌入学习算法，让词嵌入开始广泛被使用。然而，Word2vec 学习的向量其实和真正的语义还有差距，因为其学到的更多是具备相似上下文的词语，例如表示“good”和“bad”的词嵌入相似度就非常高。因此，后续又有一些新的词嵌入学习算法被提出并大量使用，其中最火的就是 Glove。</p>
<p>到目前为止，这篇博文介绍了为什么要使用 Word2vec 的产物，以及 Word2vec 的算法本质。我的目标是能够覆盖参考资料中的《N问word2vec》中的所有问题，因此后续学习还会更新此文来添加公式推导、训练技巧介绍等内容，或者写下一篇文章。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26306795">[NLP] 秒懂词向量Word2vec的本质</a>：本文主干参照了知乎上的这篇文章，写得非常好，推荐</li>
<li><a href="https://github.com/stanfordnlp/cs224n-winter17-notes/blob/master/notes1.pdf">课程 cs224n 的 notes1</a></li>
<li><a href="https://blog.csdn.net/mytestmy/article/details/26961315">深度学习word2vec笔记之基础篇 - CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/43214781">（No.39）N问word2vec</a>：可以通过试图回答这篇文章里的问题来检验自己对 Word2vec 到底了解多深</li>
</ul>
<h3 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h3><ul>
<li>Mikolov 关于 Word2vec 的两篇开山之作：<ul>
<li><a href="https://arxiv.org/pdf/1405.4053.pdf">Distributed Representations of Sentences and Documents</a>：在前人基础上提出 Word2vec</li>
<li><a href="https://arxiv.org/pdf/1301.3781.pdf">Efficient estimation of word representations in vector space</a>：专门讲两个训练技巧</li>
</ul>
</li>
<li><a href="http://www.hankcs.com/nlp/Word2vec.html">Word2vec原理推导与代码分析-码农场</a></li>
<li><a href="https://arxiv.org/pdf/1411.2738.pdf">word2vec Parameter Learning Explained</a>：他人重点推荐</li>
<li><a href="https://www.zhihu.com/question/53011711">Word2vec 相比之前的 Word Embedding 方法好在什么地方？ - 知乎</a></li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>

]]></content>
      <categories>
        <category>自然语言处理笔记</category>
      </categories>
      <tags>
        <tag>Word2vec</tag>
        <tag>语言模型</tag>
        <tag>Skip-gram</tag>
        <tag>CBOW</tag>
        <tag>自然语言处理</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】理解 LSTM</title>
    <url>/blog/Understanding-LSTMs/</url>
    <content><![CDATA[<p>一直以来感觉自己对 LSTM 的理解缺了点什么。这次看到一篇不错的博客 <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a>，对 LSTM 的机制和公式有逐条的解释。正好最近手头的工作也和门机制有一定联系，因此决定翻译一下，帮助自己理解和记忆公式。主要靠意译，省略了一点无关紧要的内容，有条件可以自己看看原文。</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>人类不是每分每秒都从头开始思考，而是基于所学所想进一步思考，有一定的持续性。RNN 可以通过前一个单元将消息传递给后一个单元，一定程度上模拟这个过程。</p>
<p>使用 RNN 面临着一个问题，有时候我们需要非常长的上下文，例如通过非常靠前的相关信息来预测下一个词。在实践中，RNN 难以处理这种“<strong>长期依赖</strong>”，原因和梯度爆炸（exploding gradient）/梯度消失（vanishing gradient）有关。不过，LSTM 可以解决这个问题，它会默认地长时间记忆信息。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-SimpleRNN.png"></p>
<p>上图展示了包含了单个层的标准 RNN 单元组成的链式结构。LSTM 有着同样的链式结构，但是重复的组件结构不同，它有着四个交互的层：</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-chain.png"></p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>LSTM 的核心是 <strong>cell state（单元状态）</strong>，即贯穿图顶部的水平线。cell state 有点像传送带，沿着整个链向后，只有一些小的线形相互作用。因此，信息很容易不加改动地沿着它流动。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-C-line.png"></p>
<p>而向 cell state 删除或者添加的信息通过<strong>门（gates）</strong>结构精心控制。门结构能够选择性地让信息通过，它有一个 sigmoid 层和一个 pointwise 乘积操作组成：</p>
<img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-gate.png" style="width:20%; margin-top=10px; margin-bottom=10px;">

<p>sigmoid 层输出一个 0 到 1 之间的实数，来描述允许多少信息通过，0 代表不允许任何信息通过，而 1 代表让全部信息通过。LSTM 有三个类似的门机构，用来保护和控制 cell state。</p>
<h2 id="一步一步看公式"><a href="#一步一步看公式" class="headerlink" title="一步一步看公式"></a>一步一步看公式</h2><p>LSTM 的第一步是决定从 cell state 中丢弃什么信息，这个决定通过称为“<strong>忘记门（forget gate）</strong>”的 sigmoid 层作出。输入是 $h_{t-1}$ 和 $x_t$，并为 cell state $C_{t-1}$ 中的每个数字输出一个 0 到 1 之间的值，1 表示完全保留，而 0 表示完全遗忘。</p>
<p>举一个基于前面所有单词来预测下一个单词的例子，在这个问题中，cell state 可能包括当前主语的性别，以便使用正确的代词。当我们看到一个新的主语时，我们想要忘记旧主语的性别。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-f.png"></p>
<p>第二步我们决定将在 cell state 中存储什么新信息。首先，一个称为<strong>输入门（input gate）</strong>的 sigmoid 层决定我们将要更新的值。然后，一个 tanh 层创建一个候选的 $\tilde C_i$，准备加到 cell state 中。在下一步，我们将这两个值合并，来为 cell state 做一个更新。</p>
<p>继续之前的例子，我们想要将新主语的性别加入到 cell state，以取代我们遗忘的内容。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-i.png"></p>
<p>接下来我们将旧的 cell state $C_{t-1}$ 更新为新的 cell state $C_t$。在例子中，我们在这一步中正式地丢弃关于旧主语性别的信息并添加新信息。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-C.png"></p>
<p>最后，我们决定要输出的内容。输出取决于我们的 cell state，不过要经过一层过滤。首先，我们还是通过一个 sigmoid 层来决定 cell state 中哪些部分要被输出。之后，我们将 state cell 通过 tanh 来将值缩放到 -1 与 1 之间，并用 sigmoid 门的输出做乘法，决定输出的部分。</p>
<p>对于语言模型示例，由于它只看到了一个主语，因此可能希望输出与谓词相关的信息，以防接下来会出现与谓词相关的信息。例如，它可以输出主语是单数还是复数，这样我们就知道如果接下来是动词，动词应该用什么形式。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-focus-o.png"></p>
<h2 id="LSTM-的变体"><a href="#LSTM-的变体" class="headerlink" title="LSTM 的变体"></a>LSTM 的变体</h2><p>以上所述就是一个标准的 LSTM。但是，几乎所有的论文使用的 LSTM 都有或多或少的修改。虽然差异不大，但其中有些版本值得一提。</p>
<p><a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf">Gers &amp; Schmidhuber (2000)</a> 中的版本增加了<strong>窥视孔连接（peephole connections）</strong>，使得门层可以观察 cell state。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-peepholes.png"></p>
<p>上图在所有的门上都加了窥视孔。也有些论文只给一些门增加窥视孔。</p>
<p>另一种变体是将遗忘门和输入门耦合。我们不再单独决定要忘记什么或者应该添加什么新信息，而是共同做出这些决定，并且只在准备遗忘旧信息时添加新信息作为替代。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-tied.png"></p>
<p>一个变化稍大的变体是 <a href="arxiv.org/pdf/1406.1078v3.pdf">Cho, et al. (2014)</a> 提出的<strong>门控循环单元（Gated Recurrent Unit, GRU）</strong>。它将遗忘和输入合并到一个单独的“更新门”，并将 cell state 和 hidden state 合并到一块。GRU 比标准的 LSTM 更简单，并且也得到广泛的应用。</p>
<p><img src="http://colah.github.io/posts/2015-08-Understanding-LSTMs/img/LSTM3-var-GRU.png"></p>
<p>除了几个最值得注意的变体，还有很多版本。<a href="jmlr.org/proceedings/papers/v37/jozefowicz15.pdf">Jozefowicz, et al. (2015)</a> 测试了超过一万种 RNN 架构，发现一部分会在特定任务上比 LSTM 表现更好。</p>
<h2 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h2><ul>
<li><a href="http://www.bioinf.jku.at/publications/older/2604.pdf">Hochreiter S, Schmidhuber J. Long Short-Term Memory[J]. Neural Computation, 1997, 9(8):1735-1780.</a>：提出 LSTM 的 paper。</li>
<li><a href="https://jalammar.github.io/">Jay Alammar’s Blog</a>：另一个致力于可视化讲解机器学习概念的好博客。最新的两篇讲 NLP 里的 Transformer 和 BERT，可见内容之新。</li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>自然语言处理笔记</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>Node 异步 I/O</title>
    <url>/blog/async-IO-in-Node/</url>
    <content><![CDATA[<p>在底层系统中，异步通过信号量、消息等方式有了广泛的应用。但程序员们还是习惯采用同步的方式编写应用，在绝大多数高级编程语言中，异步并不多见。Java 中用多线程来应对高并发的场景，而 PHP 甚至连多线程都不提供。</p>
<p>Node 是首个将异步作为主要编程方式的运行平台。伴随着异步 I/O 的还有事件驱动和单线程，它们共同为 Node 的设计理念奠定基调，Node 由此成为首个大规模将异步 I/O 应用在应用层上的平台。</p>
<p>因此，想要深入理解 Node 的运作机制，就必须理解 Node 中的异步。对操作系统有学习经验的同学应该会更容易理解。</p>
<p>这篇博文在《深入浅出 Mode.js》第三章笔记的基础上，加上自己的思考与总结而写成。全是硬货，需得再啃。</p>
<span id="more"></span>

<h2 id="选择异步的原因"><a href="#选择异步的原因" class="headerlink" title="选择异步的原因"></a>选择异步的原因</h2><p>选择异步的原因包括用户体验和资源分配两个方面。</p>
<p>从用户体验的角度分析，浏览器中 JavaScript 在单线程上执行，并且与 UI 渲染共用一个线程。因此采用异步请求将使下载资源期间，JavaScript 和 UI 的执行都不会处于等待状态，可以继续响应用户的交互行为。</p>
<p>而从资源分配角度来看，当遇到一组互不相关的任务需要完成的场景时，主流选择有以下两种：</p>
<ul>
<li>单线程串行依次执行：容易导致阻塞，硬件资源难以有效利用；</li>
<li>多线程并行：创建线程和执行期线程上下文切换的开销较大，且经常面临锁、状态同步等问题（但多线程在多核 CPU 上能够有效提升 CPU 的利用率）；</li>
</ul>
<p>而 Node 给出的解决方案是：利用<strong>单线程</strong>，远离多线程死锁、状态同步等问题；利用<strong>异步 I/O</strong>，让单线程远离阻塞以更好地利用 CPU。</p>
<p>而为了弥补单线程无法有效利用多核 CPU 的缺点，Node 提供了类似前端浏览器中 Web Workers 的子进程，该子进程可以通过工作进程高效利用 CPU 和 I/O。</p>
<h2 id="从操作系统看异步-I-O"><a href="#从操作系统看异步-I-O" class="headerlink" title="从操作系统看异步 I/O"></a>从操作系统看异步 I/O</h2><p>Node 的异步 I/O 不可否认地受到操作系统中异步 I/O 实现的启发。</p>
<p>要强调的是，从计算机内核 I/O 而言，<strong>异步/同步和阻塞/非阻塞实际上是两回事</strong>。</p>
<h3 id="阻塞-非阻塞-I-O"><a href="#阻塞-非阻塞-I-O" class="headerlink" title="阻塞/非阻塞 I/O"></a>阻塞/非阻塞 I/O</h3><p>在调用<strong>阻塞 I/O</strong> 时，应用程序需要等待 I/O 完成时才返回结果。特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束，因此造成 <strong>CPU 等待 I/O，浪费等待时间，CPU 的处理能力不能得到充分利用</strong>。</p>
<p>与阻塞 I/O 完成整个获取数据的过程相比，<strong>非阻塞 I/O</strong> 则<strong>不带数据直接返回</strong>，要获取数据还需要通过<strong>文件描述符</strong>再次读取。非阻塞 I/O 返回之后，CPU 的时间片可以用来处理其他事务。</p>
<p>但由于完整的 I/O 并没有完成，非阻塞 I/O 立即返回的仅仅是当前调用的状态。为了获取完整数据，需要<strong>轮询</strong>这种重复调用以判断操作是否完成的技术。</p>
<p>现存的轮询技术包括 <strong>read</strong>（通过重复调用检查 I/O 状态，性能最低，CPU 一直等待）、<strong>select</strong>（通过对文件描述符上的事件状态进行判断）、<strong>poll</strong>（比 select 有所改进，但性能仍较低）、<strong>epoll</strong>（Linux 下<strong>效率最高</strong>的 I/O 事件通知机制，进入轮询时休眠，直到事件发生将其唤醒）和<strong>kqueue</strong>（与 epoll 类似，仅在 FreeBSD 系统存在）。</p>
<p>虽然轮询技术能够满足了非阻塞 I/O 确保获取完整数据的需求，但应用程序依旧花费了很多时间来等待 I/O 完全返回。等待期间，CPU 要么用于<strong>遍历文件描述符的状态</strong>，要么用于<strong>休眠等待事件发生</strong>。因此，<strong>它仍然只能算是一种同步</strong>。</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><p>在看廖雪峰的 Python 教程的异步 IO 这一章时，在评论区看到一个对于阻塞/非阻塞和同步/异步非常精妙的解释，十分容易理解和记忆，特摘录如下：</p>
<blockquote>
<p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</p>
<p>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻</p>
<p>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。</p>
</blockquote>
<blockquote>
<p>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大</p>
</blockquote>
<blockquote>
<p>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p>
</blockquote>
<blockquote>
<p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p>
</blockquote>
<blockquote>
<p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
</blockquote>
<h3 id="异步-I-O-的实现"><a href="#异步-I-O-的实现" class="headerlink" title="异步 I/O 的实现"></a>异步 I/O 的实现</h3><p>我们期望的完美异步 I/O 应该是：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序即可。</p>
<p>Linux 原生提供 AIO 这种符合要求的异步 I/O 方式，但只有 Linux 下有，且其无法利用系统缓存。因此现实情况下，想在单线程场景完美实现异步 I/O 有些难度。</p>
<p>而在<strong>多线程</strong>，通过<strong>让部分线程进行阻塞 I/O 或者非阻塞 I/O 加载轮询技术来完成数据获取，让一个线程进行计算处理，再通过线程间的通信将 I/O 得到的数据进行传递</strong>，可以模拟异步 I/O。</p>
<p>*nix 平台，Node 自行实现了线程池来完成异步 I/O；Windows 平台则采用 IOCP 实现。Node 提供了 libuv 作为抽象封装层，平台兼容性由这一层完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。</p>
<p>Node 在<strong>编译期间判断平台条件</strong>，选择性编译 unix 目录或 win 目录下的源文件到目标程序中。</p>
<ul>
<li>我们常说的“Node 是单线程的”里的“单线程”仅指 <strong>JavaScript 执行在单线程</strong>。而内部完成 I/O 任务的另有线程池，只是 I/O 线程使用的 CPU 较少。</li>
<li>除了用户代码无法并行执行外，所有的 I/O （磁盘 I/O 和网络 I/O 等）可以并行。</li>
</ul>
<h2 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h2><p><strong>事件循环</strong>、<strong>观察者</strong>、<strong>请求对象</strong>、<strong>I/O 线程池</strong>一同构成了 Node 异步 I/O 模型的基本要素。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>每执行一次循环体的过程被称为 <strong>Tick</strong>，查看是否有事件待处理，若有则取出事件及相关回调函数。如果存在关联的回调函数，就执行它们。直到没有事件，进入下个循环。</p>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>每个事件循环中有一个或者多个观察者，<strong>判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件</strong>。</p>
<p>事件循环是一个典型的<strong>生产者/消费者模型</strong>。<em>异步 I/O、网络请求</em>是事件的<em>生产者</em>，事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。<strong>观察者相当于事件池</strong>。</p>
<p>在 Windows 下，这个循环基于 IOCP 创建，而在 *unix 下基于多线程创建。</p>
<h3 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h3><p>请求对象是从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中的重要<strong>中间产物</strong>。所有的状态都保存在这个对象中，包括<strong>送入 I/O 线程池等待执行</strong>以及 I/O 操作完毕后的回调处理。</p>
<h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><p>组装好请求对象、送入 I/O 线程池等待执行，构成了异步 I/O 的第一部分。而回调通知是第二部分。</p>
<p>线程池中的 I/O 操作调用完毕后，会调用方法向 IOCP 提交执行状态，并将线程归还线程池。</p>
<p>在每次 Tick 的执行中，I/O 观察者会调用方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。</p>
<p>整个异步 I/O 流程图如下：</p>
<img src="/images/async IO model.jpg" />

<h2 id="非-I-O-的异步-API"><a href="#非-I-O-的异步-API" class="headerlink" title="非 I/O 的异步 API"></a>非 I/O 的异步 API</h2><p>Node 中还存在一些与 I/O 无关的异步 API：<code>setTimeout()</code>、<code>setInterval()</code>、<code>setImmediate()</code>、<code>process.nextTick()</code>。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><code>setTimeout()</code>和<code>setInterval()</code>与浏览器 API 一致，创建的定时器会被插入到<strong>定时器观察者内部的一个红黑树</strong>中。每次 Tick 执行时，会从该红黑树中<strong>迭代</strong>取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件并执行其回调函数。注意：由于事件循环自身特点，定时器并非精确的。</p>
<h3 id="process-nextTick-amp-setImmediate"><a href="#process-nextTick-amp-setImmediate" class="headerlink" title="process.nextTick() &amp; setImmediate()"></a>process.nextTick() &amp; setImmediate()</h3><p>两者都可用于将回调函数延迟执行，以异步执行一个任务。两者的区别如下：</p>
<ul>
<li><p>优先级：<code>process.nextTick()</code>中回调函数执行优先级要高于<code>setImmediate()</code>，原因在于<strong>事件循环对观察者的检查是有先后顺序的</strong>，idle 观察者（<code>process.nextTick()</code>） &gt; I/O 观察者 &gt; check 观察者（<code>setImmediate()</code>）。</p>
</li>
<li><p>具体实现：<code>process.nextTick()</code>的回调函数保存在一个<em>数组</em>中，<code>setImmediate()</code>保存在<em>链表</em>中。</p>
</li>
<li><p>行为：<code>process.nextTick()</code>在每轮循环中会将数组中的回调函数<em>全部执行</em>完，而<code>setImmediate()</code>在每轮循环中执行链表中的<em>一个</em>回调函数。这样的设计是为了保证每轮循环能够较快地执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。</p>
</li>
</ul>
<h2 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h2><p>事件驱动的实质：通过<strong>主循环加事件触发</strong>的方式来运行程序。</p>
<p>几种经典的服务器模型各有其优缺点：</p>
<ul>
<li><strong>同步式</strong>：对于同步式的服务，一次只能处理一个请求，并且其他请求都处于等待状态。</li>
<li><strong>每进程/每请求</strong>：为每个请求启动一个进程，这样可以处理多个请求，但因为系统资源有限而不具备扩展性。</li>
<li><strong>每线程/每请求</strong>：为每个请求启动一个线程来处理。扩展性强于每进程/每请求，但由于每个线程都占用一定内存，大并发到来时内存还是会很快用光。</li>
</ul>
<p>Apache 目前还采用每线程/每请求，而 Nginx 采用事件驱动。</p>
<p>Nginx 与 Node 比较：</p>
<ul>
<li>Nginx 采用纯 C 写成，性能较高，但仅适合做 Web 服务器，用于反向代理或负载均衡等服务，在处理具体业务方面欠缺；</li>
<li>Node 是一套高性能平台，没有 Nginx 在 Web 服务器方面那么专业，但场景更大，可以处理各种具体业务。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入浅出Node.js》</p>
]]></content>
      <categories>
        <category>NodeJS 学习笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>NodeJS</tag>
        <tag>异步 I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>理清 Spark 2.2 的概念－RDD、Dataset、MLlib</title>
    <url>/blog/spark2.2-with-old-conceptions/</url>
    <content><![CDATA[<p>根据实验室的要求，现在在啃《Spark 机器学习》。这本书和市面上大多数 Spark 书籍一样，全都基于 Spark 1.x。在 Spark 版本已经升到 2.2 的今天，敲这本书上的代码可以说是遍地是坑了，很多东西都已经变更，而且很难找到正确的解决方案，弄的我很是烦躁。</p>
<p>没办法，问题要一点一点解决。我决定先从理清《Spark 机器学习》提到的某些 Spark 2.2 提供的概念、模块和配合工具下手，主要关心一下几点：</p>
<ol>
<li>RDD 是什么？在升级到 Spark2.2+ 后有什么改动？</li>
<li>Dataset 是什么？DataFrame 又是什么？</li>
<li>MLlib 是什么？在升级到 Spark2.2+ 后有没有变动？如何使用？</li>
<li>IPython 是什么？如何配合 Spark2.2+ 使用？</li>
</ol>
<span id="more"></span>

<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark 是一个快速的, 多用途的集群计算系统。 它提供了 Java, Scala, Python 和 R 的高级 API，以及一个支持通用的执行图计算的优化过的引擎. 它还支持一组丰富的高级工具, 包括使用 SQL 处理结构化数据处理的 Spark SQL, 用于机器学习的 MLlib, 用于图形处理的 GraphX, 以及 Spark Streaming。</p>
<h2 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>RDD（Resilien Distributed Dataset，弹性分布式数据集）是 Spark 的核心概念之一。一个 RDD 代表一系列的“记录”（严格来说是某种类型的对象）。这些记录被分配或分区到一个集群的多个节点上（在本地模式下，可以类似地理解为单个进程里的多个线程上）。</p>
<p>Spark 中的 RDD 具备容错性，即当某个节点或任务失败时（非用户代码错误引起，如硬件故障、网络连接失败等），RDD 会在余下的节点上自动重建，以便任务最终能够完成。</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>RDD 可以从一个驱动程序中已存在的 Scala 集合创建，也可以基于 Hadoop 的输入源（任何其他 Hadoop 支持的文件系统）创建，以及通过转换（transforming）来创建。</p>
<p>RDD 支持两种类型的操作：<strong>转换（transformation）</strong>和<strong>执行（action）</strong>。一般来说，转换操作是对一个数据集里的所有记录执行某种函数，从而使记录发生改变；而执行通常是运行某些计算或聚合操作，并将结果返回给驱动程序。</p>
<p>值得注意的是，Spark 中的<strong>转换操作是懒加载的</strong>（lazy），即在 RDD 上调用一个转换操作不会立即触发相应的计算，而是会将转换操作链接起来，并在执行操作被调用时才被高效计算。</p>
<p>调用一个 RDD 的<code>cache</code>（或<code>persist</code>）函数将会告诉 Spark 将这个 RDD 缓存在集群的内存中，以加快下一次访问数据集的速度。</p>
<p>更多 RDD 功能及实际编程方法可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/rdd-programming-guide.html">Spark 编程指南 - Spark 2.2.0 中文文档 - ApacheCN</a>里的相关部分。</p>
<h3 id="升级变动"><a href="#升级变动" class="headerlink" title="升级变动"></a>升级变动</h3><p>在 Spark 2.0 之前，Spark 的主要编程接口是 RDD。而在 Spark 2.0 之后，RDD 被 Dataset（数据集）替换。</p>
<p>Dataset 很像 RDD，也是强类型的，并能够使用强大的 lambda 函数。但 Dataset 在引擎盖（hood）有更好的优化，因此性能要更优于 RDD。RDD 接口仍然受支持，但是建议切换使用 Dataset。</p>
<h2 id="Dataset-和-DataFrame"><a href="#Dataset-和-DataFrame" class="headerlink" title="Dataset 和 DataFrame"></a>Dataset 和 DataFrame</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>Dataset 是一个分布式的数据集合。一个 Dataset 可以从 JVM 对象来构造并使用转换功能。Dataset API 在 Scala 和 Java 是可用的，遗憾的是，Python 暂不支持 Dataset API。但是由于 Python 的动态特性, 许多 Dataset API 的优点已经可用了。</p>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>一个 DataFrame 是一个 Dataset 组成的指定列。它的概念与一个关系型数据库中的表或者在 R/Python 中的数据帧（data frame）是相等的，但优化得更好。</p>
<p>DataFrames 可以从结构化的文本文件、Hive中的表、外部数据库，或者已经存在的 RDD 构造而来。DataFrame API 可以在 Scala、Java、Python 和 R 中实现。在 Scala 和 Java 中，一个 DataFrame 所代表的是一个多行的 Dataset。</p>
<p>更多相关信息可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/sql-programming-guide.html">Spark SQL and DataFrames - Spark 2.2.0 中文文档 - ApacheCN</a>。</p>
<h2 id="MLlib"><a href="#MLlib" class="headerlink" title="MLlib"></a>MLlib</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>MLlib 是 Spark 的机器学习库。其目标是使实用的机器学习具有可扩展性并且变得容易。在较高的水平上，它提供了以下工具：</p>
<ul>
<li>ML Algorithms（ML 算法）：常用的学习算法，如分类，回归，聚类和协同过滤；</li>
<li>Featurization（特征）：特征提取，变换，降维和选择；</li>
<li>Pipelines（管道）：用于构建，评估和调整 ML Pipelines 的工具；</li>
<li>Persistence（持久性）：保存和加载算法，模型和 Pipelines；</li>
<li>Utilities（实用）：线性代数，统计学，数据处理等。</li>
</ul>
<h3 id="升级变动-1"><a href="#升级变动-1" class="headerlink" title="升级变动"></a>升级变动</h3><p>MLlib 包括基于 RDD 的 API 和基于 DataFrame 的 API。从 Spark 2.0 开始，基于 RDD 的 API 处于维护模式，这意味着这些 API 仍然被支持且会修复 bug，但不会再添加新功能。在基于 DataFrame 的 API 能够开发到相同功能时，基于 RDD 的 API 将被弃用，并预计在 Spark 3.0 中删除。</p>
<p>更多相关信息可见 <a href="http://spark.apachecn.org/docs/cn/2.2.0/ml-guide.html">MLlib: 主要指南 - Spark 2.2.0 中文文档 - ApacheCN</a>。</p>
<h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>书中的 3.2 节开始也涉及到 IPython 的使用，并且在实际使用中也有一些坑。因此也需要了解一下。</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>IPython 是一个 Python 的高级交互式 shell，基于 BSD 开源，比默认的 Python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，并且内置了许多很有用的功能和函数。IPython 内置的 pylab 包括用于数值计算的 NumPy 和 SciPy，以及用于交互式绘图和可视化的 matplotlib。</p>
<h3 id="升级变动-2"><a href="#升级变动-2" class="headerlink" title="升级变动"></a>升级变动</h3><p>书中想在启动 PySpark 终端时使用 IPython 而非标准的 Python shell。启动时也可以向 IPython 传入其他参数，包括让它启动时也启动 pylab 功能。</p>
<p>但是实际操作时，在 Spark 主目录下输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPYTHON=1 IPYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark</span><br></pre></td></tr></table></figure>

<p>会报错，提示信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error in pyspark startup:</span><br><span class="line">IPYTHON and IPYTHON_OPTS are removed in Spark 2.0+. Remove these from the environment and set PYSPARK_DRIVER_PYTHON and PYSPARK_DRIVER_PYTHON_OPTS instead.</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>把输入命令变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&quot;--pylab&quot; ./bin/pyspark</span><br></pre></td></tr></table></figure>

<p>如果要使用 IPython 提供的 Notebook 应用，<br>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PYSPARK_DRIVER_PYTHON=ipython PYSPARK_DRIVER_PYTHON_OPTS=&#x27;notebook&#x27; ./bin/pyspark</span><br></pre></td></tr></table></figure>

<p>参考资料：<a href="https://stackoverflow.com/questions/42658694/starting-ipython-with-spark-2">Starting Ipython with Spark 2 - Stack Overflow</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Spark 机器学习》</li>
<li><a href="http://spark.apachecn.org/docs/cn/2.2.0/">概述 - Spark 2.2.0 中文文档 - ApacheCN</a></li>
</ul>
]]></content>
      <categories>
        <category>Spark 学习笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Spark</tag>
        <tag>RDD</tag>
        <tag>Dataset</tag>
        <tag>MLlib</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】A Closer Look at Few-shot Classification</title>
    <url>/blog/CloserLookFewShot-notes/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CloserLookFewShot-paper-title.png"></p>
<h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>本文研究了骨干网络的能力、数据集领域差异对现有小样本学习方法性能的影响，并强调了现有小样本学习方法的领域自适应能力普遍较差，需要多加注意。</p>
<h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><ul>
<li>作者：Wei-Yu Chen, Yen-Cheng Liu, Zsolt Kira, Yu-Chiang Frank Wang, Jia-Bin Huang</li>
<li>出处：ICLR 2019</li>
<li>机构：CMU; Georgia Tech; National Taiwan University; Virginia Tech</li>
<li>关键词：few-shot learning, domain shift, domain adaptation</li>
<li><a href="https://openreview.net/pdf?id=HkxLXnAcFQ">论文链接</a></li>
<li>开源代码：<a href="https://github.com/wyharveychen/CloserLookFewShot">wyharveychen/CloserLookFewShot</a></li>
<li>其他资料：<ul>
<li><a href="https://www.semanticscholar.org/paper/A-Closer-Look-at-Few-shot-Classification-Chen-Liu/9d5ec23154fb278a765f47ba5ee5150bd441d0de">Semantic Scholar</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/76596852">知乎上的一份解读</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/64672817">知乎上的另一份解读</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="内容简记"><a href="#内容简记" class="headerlink" title="内容简记"></a>内容简记</h2><h3 id="背景与主要贡献"><a href="#背景与主要贡献" class="headerlink" title="背景与主要贡献"></a>背景与主要贡献</h3><p>尽管小样本学习（Few-Shot Learning, FSL）近年来有很大的进展，但各种方法实现上的细节差异掩盖了相对表现增益，缺少在同一框架下进行公平的比较。例如，是否在数据增强的情况下进行训练（意思是简单的数据增强能够大幅提高 baseline 的效果）。本文有三个主要贡献：</p>
<ol>
<li>本文对于几种代表性的小样本分类算法进行分析，特别实验了基础骨干网络对这些方法的影响。结果表明，更深的骨干网络（即特征提取能力越强），在领域差异有限的数据集上，显著降低了方法之间的性能差异；</li>
<li>本文建立了两个 baseline，其中一种基于距离的分类 baseline 能够在 mini-ImageNet 和 CUB 数据集上与 SOTA 方法相媲美；</li>
<li>虽然目前的评估侧重于识别具有有限训练样例的新类，但这些新类从同一数据集中采样。而在现实中，新类和基础类通常存在领域漂移（domain shift）问题。因此，本文强调了小样本学习任务中的领域自适应问题。设置了评估 FSL 算法的跨域泛化能力的实验，其中，基础类和新类别从不同领域中采样。实验表明，目前的 FSL 分类 SOTA 算法在领域漂移的情况下表现相当不好，效果甚至比 baseline 要差，从而表明 FSL 中学习适应领域差别的重要性。</li>
</ol>
<h4 id="领域自适应（domain-adaptation）"><a href="#领域自适应（domain-adaptation）" class="headerlink" title="领域自适应（domain adaptation）"></a>领域自适应（domain adaptation）</h4><p>前文提到的有关领域的相关概念可能在迁移学习领域更为常见。<strong>领域（domain）</strong>主要由两部分组成：<strong>数据</strong>和<strong>生成这些数据的概率分布</strong>。而<strong>领域漂移（domain shift）</strong>指的就是源域和目标域的数据分布差异较大。<strong>领域自适应（domain adaptation）</strong>就是旨在解决领域漂移问题的研究内容。</p>
<p>在本文提到的场景中，领域自适应和小样本分类的区别：</p>
<ul>
<li>领域自适应：旨在将<strong>源数据集</strong>的知识迁移到<strong>目标数据集</strong>的<strong>相同</strong>类别上；</li>
<li>小样本分类：从基础类学习去分辨<strong>同一数据集</strong>的<strong>新</strong>类。</li>
</ul>
<p>如果基础类和新类都来自同一数据集，则基础类和新类之间存在的领域漂移极少。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CloserLookFewShot-paper-Table-A1.png"></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>本文提出的 Baseline 和 Baseline++：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/4-Figure1-1.png"></p>
<p>在 Baseline++ 中，权重矩阵 $\mathbf{W}_{b} \in \mathbb{R}^{d \times c}$ 可以被分为 $c$ 个 $d$ 维向量，每个向量表示一个类。在训练阶段，每一个输入特征，与 $c$ 个 $d$ 维向量计算 cos 相似度，之后用一个 softmax 函数对相似度进行 normalization。因此，分类结果选取相似度最大的权重向量所代表的类。因此，学到的权重向量可以看作每一类的 prototype，而分类器基于输入特征与学到的 prototype 的距离来运作。softmax 函数可防止学到的权重向量变为零向量。</p>
<p>Baseline++ 显著减少了类内（intra-class）变化性。当然，更深的骨干网络也能做到这一点。</p>
<hr>
<p>对比的方法包括 MatchingNet、ProtoNet、RelationNet、MAML：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/5-Figure2-1.png"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>三个场景对应的数据集：</p>
<ol>
<li>通用对象识别：mini-ImageNet；</li>
<li>细粒度图像分类：CUB-200-2011；</li>
<li>跨域自适应：mini-ImageNet (base class) -&gt; CUB (novel class)。</li>
</ol>
<h4 id="对比实验"><a href="#对比实验" class="headerlink" title="对比实验"></a>对比实验</h4><p>对比各方法在对应的论文公布的结果和本文作者实现的结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/7-Table1-1.png"></p>
<p>带<code>*</code>号的是没有进行数据增强的 Baseline。带<code>#</code>号指 way 数更多的 PropoNet。可以看到，数据增强能够有效缓解 Baseline 的过拟合，从而提升效果。</p>
<hr>
<p>在 mini-ImageNet 和 CUB 数据集上的实验结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/7-Table2-1.png"></p>
<p>可以看到，Baseline++ 可以与现有 SOTA 方法相媲美。同时，Baseline++ 要比 Baseline 表现好很多，说明<strong>减少类内变化是现在小样本分类问题设置中的一个重要因素</strong>。</p>
<h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p>考虑到一个更深的骨干网络也能够减少类内变化，因此在同一方法上换用不同的骨干网络比较效果，结果如下：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/8-Figure3-1.png"></p>
<p>可以看到，更深的骨干网络一般都能够提升各方法的效果。但在 mini-ImageNet 数据集的 5-shot 设置上，一些元方法的效果变差（一种看法是说明，在领域差异较大的情况下，随着特征提取能力的提高，这些方法性能差异越来越大）。考虑到 mini-ImageNet 数据集的基础类与新类的领域差异要比 CUB 数据集更大，因此，接下来通过实验分析这种域差异如何影响小样本分类的效果。</p>
<h4 id="分析领域差异大小对各方法的影响"><a href="#分析领域差异大小对各方法的影响" class="headerlink" title="分析领域差异大小对各方法的影响"></a>分析领域差异大小对各方法的影响</h4><p>即分析各方法的跨域能力。在 mini-ImageNet (base class) -&gt; CUB (novel class) 的 5-shot，骨干网络为 ResNet-18 的分类准确率效果如下：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/9-Table3-1.png"></p>
<p>在不同场景下的 5-shot，骨干网络为 ResNet-18 的分类准确率表现对比如下：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/9-Figure4-1.png"></p>
<p>可以看到，在 base class 和 novel class 域差异较大时，Baseline 模型表现相对较好。说明现有元学习方法难以适应于域差异与 base support class 过大的新类。而 Baseline 模型简单地基于少数新类别数据微调分类器，允许快速适应新类别并受领域漂移地影响较小。同时，Baseline 模型比 Baseline++ 方法表现更好，<strong>可能是因为额外减少类内变化会影响跨域的适应性</strong>。</p>
<h4 id="领域适应能力提升的影响"><a href="#领域适应能力提升的影响" class="headerlink" title="领域适应能力提升的影响"></a>领域适应能力提升的影响</h4><p>为了让小样本学习方法能够有更好的适应能力，对于 MatchingNet 和 ProtoNet，可以固定特征并训练一个新的 softmax 训练器；对于 MAML，由于初始化方法 MAML 无法固定特征，因此设置为 用 support 更新更多次迭代（实验中设置为 100 次）来训练新的分类层；对于 RelationNet，特征是卷积映射而非特征向量，因此无法用 softmax 替换。作为替代，将新类中的少数训练数据随机分为 3 个 support 和 2 个 query 数据，来用 100 个 epochs 微调关系模块。</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/9d5ec23154fb278a765f47ba5ee5150bd441d0de/9-Figure5-1.png"></p>
<p>实验表明，缺少适应是之前元学习方法比 Baseline 差的原因。因此，<strong>在元训练阶段学习去学会适应领域漂移，对于未来的元学习研究是一个重要方向</strong>。</p>
<h4 id="量化分析骨干网络深度对类内变化的影响"><a href="#量化分析骨干网络深度对类内变化的影响" class="headerlink" title="量化分析骨干网络深度对类内变化的影响"></a>量化分析骨干网络深度对类内变化的影响</h4><p>使用了 [1] 中的 Davies-Bouldin 指数，这是一种评估聚类（在本文中即为类）的紧密度的度量。结论是，使用更深的骨干网络时，base class 和 novel class 的特征的类内变化都会减少。</p>
<h3 id="个人笔记"><a href="#个人笔记" class="headerlink" title="个人笔记"></a>个人笔记</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>本文没有提出新颖的模型，而是指出小样本学习领域一些容易被忽视的问题，特别强调了骨干网络（特征提取网络）的能力、数据集的差异性以及领域自适应问题对小样本学习任务的影响。从帮助研究者认清小样本学习领域面临的挑战而言，本文是有价值的。</p>
<h2 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h2><ul>
<li>[1] David L Davies and Donald W Bouldin. A cluster separation measure. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1979.</li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>few-shot learning</tag>
        <tag>domain shift</tag>
        <tag>domain adaptation</tag>
        <tag>小样本学习</tag>
        <tag>领域漂移</tag>
        <tag>领域自适应</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】Adaptive Cross-Modal Few-Shot Learning</title>
    <url>/blog/AM3-notes/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/AM3-paper-title.png"></p>
<h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>本文提出了一种自适应模态混合机制，可以根据要学习的新图像类别自适应地组合来自视觉和语言两种模态的信息，比模态对齐方法更适用于小样本学习。</p>
<h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><ul>
<li>作者：Chen Xing, Negar Rostamzadeh, Boris N. Oreshkin, Pedro H. O. Pinheiro</li>
<li>出处：NeurIPS 2019</li>
<li>机构：Element AI, Montreal, Canada; Nankai University</li>
<li>关键词：few-shot learning, metric learning, multimodal</li>
<li><a href="https://arxiv.org/pdf/1902.07104.pdf">论文链接</a></li>
<li>开源代码：<a href="https://github.com/ElementAI/am3">ElementAI/am3</a></li>
<li>其他资料：<ul>
<li><a href="https://www.semanticscholar.org/paper/Adaptive-Cross-Modal-Few-Shot-Learning-Xing-Rostamzadeh/7d113621ab50a8b875a12cea3ad5b0263e9520ac">Semantic Scholar</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="内容简记"><a href="#内容简记" class="headerlink" title="内容简记"></a>内容简记</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当来自视觉模态的数据有限时，利用辅助模态（例如，属性，未标记的文本语料库）来帮助图像分类主要由无样本学习（Zero-Shot Learning, ZSL）驱动。与少样本学习（Few-Shot Learning, FSL）对比，无样本学习没有少量标记样本来帮助识别新类别。大多数方法在训练阶段将两种模态对齐，以此迫使模态被映射在一起并具有相同的语义结构。这样，来自辅助模态的知识在测试时被迁移到视觉方面用于识别新类别。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/AM3-Figure-1.png"></p>
<p>然而，视觉和自然语言语义特征根据定义具有不同的结构。对于不同的概念，视觉特征可能比文本特征更丰富和更具辨识度；而对于另一些概念，可能情况是相反的。此外，当图像数量非常少时，从视觉模态提供的信息往往是嘈杂和局部的，而（从无监督的文本语料库中学习的）语义表示可以提供强大的先验知识和上下文以帮助学习。在无样本学习中，测试阶段没有给视觉信息，因此算法只能完全依靠辅助模态（例如，文本）；而当有标记的图像样本数量很多时，神经网络倾向于忽略辅助模态，因为它已经有能力通过大量样本学会泛化。小样本学处于在这两个极端情况的中间态，因此我们可以假设视觉和语义信息都可用于小样本学习。</p>
<p>因此，比起将两种模态对齐并进行知识迁移，在测试阶段进行从两种模态获得信息的小样本学习时，最好<strong>将各模态视为独立的知识来源，并根据不同的场景自适应地利用不同的模态</strong>。</p>
<p>根据上述分析，本文提出<strong>自适应模态混合机制（Adaptive Modality Mixture Mechanism, AM3）</strong>，可以根据要学习的新图像类别自适应地组合来自两种模态的信息，用于小样本学习。</p>
<p>实验表明，效果超过当前的单模态小样本学习方法和模态对齐方法。另外，试验还表明，该模型可以有效调整其对两种模态的关注。当镜头数量非常小时，性能的提升特别高。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://d3i71xaburhd42.cloudfront.net/7d113621ab50a8b875a12cea3ad5b0263e9520ac/5-Figure2-1.png"></p>
<p>本文提出的自适应模态混合机制（Adaptive Modality Mixture Mechanism, AM3）可以应用于任何基于度量的方法。本文选用原型网络（Prototypical Networks）和 TADAM。对于类别 $c$，新的原型（prototype）计算如下：</p>
<p>$$<br>\mathbf{p}_{c}^{\prime}=\lambda_{c} \cdot \mathbf{p}_{c}+\left(1-\lambda_{c}\right) \cdot \mathbf{w}_{c}<br>$$</p>
<p>其中，$\mathbf{w}_{c}=g\left(\mathbf{e}_{c}\right)$ 是一个对于类别 $c$ 的标签嵌入的转换版本，$\mathbf{e}_{c}$ 是对于类别 $c$ 标签的预训练词向量，而转换 $g : \mathbb{R}^{n_{w}} \rightarrow \mathbb{R}^{n_{p}}$ 让两个模态处于同一空间并可以合并。$\lambda_{c}$ 是自适应混合系数（adaptive mixture coefficient）：</p>
<p>$$<br>\lambda_{c}=\frac{1}{1+\exp \left(-h\left(\mathbf{w}_{c}\right)\right)}<br>$$</p>
<p>$h$ 是自适应混合网络（adaptive mixing network）。自适应混合系数 $\lambda_{c}$ 可以根据不同的变量进行控制。</p>
<p>训练过程与原始的原型网络相似，只是距离度量变为</p>
<p>$$<br>p_{\theta}\left(y=c | q_{t}, S_{e}, \mathcal{W}\right)=\frac{\exp \left(-d\left(f\left(q_{t}\right), \mathbf{p}_{c}^{\prime}\right)\right)}{\sum_{k} \exp \left(-d\left(f\left(q_{t}\right), \mathbf{p}_{k}^{\prime}\right)\right)}<br>$$</p>
<p>损失是每个查询集样本的真类的负对数似然（the negative loglikelihood of the true class of each query sample）：</p>
<p>$$<br>\mathcal{L}(\theta)=\underset{\left(\mathcal{S}_{e}, \mathcal{Q}_{e}\right)}{\mathbb{E}}-\sum_{t=1}^{Q_{e}} \log p_{\theta}\left(y_{t} | q_{t}, \mathcal{S}_{e}\right)<br>$$</p>
<p>其中，$\mathcal{S}_{e}$ 是支撑集，$\mathcal{Q}_{e}$ 是查询集。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="对比实验"><a href="#对比实验" class="headerlink" title="对比实验"></a>对比实验</h4><p>数据集：</p>
<ul>
<li>miniImageNet [2]</li>
<li>tieredImageNet [3]</li>
<li>CUB-200 [4]：这是一个无样本学习数据集。考虑到大多数模态对齐方法没有在小样本学习数据集上有公开的实验结果，这个数据集用于将 AM3 与模态对齐方法进行对比</li>
</ul>
<p>本文在  和 tieredImageNet [3]，将 AM3 与三种基线进行对比：单模态 FSL 方法，模态对齐方法，模态对齐方法的基于度量的扩展。</p>
<p>baselines：</p>
<ul>
<li>单模态 FSL 方法：MAML、LEO [6]、原型网络、TADAM [5] 等；</li>
<li>模态对齐方法：CADA-VAE [7] 等；</li>
<li>模态对齐方法的基于度量的扩展：使用了基于度量的损失以及原型网络的训练方式（episode training）。</li>
</ul>
<p>在 miniImageNet 数据集上的分类结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/7d113621ab50a8b875a12cea3ad5b0263e9520ac/7-Table1-1.png"></p>
<p>在 tieredImageNet 数据集上的分类结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/7d113621ab50a8b875a12cea3ad5b0263e9520ac/7-Table2-1.png"></p>
<p>结论：</p>
<ol>
<li>在所有数据集上，AM3 的表现都优于其主干方法。说明在正确使用时，文本模态可以帮助提高基于度量的 FSL 学习框架的性能；</li>
<li>AM3（主干方法选用 TADAM）取得 SOTA，且当 shot 数（即样本数）越少时，效果提升越多。说明当视觉模态提供的信息越少时，语义信息对分类的帮助越大；</li>
<li>当扩展到基于度量、episodic、FSL 框架时时，所有模态对齐方法的表现都显著提升。然而扩展前后这些模态对齐方法都比单模态 FSL 方法的 SOTA 要差。说明尽管模态对齐方法对于 ZSL 中的跨模态是有效的，但并不适合 FSL。<strong>一个可能的原因是，两个不同的结构被迫对齐导致双方的一些信息可能损失</strong>。</li>
</ol>
<p>在 CUB-200 数据集上的分类结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/7d113621ab50a8b875a12cea3ad5b0263e9520ac/14-Table3-1.png"></p>
<p>结论：对于无样本学习场景，AM3 降级为最简单的模态对齐方法，将文本语义空间映射到视觉空间。因此，在没有自适应机制的情况下，AM3 的表现与 DeViSE 大致相同。说明自适应机制在 FSL 场景中观察到的性能提升中起主要作用。</p>
<h4 id="自适应机制分析"><a href="#自适应机制分析" class="headerlink" title="自适应机制分析"></a>自适应机制分析</h4><p>对本文提出的自适应机制进行定量分析：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/7d113621ab50a8b875a12cea3ad5b0263e9520ac/8-Figure3-1.png"></p>
<p>结论：</p>
<ol>
<li>当 shot 数（即样本数）增加时，AM3 与其主干方法的表现差距减小；</li>
<li>自适应混合系数 $\lambda_{c}$ 的平均值与 shot 数有关，当 shot 数减小时，AM3 在文本模态上的权重更大（在视觉模态上更小）。这种趋势表明，当视觉信息非常少时，AM3 可以自动将焦点更多地调整到文本模态以帮助分类；</li>
<li>当 $\lambda_{c}$ 的方差随着 shot 数增加而减小时，AM3 与其主干方法的性能差距也会缩小。这表明 AM3 在类别级别的适应性对性能提升有非常重要的作用（？？？觉得有点牵强）。</li>
</ol>
<h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="https://d3i71xaburhd42.cloudfront.net/7d113621ab50a8b875a12cea3ad5b0263e9520ac/15-Table4-1.png"></p>
<p>所以选用变换后的语义特征来做自适应机制是实验得到的最好选择。</p>
<h3 id="个人笔记"><a href="#个人笔记" class="headerlink" title="个人笔记"></a>个人笔记</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>我个人认为，转换 $g$ 本质上还是一种表示空间的强行对齐，会破坏模态本身的自然结构。因此，可能可以考虑一种更好的特征组合与自适应调整方式。</p>
<h2 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h2><ul>
<li>[1] Zero-shot learning-the good, the bad and the ugly, CVPR 2017.</li>
<li>[2] Matching networks for one shot learning, NIPS 2016.</li>
<li>[3] Meta-learning for semi-supervised few-shot classification, ICLR 2018.</li>
<li>[4] Caltech-UCSD Birds 200, Technical Report CNS-TR-2010-001, 2010.</li>
<li>[5] Tadam: Task dependent adaptive metric for improved few-shot learning, NeurIPS 2018.</li>
<li>[6] Meta-learning with latent embedding optimization, ICML 2016.</li>
<li>[7] Generalized zero-and few-shot learning via aligned variational autoencoders, CVPR 2019.</li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>few-shot learning</tag>
        <tag>小样本学习</tag>
        <tag>multimodal</tag>
        <tag>metric learning</tag>
        <tag>多模态</tag>
        <tag>度量学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】Composing Text and Image for Image Retrieval - An Empirical Odyssey</title>
    <url>/blog/TIRG-notes/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TIRG-paper-title.png"></p>
<h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>作为第一篇研究用于图像检索的图像与文本特征组合问题的论文，本文提出一种采用门控机制和残差连接的特征组合方式，确保修改后的特征处于目标图像特征处在相同空间中，并通过度量学习的方式达到 SOTA。</p>
<h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><ul>
<li>作者：Nam S. Vo, Lu Jiang, Chen Sun, Kevin Murphy, Li-Jia Li, Li Fei-Fei, James Hays</li>
<li>出处：CVPR 2019</li>
<li>机构：Google AI, Stanford</li>
<li>关键词：Image retrieval, multimodal, metric learning, feature composition</li>
<li><a href="http://openaccess.thecvf.com/content_CVPR_2019/papers/Vo_Composing_Text_and_Image_for_Image_Retrieval_-_an_Empirical_CVPR_2019_paper.pdf">论文链接</a></li>
<li>开源代码：<a href="https://github.com/google/tirg">https://github.com/google/tirg</a></li>
<li>其他资料：<ul>
<li><a href="https://www.semanticscholar.org/paper/Composing-Text-and-Image-for-Image-Retrieval-An-Vo-Jiang/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d">Semantic Scholar</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="内容简记"><a href="#内容简记" class="headerlink" title="内容简记"></a>内容简记</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/1-Figure1-1.png"></p>
<p>本文展示在一种典型的图像检索场景——用户使用已经找到的图像作为参考，然后用文本表达其与查询意图的差异，来检索相关图像——下的解决方案。这种场景与基于属性的产品检索密切相关，但不同之处在于文本可以由多个词语组成，而不是单个属性。</p>
<p>主要的研究问题在于当由两种不同的输入模态时，如何表示查询，即<strong>如何为查询学习有意义的跨模态特征组合以便找到目标图像</strong>。文本与图像间的特征组合方法，从简单的拼接、浅前馈网络，到先进的机制（如关系 [1] 或参数哈希 [2]）已经广泛应用于相关问题。在本文研究的问题中，文本应该修改查询图像的特征，但是希望修改后得到的特征向量和目标图像处在相同的空间。因此，本文提出<strong>“文本图像残差门控”（Text Image Residual Gating，TIRG）</strong>，通过<strong>门控机制和残差连接</strong>来让文本修改图片特征。该方法在三个数据集上达到 SOTA。</p>
<p>已有的特征组合方法（即本文进行比较的 baselines）：</p>
<ul>
<li>拼接输入 MLP；</li>
<li>Show and Tell [3]：用一个 LSTM 同时编码图像和文本，先输入图像特征，后输入文本单词。LSTM 的最后一个状态作为表征；</li>
<li>Attribute as Operator [4]：将文本编码为转移矩阵，并应用到图像特征上得到组合特征；</li>
<li>Parameter hashing [2]：已被编码的文本特征被散列为变换矩阵，用于替代 CNN 网络中的全连接层，以得到组合特征；</li>
<li>Relationship [1]：首先使用 CNN 提取图像的 2d 特征图（feature map），然后创建一组关系特征，每个特征是 2d 特征图中的 2 个局部特征与文本特征的拼接。这组特征被传入一个 MLP 中并将输出平均化以得到组合特征；</li>
<li>FiLM [5]：文本特征被用于预测调制特征（modulation features） $\gamma^{i}, \beta^{i} \in \mathbb{R}^{C}$，其中 $i$ 为层的索引（index），$C$ 为特征的数量。之后执行图像特征的仿射变换：$\phi_{x t}^{i}=\gamma^{i} \cdot \phi_{x}^{i}+\beta^{i}$。</li>
</ul>
<p>其中，本文提出的 TIRG 与 FiLM 的区别在于：</p>
<ul>
<li>TIRG 使用<strong>非线性变换</strong>（而非 FiLM 中的线性变换），具有更多可学习参数，使得能够对图像进行较为复杂的修改；</li>
<li>TIRG <strong>只修改单层的 CNN</strong>。修改尽可能少的层有助于确保修改的特征处于目标图像的相同空间中。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/4-Figure2-1.png"></p>
<p><strong>TIRG</strong> 的公式为：</p>
<p>$$<br>\phi_{x t}^{r g}=w_{g} f_{\mathrm{gate}}\left(\phi_{x}, \phi_{t}\right)+w_{r} f_{\mathrm{res}}\left(\phi_{x}, \phi_{t}\right)<br>$$</p>
<p>其中，$\phi_{x}$ 是 CNN 得到的查询图像特征，$\phi_{t}$ 是 LSTM 得到的文本特征；$f_{\text {gate }}, f_{\text {res }} \in \mathbb{R}^{W \times H \times C}$；$w_{g}, w_{r}$ 是用于平衡的可学习权重。</p>
<p><strong>门控机制</strong>的计算为：</p>
<p>$$<br>f_{\text {gate }}\left(\phi_{x}, \phi_{t}\right)=\sigma\left(W_{g 2} * {RELU}\left(W_{g 1} *\left[\phi_{x}, \phi_{t}\right]\right) \odot \phi_{x}\right.<br>$$</p>
<p>其中，$W_{g 1}$ 和 $W_{g 2}$ 都是 3x3 卷积核。$\phi_{t}$ 将沿着高度和宽度的尺寸广播（broadcast along the height and width dimension），使其形状与图像特征 $\phi_{x}$ 匹配。</p>
<p><strong>残差连接</strong>的计算为：</p>
<p>$$<br>f_{\text {res }}\left(\phi_{x}, \phi_{t}\right)=W_{r 2} * {RELU}\left(W_{r 1} *\left(\left[\phi_{x}, \phi_{t}\right]\right)\right)<br>$$</p>
<p>TIRG 的直观理解是我们只想根据文本特征“修改”图像特征，而不是创建一个完全不同的特征空间。门控机制被设计成保留某些与文本修改无关的查询图像特征。</p>
<h4 id="训练方法"><a href="#训练方法" class="headerlink" title="训练方法"></a>训练方法</h4><p>训练目标是使“修改后”的图像特征与目标图像特征尽可能接近，同时使与非目标图像特征尽可能远离。因此，采用每次采样一个正例和 B 个负例计算损失，并重复 M 次，公式为：</p>
<p>$$<br>L=\frac{-1}{M B} \sum_{i=1}^{B} \sum_{m=1}^{M} \log \left\{\frac{\exp \left\{\kappa\left(\psi_{i}, \phi_{i}^{+}\right)\right\}}{\sum_{\phi_{j} \in \mathcal{N}_{i}^{m}} \exp \left\{\kappa\left(\psi_{i}, \phi_{j}\right)\right\}}\right\}<br>$$</p>
<p>其中 $\kappa$ 是相似度计算函数，在实现中采用点积或负欧式距离（为负时越小的距离能够获得更高的分数）。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="对比实验"><a href="#对比实验" class="headerlink" title="对比实验"></a>对比实验</h4><p>在三个数据集上进行实验：Fashion200k [6]，MIT-States [7]，本文提出的 CSS 数据集。三个数据集的区别在于，前两个数据集图像中物体不变，属性之一发生变化；而 CSS 数据集的变化更加复杂，可以增加、减少处于某个位置的物体，也可以改变物体的属性；前两个数据集的图像内容较为丰富，而 CSS 数据集的图像是生成的规律几何体摆放，且有 2D 和 3D 两种图像。</p>
<p>主要评价指标为 recall at rank k (R@K)，即正确的图像（即标签）在前 K 个检索出的图像中的百分比。MIT-States 同时汇报分类结果。本文提出的 TIRG 均达到 SOTA。</p>
<p>在 Fashion200k 和 MIT-States 数据集上的检索结果如下：</p>
<p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/5-Table1-1.png"></p>
<p>在 MIT-States 数据集上的分类结果如下：</p>
<p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/6-Table3-1.png"></p>
<p>在 CSS 数据集上的检索结果如下：</p>
<p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/7-Table4-1.png"></p>
<h4 id="从组合特征中重建图像"><a href="#从组合特征中重建图像" class="headerlink" title="从组合特征中重建图像"></a>从组合特征中重建图像</h4><p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/8-Figure6-1.png"></p>
<p>为了更深入地了解组合特征的本质，本文训练了一个转置卷积网络（transposed convolutional network），学习从查询图像的特征中重建图像，然后将其应用于组合特征。对比直接拼接、FiLM 和本文的 TIRG 三种方法得到的组合特征的重建图像。从 TIRG 特征表示生成的图像看起来更好，并且更接近目标图像。</p>
<h4 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h4><p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fd5129e8ebfaa5dcce3d4ce2839b90c6cd3ca39d/7-Table5-1.png"></p>
<ol>
<li>去除残差连接和门控机制都会使模型表现显著变差；</li>
<li>TIRG 的特征修改可发生在最后一个卷积层或最后一个全连接层。实验表明，对于 Fashion200k 和 MIT-States 数据集在最后一个全连接层进行特征修改，以及对于 CSS 数据集在最后一个卷积层进行特征修改，效果更好。作者认为这是因为在 CSS 数据集上的修改更加空间局部化，而在其他两个数据集上的修改更加全局化；</li>
<li>设置训练时的每次采样的样本数量为 2（即损失变为 soft triplet loss）或 B（即实验中原本的设置）。当采样大小为 2 时，会发现对于 Fashion200k 这样较大的数据集，网络会欠拟合；而当采样大小为 B 时，网络对 Fashion200k 数据集拟合更好并得到更好的结果，但是对于其他两个数据集训练变得不稳定。</li>
</ol>
<h3 id="个人笔记"><a href="#个人笔记" class="headerlink" title="个人笔记"></a>个人笔记</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>实现预训练的 CNN 和 LSTM</strong></p>
<p>CNN：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">img_model = torchvision.models.resnet18(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>LSTM：</p>
<p>源码自己实现了一个应用于文本的 LSTM，详见 <a href="https://github.com/google/tirg/blob/master/text_model.py">text_model.py</a>。</p>
<!-- 暂时还没搞懂是怎么将 one-hot 向量转为词嵌入的，是 
torch.nn.Embedding：https://pytorch.org/docs/stable/nn.html?highlight=torch%20nn%20embedding#torch.nn.Embedding 吗？ -->

<p><strong>实现可学习权重 w_g，w_r</strong></p>
<!-- 用 torch.nn.Linear 不太好实现 -->

<p>通过<code>torch.nn.Parameter</code>将张量添加到参数列表中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.a = torch.nn.Parameter(torch.tensor([<span class="number">1.0</span>, <span class="number">10.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">f = F.sigmoid(f1) * img_features * self.a[<span class="number">0</span>] + f2 * self.a[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 但是没有理解为什么只使用两个值，初始化时要用长度为 4 的向量</span></span><br></pre></td></tr></table></figure>

<p><strong>将文本特征沿着高度和宽度的尺寸广播后与图像特征拼接</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">y = text_features</span><br><span class="line">y = y.reshape((y.shape[<span class="number">0</span>], y.shape[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>)).repeat(<span class="number">1</span>, <span class="number">1</span>, x.shape[<span class="number">2</span>], x.shape[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># x 为图像特征</span></span><br><span class="line">z = torch.cat((x, y), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>实现在最后一个卷积层修改特征</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TIRGLastConv</span>(<span class="params">ImgEncoderTextEncoderBase</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;The TIGR model with spatial modification over the last conv layer.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  The method is described in</span></span><br><span class="line"><span class="string">  Nam Vo, Lu Jiang, Chen Sun, Kevin Murphy, Li-Jia Li, Li Fei-Fei, James Hays.</span></span><br><span class="line"><span class="string">  &quot;Composing Text and Image for Image Retrieval - An Empirical Odyssey&quot;</span></span><br><span class="line"><span class="string">  CVPR 2019. arXiv:1812.07119</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, texts, embed_dim</span>):</span></span><br><span class="line">    <span class="built_in">super</span>(TIRGLastConv, self).__init__(texts, embed_dim)</span><br><span class="line"></span><br><span class="line">    self.a = torch.nn.Parameter(torch.tensor([<span class="number">1.0</span>, <span class="number">10.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]))</span><br><span class="line">    self.mod2d = torch.nn.Sequential(</span><br><span class="line">        torch.nn.BatchNorm2d(<span class="number">512</span> + embed_dim),</span><br><span class="line">        torch.nn.Conv2d(<span class="number">512</span> + embed_dim, <span class="number">512</span> + embed_dim, [<span class="number">3</span>, <span class="number">3</span>], padding=<span class="number">1</span>),</span><br><span class="line">        torch.nn.ReLU(),</span><br><span class="line">        torch.nn.Conv2d(<span class="number">512</span> + embed_dim, <span class="number">512</span>, [<span class="number">3</span>, <span class="number">3</span>], padding=<span class="number">1</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    self.mod2d_gate = torch.nn.Sequential(</span><br><span class="line">        torch.nn.BatchNorm2d(<span class="number">512</span> + embed_dim),</span><br><span class="line">        torch.nn.Conv2d(<span class="number">512</span> + embed_dim, <span class="number">512</span> + embed_dim, [<span class="number">3</span>, <span class="number">3</span>], padding=<span class="number">1</span>),</span><br><span class="line">        torch.nn.ReLU(),</span><br><span class="line">        torch.nn.Conv2d(<span class="number">512</span> + embed_dim, <span class="number">512</span>, [<span class="number">3</span>, <span class="number">3</span>], padding=<span class="number">1</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compose_img_text</span>(<span class="params">self, imgs, texts</span>):</span></span><br><span class="line">    text_features = self.extract_text_feature(texts)</span><br><span class="line"></span><br><span class="line">    x = imgs</span><br><span class="line">    x = self.img_model.conv1(x)</span><br><span class="line">    x = self.img_model.bn1(x)</span><br><span class="line">    x = self.img_model.relu(x)</span><br><span class="line">    x = self.img_model.maxpool(x)</span><br><span class="line"></span><br><span class="line">    x = self.img_model.layer1(x)</span><br><span class="line">    x = self.img_model.layer2(x)</span><br><span class="line">    x = self.img_model.layer3(x)</span><br><span class="line">    x = self.img_model.layer4(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># mod</span></span><br><span class="line">    y = text_features</span><br><span class="line">    y = y.reshape((y.shape[<span class="number">0</span>], y.shape[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>)).repeat(</span><br><span class="line">        <span class="number">1</span>, <span class="number">1</span>, x.shape[<span class="number">2</span>], x.shape[<span class="number">3</span>])</span><br><span class="line">    z = torch.cat((x, y), dim=<span class="number">1</span>)</span><br><span class="line">    t = self.mod2d(z)</span><br><span class="line">    tgate = self.mod2d_gate(z)</span><br><span class="line">    x = self.a[<span class="number">0</span>] * F.sigmoid(tgate) * x + self.a[<span class="number">1</span>] * t</span><br><span class="line"></span><br><span class="line">    x = self.img_model.avgpool(x)</span><br><span class="line">    x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">    x = self.img_model.fc(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<h2 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h2><ul>
<li>[1] A simple neural network module for relational reasoning, NIPS 2017.</li>
<li>[2] Image question answering using convolutional neural network with dynamic parameter prediction, CVPR 2016.</li>
<li>[3] Show and tell: A neural image caption generator, CVPR 2015.</li>
<li>[4] Attributes as operators, 2018.</li>
<li>[5] Film: Visual reasoning with a general conditioning layer, 2018.</li>
<li>[6] Automatic spatially-aware fashion concept discovery, ICCV 2017.</li>
<li>[7] Discovering states and transformations in image collections, CVPR 2015.</li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>multimodal</tag>
        <tag>metric learning</tag>
        <tag>多模态</tag>
        <tag>度量学习</tag>
        <tag>image retrieval</tag>
        <tag>feature composition</tag>
        <tag>图像检索</tag>
        <tag>特征组合</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】Prototypical Networks for Few-shot Learning</title>
    <url>/blog/ProtoNet-notes/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ProtoNet-paper-title.png"></p>
<blockquote>
<p>一直没有完整看过这篇论文。这两天在复现 Prototypical Networks 时发现自己对 metric-based few-shot learning 的认知上存在一些问题，于是决定把这篇经典论文拿出来好好读一遍。</p>
</blockquote>
<h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>本文提出了原型网络（Prototypical Networks），通过将每个类别的样本求均值得到每个类的原型表示（prototypical representation），简化了 n-shot 分类时 n &gt; 1 的情况，并可以将最近邻分类器成功应用在小样本分类问题上。基于度量学习的小样本学习方法因为这篇经典论文的出世从此自成一派。</p>
<h2 id="论文信息"><a href="#论文信息" class="headerlink" title="论文信息"></a>论文信息</h2><ul>
<li>作者：Jake Snell, Kevin Swersky, Richard S. Zemel</li>
<li>出处：NIPS 2017</li>
<li>机构：Twitter; University of Toronto</li>
<li>关键词：few-shot learning, metric learning</li>
<li><a href="https://arxiv.org/pdf/1703.05175.pdf">论文链接</a></li>
<li>开源代码：<ul>
<li><a href="https://github.com/jakesnell/prototypical-networks">jakesnell/prototypical-networks</a></li>
<li><a href="https://github.com/orobix/Prototypical-Networks-for-Few-shot-Learning-PyTorch">orobix/Prototypical-Networks-for-Few-shot-Learning-PyTorch</a></li>
</ul>
</li>
<li>其他资料：<ul>
<li><a href="https://www.semanticscholar.org/paper/Prototypical-Networks-for-Few-shot-Learning-Snell-Swersky/c269858a7bb34e8350f2442ccf37797856ae9bca">Semantic Scholar</a></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="内容简记"><a href="#内容简记" class="headerlink" title="内容简记"></a>内容简记</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><img src="https://d3i71xaburhd42.cloudfront.net/c269858a7bb34e8350f2442ccf37797856ae9bca/2-Figure1-1.png"></p>
<p>考虑到小样本分类问题上数据量受到限制，分类器应该有一个非常简单的归纳偏执（根据 [1]，我认为是因为这样可以减小所需要的样本复杂性）。<strong>原型网络（Prototypical Networks）</strong>基于“存在一个嵌入空间，使得对于每一类存在一个原型表征，该类中的所有点都围绕着这个原型表征”的假设。在实现上，使用一个神经网络来实现输入到嵌入空间的非线性映射，每类的原型选择嵌入空间中该类的支持集的均值。而对于新的查询样本的分类通过简单地查找最近邻类别原型来实现。</p>
<p>零样本学习问题中，新的（或者说训练阶段不可见的）类别不再包含少量的有标签数据，而是每一类会提供一些元数据（或者称为辅助信息），例如属性、描述等。在实现上，即是每一类有一个元数据向量。因此，对于零样本学习，Prototypical Network 学习将元数据嵌入到一个共享空间中来作为类别原型。也就是说，类别原型和查询原型不来自同一个域。</p>
<h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><h4 id="作为混合密度估计"><a href="#作为混合密度估计" class="headerlink" title="作为混合密度估计"></a>作为混合密度估计</h4><p>Prototypical Network 的学习过程可以理解为混合概率估计。Bregman 散度是一类特别的距离度量，包含欧式距离和 Mahalanobis 距离。采用 Bregman 散度时，聚类中心即是整个簇最具代表性的点（即质心），使得该类的所有点到质心的总距离之和最小。因此，Prototypical Network 使用类均值作为原型表示，并采用欧氏距离度量。而对于 Matching Network [2] 采用的余弦距离，满足满足和簇的其他点之间总距离最小的质心是使信息损失最小化的点。</p>
<h4 id="作为线性模型进行解释"><a href="#作为线性模型进行解释" class="headerlink" title="作为线性模型进行解释"></a>作为线性模型进行解释</h4><p>当使用欧氏距离时 $d\left(\mathbf{z}, \mathbf{z}^{\prime}\right)=\left|\mathbf{z}-\mathbf{z}^{\prime}\right|^{2}$，softmax 的内部可以相当于有特定参数的线性模型。具体来说，将欧式距离展开得到</p>
<p>$$<br>-\left|f_{\phi}(\mathbf{x})-\mathbf{c}_{k}\right|^{2}=-f_{\phi}(\mathbf{x})^{\top} f_{\phi}(\mathbf{x})+2 \mathbf{c}_{k}^{\top} f_{\phi}(\mathbf{x})-\mathbf{c}_{k}^{\top} \mathbf{c}_{k}<br>$$</p>
<p>其中，第一项对于类别 k 来说是常量，不影响 softmax 的概率结果；而后两项可以写为</p>
<p>$$<br>2 \mathbf{c}_{k}^{\top} f_{\phi}(\mathbf{x})-\mathbf{c}_{k}^{\top} \mathbf{c}_{k}=\mathbf{w}_{k}^{\top} f_{\phi}(\mathbf{x})+b_{k}, \text { where } \mathbf{w}_{k}=2 \mathbf{c}_{k} \text { and } b_{k}=-\mathbf{c}_{k}^{\top} \mathbf{c}_{k}<br>$$</p>
<p>因此变为一个线性模型。</p>
<p>本文猜想，嵌入函数内部已经包含所需要的非线性转换，因此可以直接使用欧氏距离，使得方法更加简单有效。</p>
<h4 id="与-Matching-Network-的比较"><a href="#与-Matching-Network-的比较" class="headerlink" title="与 Matching Network 的比较"></a>与 Matching Network 的比较</h4><p>Matching Network 在给定支持集的情况下生成一个加权最近邻分类器，而 Prototypical Network 使用欧氏距离生成一个线性分类器。当支持集中每个类只有一个样本时，二者等价。Matching Network 有相对复杂的结构，而 Prototypical Network 采用简单的设计达到相当甚至更好的效果。</p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><h4 id="对比实验"><a href="#对比实验" class="headerlink" title="对比实验"></a>对比实验</h4><p>在小样本分类问题上，本文在 Omniglot 数据集上的结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/c269858a7bb34e8350f2442ccf37797856ae9bca/6-Table1-1.png"></p>
<p>在 miniImageNet 数据集上的结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/c269858a7bb34e8350f2442ccf37797856ae9bca/6-Table2-1.png"></p>
<p>在零样本分类问题上，本文在 CUB 数据集上的结果：</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/c269858a7bb34e8350f2442ccf37797856ae9bca/7-Table3-1.png"></p>
<p>另外有一些有趣的结论。下图的实验结果证明：</p>
<ol>
<li>当训练阶段在一个任务中使用更多的类别数时，测试进行 5-way 分类的结果更好；</li>
<li>比起 Matching Network 采用的余弦距离，欧式距离在 Prototypical Network 上的效果更好。原因已在前文进行解释。</li>
</ol>
<p><img src="https://d3i71xaburhd42.cloudfront.net/c269858a7bb34e8350f2442ccf37797856ae9bca/7-Figure3-1.png"></p>
<h3 id="个人笔记"><a href="#个人笔记" class="headerlink" title="个人笔记"></a>个人笔记</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>简单聊一聊实现上的事情。我之前以为，在 metric-based few-shot learning 中，loss 是从 meta-train 的 training data 上得到的，因此。这是一个没实现过小样本学习方法，只凭借监督问题上的经验容易产生的误区。在小样本学习中，要抛弃掉 training data 和 test data 的概念，用支持集（support set）和查询集（query set）来代表会更好地理解。模型训练阶段的 loss 实际上是由 meta-train 的 query set 得到的，因此，实际上 Prototypical Network 在 meta-test 阶段也不存在微调了，直接用 query prototype 来进行最近邻分类得到准确率。</p>
<p>有一个问题是，零样本学习任务中，本文提出可用固定原型embedding的长度为单位长度，对query embedding不限制。没有很看懂这个设置，这个反映到代码里是怎么实现的？但是源码中没有给出零样本学习部分的代码，有点难受。</p>
<!-- 还有一个问题是，发现虽然小样本分类的论文绝大部分都在同样的几个数据集（以 Omniglot，miniImageNet，tiredImageNet，CUB 为主）上进行评估，但是目前还没有一套固定的预处理和训练优化器和超参数设置。因此，想要直接使用很多篇论文的实验结果进行比较（而不用自己实现的实验结果）有些困难。当然这也是正常情况了，就是需要自己找一套能够说服评审的设置了。-->


<h2 id="参考论文"><a href="#参考论文" class="headerlink" title="参考论文"></a>参考论文</h2><ul>
<li>[1] Generalizing from a Few Examples: A Survey on Few-Shot Learning, arXiv:1904.05046v2.</li>
<li>[2] Oriol Vinyals, Charles Blundell, Tim Lillicrap, Daan Wierstra, et al. Matching networks for one shot learning. In Advances in Neural Information Processing Systems, pages 3630–3638, 2016.</li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>few-shot learning</tag>
        <tag>小样本学习</tag>
        <tag>metric learning</tag>
        <tag>度量学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】Recurrent Neural Network for Text Classification with Multi-Task Learning</title>
    <url>/blog/1605-05101-notes/</url>
    <content><![CDATA[<p>原文链接：<a href="http://www.ijcai.org/Proceedings/16/Papers/408.pdf">Recurrent Neural Network for Text Classification with Multi-Task Learning</a></p>
<p>作者：Pengfei Liu, Xipeng Qiu, Xuanjing Huang</p>
<p>单位：复旦大学 自然语言处理与深度学习组</p>
<p>文章来源：IJCAI 2016</p>
<p>简介：本文针对文本多分类任务，提出了基于 RNN 的三种不同的共享信息机制，在四个基准的文本分类任务中取得了较好的结果。</p>
<h2 id="研究概况"><a href="#研究概况" class="headerlink" title="研究概况"></a>研究概况</h2><h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>假设多个任务之间具有相关性，**<a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Structuring_Machine_Learning_Projects/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88ML%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%882%EF%BC%89?id=%e5%a4%9a%e4%bb%bb%e5%8a%a1%e5%ad%a6%e4%b9%a0">多任务学习</a>**利用任务之间的相关性相互促进，通过并行学习任务来提高分类效果。这些模型的基本的多任务架构将共享一些较低的层以确定共同的特性。在共享层之后，每个特定任务单独使用一个输出层。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/Andrew-Ng-Deep-Learning-notes/master/docs/Structuring_Machine_Learning_Projects/Shared-Representation.png" alt="Shared-Representation"></p>
<h3 id="前人工作和不足"><a href="#前人工作和不足" class="headerlink" title="前人工作和不足"></a>前人工作和不足</h3><p>基于神经网络的多任务学习已被用于解决 NLP 的各类任务。例如：</p>
<ul>
<li>使用一个对于输入单词的共享表示：用途是解决词性标注、语义角色标注等传统 NLP 任务。缺点是只有一张查找表是共享的、其他查找表和层是任务特定的，并且需要用基于窗口的方法处理长度不定的文本序列；</li>
<li>多任务 DNN 来学习表示：用途是解决查询分类和网络搜索排名任务。缺点是模型输入为词袋表示，损失了词序信息。</li>
</ul>
<p>不同于以上两种方法，本文的模型基于 RNN，对于建模变长文本序列更友好。</p>
<h3 id="本文工作"><a href="#本文工作" class="headerlink" title="本文工作"></a>本文工作</h3><p>基于 RNN，提出了三种不同的共享信息机制，可以将信息共享到特定任务层的共享层。整个网络都是在所有这些任务上共同训练的。模型在四个基准的文本分类任务上展示了很好的效果，超过了大多数的 state-of-the-art。</p>
<!--### 意义和创新点-->

<span id="more"></span>

<h2 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/1605-05101/three-architectures.png"></p>
<ul>
<li>模型一（Uniform-layer Architecture）：对于每个分类任务，在每个输入 character 的 embedding vector 后拼上一个随机生成的可训练向量，表示该特定任务，所有任务共享 LSTM 层，最后一个 时刻的 hidden state 则作为输入传入 softmax；</li>
<li>模型二（Coupled-layer Architecture）：每个任务具有自己独立的 LSTM 层，但是每一时刻所有任务的 hidden state 则会和下一时刻的 character 一起作为输入，最后一个时刻的 hidden state 进行分类；</li>
<li>模型三（Shared-layer Architecture）：除了一个共享的 Bi-LSTM 层用于获取共享信息，每个任务有自己独立的 LSTM 层，LSTM 的输入包括每一时刻的 character 和 Bi-LSTM 的 hidden state。</li>
</ul>
<!--大概可以加公式？-->

<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>对于模型一和模型三，具有一个共享层。在联合学习阶段之后可以进行<strong>微调（Fine Tuning）</strong>来进一步优化每个任务的性能。</p>
<p>对于模型三，共享层可以由无监督的预训练阶段初始化，用四个任务数据集进行语言模型的训练。</p>
<p>训练方法：</p>
<ol>
<li>随机选择一项任务；</li>
<li>从该任务中随机选择一个训练样本；</li>
<li>根据基于梯度的优化（paper 中使用 Adagrad update rule）来更新参数；</li>
<li>重复 1-3 步。</li>
</ol>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/1605-05101/datasets.png"></p>
<ul>
<li>SST-1：5 个情绪类别的电影影评，来自斯坦福情感数据库</li>
<li>SST-2：二分类电影影评，来自斯坦福数据库</li>
<li>SUBJ：主观性数据集，任务目的是将句子分为主观和客观</li>
<li>IMDB：二分类的电影影评，大多数评价为长句子</li>
</ul>
<h3 id="超参数与训练"><a href="#超参数与训练" class="headerlink" title="超参数与训练"></a>超参数与训练</h3><p>使用 word2vec 在维基语料获得词向量，字典规模约 500,000。词嵌入在训练过程中被微调以提高性能；其他参数在 [-0.1, 0.1] 的范围随机采样，超参数将选择在验证集上性能最好的一组。对于没有验证集的数据集使用 10 折交叉验证。</p>
<p>特定任务和共享层的嵌入大小为 64。对于模型一，每个单词有两个嵌入，大小都为 64。LSTM 的隐藏层大小为 50。初始学习率为 0.1。参数的正则化权值为 10^-5。</p>
<h3 id="结果比较"><a href="#结果比较" class="headerlink" title="结果比较"></a>结果比较</h3><p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/1605-05101/results-of-model-i.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/1605-05101/results-of-model-ii.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/1605-05101/results-of-model-iii.png"></p>
<h3 id="与-state-of-the-art-相比较"><a href="#与-state-of-the-art-相比较" class="headerlink" title="与 state-of-the-art 相比较"></a>与 state-of-the-art 相比较</h3><p>将模型三和下列模型进行比较：</p>
<!--* NBOW：对词向量求和，并应用一个非线性项，之后一个 softmax 分类层；
* MV-RNN：
* RNTN：
* DCNN：
* PV：
* Tree-LSTM：-->

<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/1605-05101/compare-to-state-of-the-art.png"></p>
<p>paper 中的多任务模型和其他基于 RNN 的模型（例如 Tree-LSTM）是兼容的，可以合并以扩展。</p>
<h3 id="了解模型"><a href="#了解模型" class="headerlink" title="了解模型"></a>了解模型</h3><p>从 SST-2 的测试集中采样，看在单个 LSTM 和含共享层的 LSTM 中，句子中每个单词对预测的情绪分数的影响。具体方式是观察全局门（global gates）的激活值，这个值控制一个 LSTM 分享层到一个特定任务层的信号流，使我们能够了解神经元的行为。</p>
<p>例如，“marry”一词使得激活值升高，说明特定任务层从共享层得到很多信息，从而使预测更准确。</p>
<p>通过分析，单个 LSTM 无法捕捉到“but … higher than”的结构，但是 paper 中的模型对其敏感，说明共享层不仅增强了特定词的意义，并且帮助特定任务学到结构信息。</p>
<h3 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h3><p>该模型的错误案例可分为两种：</p>
<ol>
<li>一些含有非常复杂的结构的句子不能被适当处理，例如二次否定、虚拟语气。对于这些情况，在结构上可以做一些改进，比如基于树的 LSTM；</li>
<li>某些句子难以从书面意思判断其情绪，例如“I tried to read the time on my watch.”</li>
</ol>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>多任务学习</tag>
        <tag>文本分类</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】基于 Web 的问答系统综述</title>
    <url>/blog/survey-on-web-based-question-answering-notes/</url>
    <content><![CDATA[<p>原文链接：<a href="http://www.jsjkx.com/jsjkx/ch/reader/create_pdf.aspx?file_no=20170601&flag=&journal_id=jsjkx&year_id=2017">基于 Web 的问答系统综述</a></p>
<p>作者：李舟军，李水华</p>
<p>简介：详细介绍了基于 Web 的问答系统的研究背景、架构及其问题分析、信息检索、答案抽取这三大关键技术的研究进展，并分析了基于 Web 的问答系统所面临的问题。</p>
<p>选读原因：选了一篇中文的基于 Web 的问答系统综述，和手头上工作比较贴近，来对接下来的研究方向有个大致的了解和思考，因此记录也比较详细。</p>
<span id="more"></span>

<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>问答系统（Question Answering, QA）</strong>以自然语言为输入与输出，理解用户的查询意图后，通过一系列的检索、分析与处理，返回精确、简练的答案。</p>
<p>根据问答系统知识来源的不同，该文将问答系统分为 3 类：</p>
<ol>
<li><strong>基于知识库的问答系统（Qustion Answering over Knowledge Bases, KBQA）</strong>：主要以知识库作为问答系统的知识来源；</li>
<li><strong>基于社区的问答系统（Community-based Question Answering, CQA）</strong>：主要以问答社区（如知乎、百度知道等）作为问答系统的知识来源；</li>
<li><strong>基于 Web 的问答系统（Web-based Question Answering, WQA）</strong>：以开放的互联网上的 Web 文档作为问答系统的知识来源，从搜索引擎上返回的相关网页片段中抽取出用户所提问题的答案。</li>
</ol>
<p>其中，WQA 系统同时具有搜索引擎和问答系统的优点，与时俱进，不断更新。</p>
<h3 id="WQA-系统"><a href="#WQA-系统" class="headerlink" title="WQA 系统"></a>WQA 系统</h3><p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/Architecture-of-question-answering-system.png" alt="Architecture-of-question-answering-system"></p>
<p>经典的 WQA 系统通常由以下 3 个模块构成（其他 QA 系统各模块大体一致，功能有所不同。上图来源[1]）：</p>
<ol>
<li><strong>问题分析模块</strong>：根据用户的查询意图生成相应的查询语句，可能包含对问题的分类、提取问题的关键词或者生成一些其他描述用户查询意图的中间数据；</li>
<li><strong>信息检索模块</strong>：将问题分析模块得到的查询语句或关键词提交给搜索引擎，并整理返回的搜索结果来得到可能包含正确答案的网页片段（性能瓶颈）；</li>
<li><strong>答案抽取模块</strong>：利用信息抽取技术，从网页片段中抽取答案，可能需要用到问题分析模块得到的问题类别、关键词等数据。</li>
</ol>
<h4 id="问题分析模块"><a href="#问题分析模块" class="headerlink" title="问题分析模块"></a>问题分析模块</h4><p>流程：</p>
<ol>
<li>分词</li>
<li>问题分类：问题的类别是反应用户提问意图的重要信息</li>
<li>问题重写：便于搜索引擎理解问题语义</li>
</ol>
<h5 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h5><p>问题分类的作用体现在：</p>
<ul>
<li><strong>能够有效减少候选答案空间，提高系统返回答案的准确性</strong>。例如，一个问句被分类为时间类，则在答案抽取阶段，系统把不含时间的候选句子过滤掉；</li>
<li><strong>决定答案喧杂策略，根据不同的问句类型调节对不同问题的答案选择策略</strong>。例如，对于“安徽省的简称是什么”，分析出其询问地点类别，抽取文档库中地点类的文档作为候选答案。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/question-classifier.png" alt="问题分类体系"></p>
<p>表一为国际权威的 UIUC 问句分类体系，针对英文分类。表二是哈工大定义的中文问句分类体系。</p>
<p>很多 WQA 系统采用规则分类器对问题进行分类。最简单的规则可以是通过问题是否包含某个词来分类，而比较复杂的规则包括基于语义模式匹配的问题分类[2]。如果没有一条规则能够与问题匹配成功，则借助一些统计机器学习的方法分类，例如 SVM、RNN 等。</p>
<h5 id="关键词提取和扩展"><a href="#关键词提取和扩展" class="headerlink" title="关键词提取和扩展"></a>关键词提取和扩展</h5><p>关键词既可作为搜索引擎的输入，也可辅助答案的抽取过程。WQA 系统通常在分词、取出停用词之后进行关键词的提取，并将名词、动词、形容词等作为关键词。因此可以用一些简单规则提取，例如“所有带形容词的名词都是关键词”等。也可以分析问题的语法结构，抽取主语、宾语作为关键词[3]。</p>
<p>关键词的扩展主要用于解决关键词的同义词的匹配问题，通常需要一些同义词词库进行辅助。</p>
<h5 id="问题重写"><a href="#问题重写" class="headerlink" title="问题重写"></a>问题重写</h5><p>当问题本身（而非关键词）作为搜索引擎的输入时，可能较难领会语义，此时需要对问题进行重写。一些启发式的方法依靠简单的字符串操作（替换、拼接、删除）来实现问题重写，也有较为复杂的优化方法，例如定义一个针对问题的操作集合，然后利用概率模型选择最合适的操作来重写问题[4]。</p>
<h4 id="信息检索模块"><a href="#信息检索模块" class="headerlink" title="信息检索模块"></a>信息检索模块</h4><p>信息检索模块的实现可以调用搜索引擎提供的接口，也可以利用爬虫技术。搜索引擎所具有的高质量摘要技术能过滤原始网页的噪音数据，因此无需抓取解析原始网页。</p>
<h4 id="答案抽取模块"><a href="#答案抽取模块" class="headerlink" title="答案抽取模块"></a>答案抽取模块</h4><p>答案抽取模块是 WQA 系统中的重点和难点，通常包括两个步骤：</p>
<ol>
<li>候选答案抽取：从网页片段中抽取出候选答案；</li>
<li>候选答案排序：对候选答案进行排序，得到最佳答案。</li>
</ol>
<h5 id="候选答案抽取"><a href="#候选答案抽取" class="headerlink" title="候选答案抽取"></a>候选答案抽取</h5><p>抽取候选答案的几种典型方法：</p>
<ol>
<li>手工编辑或自动生成名词词典，将词典中的所有名词都作为候选答案。这种做法的候选答案集非常大，因此候选答案排序以及维护难度很大，难以更新以应对新的领域和新的概念；</li>
<li>利用<strong>命名实体识别（Named Entity Recognition, NER）</strong>工具，抽取命名实体作为候选答案。具体效果受问题分类算法和命名实体识别算法效果的影响；</li>
<li>根据手工编辑或自动生成的文本模式抽取候选答案。准确率较高，但匹配较为死板，无法适应新的数据。</li>
</ol>
<h5 id="候选答案排序"><a href="#候选答案排序" class="headerlink" title="候选答案排序"></a>候选答案排序</h5><p>候选答案排序及最佳答案选择的几种典型方法：</p>
<ol>
<li>采用<strong>向量空间模型（Vector Space Model, VSM）</strong>计算候选答案与问题的相似度，并以此进行排序[5]；</li>
<li>根据语法结构判断候选答案与问题的匹配度，并以此进行排序；</li>
<li>根据词汇特征、相似度特征、统计特征等多种特征进行综合排序。</li>
</ol>
<h3 id="WQA-面临的主要问题"><a href="#WQA-面临的主要问题" class="headerlink" title="WQA 面临的主要问题"></a>WQA 面临的主要问题</h3><ol>
<li>问题分类有待改善：问题分类的本质是短文本分类，受限于特征稀缺，分类器效果有待提升；</li>
<li>同义句子的理解需要解决：同义词的使用和句法结构的变化使得 WQA 系统难以准确抽取答案；</li>
<li>高质量的 QA 对难以获取：缺少相关数据；</li>
<li>利用跨语言语料能力较差：网页片段可能存在多种语言，WQA 系统难以利用多种语言的文本数据来回答某一种特定语言的问题；</li>
<li>通用型不足：回答通用领域问题的能力尚有待进一步增强；</li>
<li>处理复杂问题的能力不足：对于定义型、原因型、关系型、比较型、方法型等问题难以给出满意的回答。</li>
</ol>
<h3 id="WQA-的发展趋势"><a href="#WQA-的发展趋势" class="headerlink" title="WQA 的发展趋势"></a>WQA 的发展趋势</h3><ol>
<li>与其他问答系统的融合；</li>
<li>通过答案摘要生成答案；</li>
<li>自动生成高质量问答对数据；</li>
<li>提升 WQA 系统处理复杂问题的能力；</li>
<li>跨语言能力、跨领域能力的进一步增强；</li>
<li>与语音识别、语音生成等工具的进一步结合；</li>
<li>辅助机器人。</li>
</ol>
<h3 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h3><p>[1] 镇丽华, 王小林, 杨思春. 自动问答系统中问句分类研究综述[J]. 安徽工业大学学报(自科版), 2015, 32(1):48-54.</p>
<p>[2] LI X, HU D, LI H, et al. Automatic question answering from Web documents[J]. Wuhan University Journal of Natural Sciences, 2007, 12(5):875 880.</p>
<p>[3] LIU Z J, WANG X L, CHEN Q C, et al. A Chinese question answering system based on Web search [C]. International Conference on Machine Learning and Cybernetics, Lanzhou: IEEE, 2014:816-820.</p>
<p>[4] CHALI Y, HASAN S A, MOJAHID M. A reinforcement learning formulation to the complex question answering problem<br>[J]. Information Processing &amp; Management, 2015, 51(3):252 272.</p>
<p>[5] 余正涛，樊孝忠，郭剑毅，等. 基于潜在语义分析的汉语问答系统答案提取[J]. 计算机学报，2006，29(10):1889—1893.</p>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>问答系统</tag>
        <tag>信息检索</tag>
        <tag>答案抽取</tag>
        <tag>问题分析</tag>
        <tag>综述</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】Deep Learning for Sentiment Analysis：A Survey</title>
    <url>/blog/1801-07883-notes/</url>
    <content><![CDATA[<p>原文链接：<a href="https://arxiv.org/ftp/arxiv/papers/1801/1801.07883.pdf">Deep Learning for Sentiment Analysis: A Survey</a></p>
<p>作者：Lei Zhang, Shuai Wang, Bing Liu</p>
<p>简介：该文首先对深度学习的技术进行了概述，然后对基于深度学习的情感分析研究进行了全面的综述。</p>
<p>选读原因：之前想把手头情感分析的工作再进一步推动一下，因此选择在 arXiv 上找一篇相关综述进行阅读。同样，也是对自然语言处理中的一些概念和技术的了解和复习。这篇综述相对较新，质量很高，而且作者之一刘兵老师是情感分析领域最有影响力的学者之一。当然，综述只是帮助对某一研究领域建立一个初步的印象，要想真正开始深入还是得读海量的 paper + 选择复现。这篇综述中对相关工作建立表格详细介绍，因此原文仍值得一看。</p>
<h2 id="研究概况"><a href="#研究概况" class="headerlink" title="研究概况"></a>研究概况</h2><h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>情感分析（Sentiment analysis）或意见挖掘（Opinion mining）是对人群对于产品、服务、组织、个体、问题、事件、话题等实体的意见、情感、情绪、评价、态度的计算研究。鉴于网络社交媒体的风行，我们拥有了海量的情绪化数据。情感分析已经成为自然语言处理中最有吸引力的研究领域之一，它与管理科学、社会科学领域有交集。</p>
<p>早期的情感分析技术包括监督方法（支持向量机、最大熵、朴素贝叶斯等监督机器学习方法）和无监督方法（包括利用情感词典、语法分析和句法模式的各种方法），而深度学习走红后，其应用到情感分析的出色效果催生大量基于深度学习的情感分析研究。</p>
<span id="more"></span>

<h2 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h2><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><p>这里简单概括一下文中对各种深度学习技术的介绍，同时也是对我知道的点做一个复习。DNN、CNN、RNN、Attention 就不介绍了，如果想了解欢迎看我的<a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/">吴恩达《深度学习》系列课程笔记</a>。</p>
<h4 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h4><p>NLP 中的许多深度学习模型需要词嵌入作为输入特征。词嵌入将词转换为包含实数的向量，并做从高维稀疏向量空间（通常是 One-hot 编码得到的词向量）到低维密集向量空间的处理。嵌入向量的每个维度都代表一个单词的潜在特征，因此这些向量可以编码语言的规律和模式。</p>
<p>Word2Vec 和 Glove 是两种常用于获得词嵌入的方法。前者是一种神经网络预测模型，可以从文本中学习词嵌入；后者是在一个全局单词共现矩阵的非零项上进行训练。</p>
<h4 id="自动编码器"><a href="#自动编码器" class="headerlink" title="自动编码器"></a>自动编码器</h4><p><strong>自动编码器（Autoencoder）</strong>是一种主要用于数据降维或者特征抽取的的<strong>自监督</strong>学习算法。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/Autoencoder.png" alt="Autoencoder"></p>
<p>一个三层的神经网络，其中隐藏层被看作一个编码器和解码器，而输出层的目标值和输入层输入值一致。这样，隐含层是尽量保证输出数据等于输入数据的，使得隐含层能够抓住输入数据的特点，使其特征保持不变。设编码函数为<code>h()</code>、解码函数为<code>g()</code>，则目标是最小化损失函数<code>loss(x, g(h(x)))</code>，而最后获得的隐藏层激活值即是自动编码器捕捉到的训练数据中最显著的特征，权重矩阵<code>W</code>则可作为神经网络训练的初始值。</p>
<p>自动编码器的一种扩展是<strong>去噪自动编码器（Denoising Autoencoder，DAE）</strong>。其目标是最小化<code>loss(x, g(h(~x)))</code>，其中<code>~x</code>是被某种噪声损坏的<code>x</code>，使得隐藏层学习更健壮的特征。</p>
<h4 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h4><p><strong>LSTM（Long Short Term Memory，长短期记忆）</strong>是一种特殊的 RNN，用于缓解 RNN 梯度爆炸和梯度消失的问题。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/LSTM-network.png" alt="LSTM-network"></p>
<p>在 LSTM 的一个可供重复使用的结构中，有四个层相互作用，并有 hidden state 和 cell state 两个 states。</p>
<p>在时间步 $t$，LSTM 首先决定是否将 cell state 中的信息丢弃。这个决定由使用 sigmoid 函数的层 $f_t$（称为“<strong>遗忘门</strong>”）。函数使用 $h_{t-1}$（前一个隐藏层的输出）和 $x_t$（当前输入），输出一个 [0, 1] 的值，1 表示完全保留，0 表示完全丢弃。</p>
<p>$$f_t = \sigma(W^fx_t + U^fh_{t-1})$$</p>
<p>之后，LSTM 决定存储在 cell state 中的新的信息。第一步，使用 sigmoid 函数的“<strong>输入门</strong>” $i_t$ 决定 LSTM 更新的值；第二步，一个使用 tanh 函数的层创建一个候选值向量 $\tilde{C_t}$ 来加到 cell state 上。</p>
<p>$$i_t = \sigma(W^ix_t + U^ih_{t-1})$$</p>
<p>$$\tilde{C_t} = tanh(W^nx_t + U^nh_{t-1})$$</p>
<p>然后用以下公式更新 $C_t$。其中遗忘门 $f_t$ 可以控制经过的梯度，以缓解梯度消失或梯度爆炸的问题。</p>
<p>$$C_t = f_t * C_{t-1} + i_t * \tilde{C_t}$$</p>
<p>最后，LSTM 基于 cell state 决定输出。这里用到一个使用 sigmoid 函数的“<strong>输出门</strong>”。</p>
<p>$$o_t = \sigma(W^o x_t + U^o h_{t-1})$$</p>
<p>$$h_t = o_t * tanh(C_t)$$</p>
<p>LSTM 常用于序列数据，但也可用于树结构数据。<strong>树结构 LSTM（Tree-structured LSTM）</strong>在表示句子含义上比普通的 LSTM 表现更好。[1]</p>
<h4 id="递归神经网络（RecNN）"><a href="#递归神经网络（RecNN）" class="headerlink" title="递归神经网络（RecNN）"></a>递归神经网络（RecNN）</h4><p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/Recursive-NN.png" alt="RecNN"></p>
<p><strong>递归神经网络（RecNN）</strong>通常用于从数据中学习有向无环图结构（例如树结构）。给定句子的结构表示形式（例如解析树），RecNN 以自下而上的方式递归地生成父表示形式（一般为向量），通过组合 tokens 来生成短语表示形式，最终生成整个句子。然后可以使用句子级表示形式对给定的输入句子进行最终分类（例如情感分类）。</p>
<h3 id="情感分析任务"><a href="#情感分析任务" class="headerlink" title="情感分析任务"></a>情感分析任务</h3><p>情感分析可以根据分析对象的粒度分为三个 level：</p>
<ul>
<li><strong>Document level</strong>：对文章做总体的情感分类。</li>
<li><strong>Sentence level</strong>：一般先分类为有情感和无情感的（这个过程被称作 subjectivity classification），然后再对有情感的句子进行分类。</li>
<li><strong>Aspect level</strong>：任务是提取人们对实体和实体的各个方面/特征所表达的意见。因此，它包含了方面抽取、情感抽取和情感分类。</li>
</ul>
<h4 id="Document-level"><a href="#Document-level" class="headerlink" title="Document level"></a>Document level</h4><p>如果是多分类，例如 1-5 星，可以考虑用回归实现。</p>
<p>比较传统的方法是基于词袋模型，对每篇文档定长的数值化特征向量，长度为词典中的词量，值可以是词频或者 TF-IDF。词袋模型的缺点是文本中单词顺序和上下文所蕴含的信息被完全丢弃，n-gram 可以略微减少其影响，但是增加了数据稀疏和高维等问题。另外，词袋模型无法表示语义。</p>
<p>由此引入词嵌入和神经网络。神经网络可能只用于提取文本特征/表示，这些特征用于非神经网络的分类器中，以获得一个结合二者优点的分类器。</p>
<p>鉴于文章常有较长的依赖关系，注意力机制在文章级别的情感分类中也经常使用。</p>
<h4 id="Sentence-level"><a href="#Sentence-level" class="headerlink" title="Sentence level"></a>Sentence level</h4><p>由于句子相较文章来说要短得多，信息量更小，因此一些语义和句法的信息会对 Sentence level 的情感分析有帮助。早期研究中，会用包括解析树、情感词典、词性标注等来提供这些信息。但现在，CNN 和 RNN 使得不再需要用解析树从句子中提取特征，取而代之的是已经将语义、句法信息编码在内的词嵌入作为输入。同时 CNN 和 RNN 也会学习词与词之间的关系信息。</p>
<h4 id="Aspect-level"><a href="#Aspect-level" class="headerlink" title="Aspect level"></a>Aspect level</h4><p>在 Aspect level 的情感分析中，我们不只关注情感本身，还关注它所联系的目标对象（target）。一个对象通常是一个实体或者实体的某一方面，它们有时也被称为 aspect。</p>
<p>例如，在 “the screen is very clear but the battery life is too short.” 这一句话中，如果 target aspect 是 “screen”，那么情感是正面的；但如果 target aspect 是 “battery life”，那么情感是负面的。</p>
<p>Aspect level 的情感分析难度较大，因为需要捕捉目标对象和上下文（context）的语义联系。</p>
<p>三个重要任务：</p>
<ol>
<li>生成目标对象上下文的表示：可以使用之前提到的文本表示方法；</li>
<li>生成目标对象的表示：可以类似词嵌入，学习一个文本嵌入；</li>
<li>识别对于特定目标对象的重要情感上下文：目前常用注意力机制处理，但是还没有统治性的方法出现。</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>还有一些其他的研究内容，包括：</p>
<ul>
<li>Aspect extraction and categorization：实体对象的抽取与分类；</li>
<li>Opinion expression extraction：意见表达词的抽取；</li>
<li>Sentiment composition：直译为情感成分，认为意见表达的情感取向是由其构成成分的意义和语法结构决定的；</li>
<li>Opinion holder extraction：抽取意见的持有者；</li>
<li>Temporal opinion mining：情感或意见是有时效性的，因此预测未来的情感或意见也是一个可研究的问题；</li>
<li>Sarcasm analysis：分析是否为讽刺；</li>
<li>Emotion analysis：我将这里的 Emotion 翻译成情绪，比情感更主观；</li>
<li>Multimodal data for sentiment analysis：多模态数据，例如包含文本、视觉和声学信息的数据，被用来帮助情感分析；</li>
<li>Resource-poor language and multilingual sentiment analysis：资源贫乏语言和多语言的情感分析；</li>
<li>Sentiment intersubjectivity：情感主体间性，研究语言的表层形式与相应的抽象概念之间的差距；</li>
<li>Lexicon Expansion：词汇扩展；</li>
<li>Financial Volatility Prediction：根据情感分析进行金融波动预测；</li>
<li>Opinion Recommendation：意见推荐，将用户写好的关于商品的意见选择推荐给其他用户；</li>
<li>Stance Detection：立场检测，分析例如政治 twitter 等数据隐含的政治立场。</li>
</ul>
<p>由此可见，情感分析仍然是一个值得深挖的研究方向，并且在深度学习的结合下，有更多的研究和应用出现。</p>
<h2 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h2><p>[1] Tai K.S, Socher R, Manning C. D. Improved semantic representations from tree-structured long short-term memory networks. In Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL 2015), 2015.</p>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
   tex2jax: {inlineMath: [ ['$', '$'] ],
         displayMath: [ ['$$', '$$']]}
 });
</script>

<script src="https://cdn.bootcss.com/mathjax/2.7.4/latest.js?config=default"></script>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>自然语言处理</tag>
        <tag>综述</tag>
        <tag>情感分析</tag>
        <tag>意见挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title>论文综述 - 基于设备行为特征的用户身份认证</title>
    <url>/blog/user-authentication-of-behavioral-biometrics-notes/</url>
    <content><![CDATA[<p>这篇论文综述已经成文比较久了，是四月上旬写成的。“基于设备行为特征的用户身份认证”是朱老师给我的一个题目，希望我能在阅读论文后有一些想法，并做实验去实现。</p>
<p>这篇文章算是一个阶段性总结，但是我们并没有一个具体的好的 idea，我这学期时间比较紧张，也不太好漫无目的地写程序做实验找实验者得到数据再以此找 idea，因此暂时搁置去做其他的工作。但是也算是我在实验室的工作之一，锻炼了我读论文的能力。希望大四有机会看能不能进一步做出一些成果。</p>
<p>对了，我知道这不是一篇合格或者说合乎规范的论文综述。</p>
<h2 id="论文总体背景"><a href="#论文总体背景" class="headerlink" title="论文总体背景"></a>论文总体背景</h2><h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>身份认证是指用户声明自己的身份并利用相关特征数据来证实该身份，将该用户的相关特征数据与其声明用户的模板进行比较，是一种一对一的匹配方法。安全的身份认证是保证计算机及网络系统安全的基本前提。现有的身份认证技术主要包括三类，分别利用了不同的信息:</p>
<ol>
<li>记忆信息，如密码、PIN 等；</li>
<li>辅助设备、如 ID 卡、令牌等；</li>
<li>生物特征，如指纹，虹膜等。</li>
</ol>
<p>这些传统的识别技术自身均存有缺陷，如密码难于记忆并容易搞混和泄露，ID 卡需要随身携带且易失窃或失效，生物认证需要额外的硬件设备。鉴于此，研究人员仍然在不断寻找新的身份认证手段和方法。[1]</p>
<p><strong>基于设备行为特征的用户身份认证</strong>是研究通过键盘、鼠标等计算机输入设备以及触摸屏、陀螺仪等移动终端设备的使用行为特征来识别计算机操作者身份的可行性及相关方法。该研究基于所有用户在设备上进行操作的行为特征不尽相同的<strong>假设</strong>。因为其有着不需要额外的设备、在当前大多数计算机系统中可以直接部署、认证和监控期间对用户几乎无干扰等优点，因此逐渐成为身份认证研究中的新热点。除开网络安全、机器学习，该问题也被归于<strong>生物行为统计学（Behavioral Biometrics）</strong>。</p>
<span id="more"></span>

<h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>在该研究中中，对模型或系统性能的评估指标通常与生物统计学中类似问题相同，定义如下：</p>
<ul>
<li>False Acceptance Rate（错误接受率，FAR）：冒名顶替者被系统接受的百分比；</li>
<li>False Rejection Rate（错误拒绝率，FRR）：真实授权用户被系统拒绝的百分比；</li>
<li>Equal Error Rate（等错误率，EER）：错误接受率和错误拒绝率相等时的错误率，即前两者相交的点。[2]</li>
</ul>
<h2 id="具体论文介绍"><a href="#具体论文介绍" class="headerlink" title="具体论文介绍"></a>具体论文介绍</h2><h3 id="基于鼠标行为特征的用户身份认证与监控-1"><a href="#基于鼠标行为特征的用户身份认证与监控-1" class="headerlink" title="基于鼠标行为特征的用户身份认证与监控[1]"></a>基于鼠标行为特征的用户身份认证与监控[1]</h3><p>本文对 20 个用户 2 个月的鼠标行为数据进行比较分析，结合 SVM（支持向量机）建立模型。</p>
<p>本文的亮点是提出了一种基于顺序前进贪婪搜索和支持向量机的特征组合选择算法，以降低鼠标特征空间的维数，显著提高身份认证和监控的准确度。错误接受率为 1.67%，错误拒绝率为 3.68%。</p>
<h3 id="User-Authentication-using-Combination-of-Behavioral-Biometrics-over-the-Touchpad-acting-like-Touch-screen-of-Mobile-Device-2"><a href="#User-Authentication-using-Combination-of-Behavioral-Biometrics-over-the-Touchpad-acting-like-Touch-screen-of-Mobile-Device-2" class="headerlink" title="User Authentication using Combination of Behavioral Biometrics over the Touchpad acting like Touch screen of Mobile Device[2]"></a>User Authentication using Combination of Behavioral Biometrics over the Touchpad acting like Touch screen of Mobile Device[2]</h3><p>本文的研究成果表明，在触摸屏设备上，用 k-NN 分类方法，手指压力比击键力学更能给出判别信息。此外，仅使用手指压力，准确度高达99%。</p>
<p>本文的优点是详细地介绍了生物统计学，以及数据采集使用的设备和方法。</p>
<h3 id="动态实时身份认证的方法研究-3"><a href="#动态实时身份认证的方法研究-3" class="headerlink" title="动态实时身份认证的方法研究[3]"></a>动态实时身份认证的方法研究[3]</h3><p>本文研究的前提是介入式场景的身份认证需要的时间短（几秒内），但是人的短时行为不稳定，影响准确率；而认证时间长，内部攻击可能已经完成。</p>
<p>本文研究重点在于动态场景和固定场景配合的身份认证。动态场景中，系统等待合适的时机注入异常事件，构建包括鼠标光标的跳变、隐藏和呆滞 3 种异常场景，采集用户在异常发生时的鼠标行为；在连续两次动态身份认证异常后，系统引导用户进入固定场景（本文在此设计了一款记忆性的拼图游戏）以长时间采集行为数据，确定是判断为用户正常、更新模版库还是判断为伪造用户并报警。</p>
<p>本文的亮点是提出了一种全场景身份认证系统，动态用场景和固定场景的配合克服固定场景无法实时身份认证的弊端，而且保证了用户体验和资源节省。错误接受率为 1.8%，错误拒绝率为 3.0%，平均认证时间仅需 8.12s。</p>
<h3 id="行为截获技术对鼠标动力学身份认证的影响-4"><a href="#行为截获技术对鼠标动力学身份认证的影响-4" class="headerlink" title="行为截获技术对鼠标动力学身份认证的影响[4]"></a>行为截获技术对鼠标动力学身份认证的影响[4]</h3><p>本文研究了三种截获用户鼠标行为数据的方法：消息钩子、WM_INPUT 消息处理和过滤驱动，在采样时钟分辨率、时间精度、位置信息等方面分析了不同方法所获取的数据之间的区别，并利用神经网络分类器构建了身份认证模型。</p>
<p>本文的结论是三种行为截获技术中，消息钩子方法截获的数据时间准确性高，轨迹位置表示的误差较小，用于身份认证的效果较好。</p>
<p>本文的亮点是研究重点另辟蹊径，放在了行为截获技术这一特征采集的源头。</p>
<h3 id="A-Practical-Real-Time-Authentication-System-with-Identity-Tracking-Based-on-Mouse-Dynamics-5"><a href="#A-Practical-Real-Time-Authentication-System-with-Identity-Tracking-Based-on-Mouse-Dynamics-5" class="headerlink" title="A Practical Real-Time Authentication System with Identity Tracking Based on Mouse Dynamics[5]"></a>A Practical Real-Time Authentication System with Identity Tracking Based on Mouse Dynamics[5]</h3><p>本文提出了一种基于鼠标动态的实时认证方法，称为PAITS（Practical Authentication with Identity Tracking System）。该方法也是通过注入异常事件，与“动态实时身份认证的方法研究”一文相比，优点在于数据集更大：12 个志愿者，1038 个鼠标会话。</p>
<h3 id="Verification-of-Computer-Users-Using-Keystroke-Dynamics-6"><a href="#Verification-of-Computer-Users-Using-Keystroke-Dynamics-6" class="headerlink" title="Verification of Computer Users Using Keystroke Dynamics[6]"></a>Verification of Computer Users Using Keystroke Dynamics[6]</h3><p>本文的特点在于采用了模糊 ARTMAP、径向基函数网络（RBFN）和学习矢量量化（LVQ）神经网络模型等一些较为少见的神经网络模型，声称在特征选用按键持续时间与按键间隔时间相结合时识别准确率最好能够达到 100%。考虑到本文发表的时间（1997年），如今常用的神经网络理应有更好的分类效果，因此怀疑以上表现的原因是数据集较小。</p>
<h3 id="User-Re-Authentication-via-Mouse-Movements-7"><a href="#User-Re-Authentication-via-Mouse-Movements-7" class="headerlink" title="User Re-Authentication via Mouse Movements[7]"></a>User Re-Authentication via Mouse Movements[7]</h3><p>通过突然的警报来构建动态场景，根据鼠标移动行为来进行用户认证。假阳性率为0.43%，假阴性率为1.75%。可能是因为发表时间较早（2004 年），与其余论文比没有感觉有特别突出的亮点。</p>
<h3 id="The-detection-of-faked-identity-using-unexpected-questions-and-mouse-dynamics-8"><a href="#The-detection-of-faked-identity-using-unexpected-questions-and-mouse-dynamics-8" class="headerlink" title="The detection of faked identity using unexpected questions and mouse dynamics[8]"></a>The detection of faked identity using unexpected questions and mouse dynamics[8]</h3><p>本文的研究前提和其他论文不太相似，不需要保存有声明用户的行为特征数据，而基于记忆检测（RT-based memory detection），通过通过鼠标轨迹有效检测伪造身份。</p>
<p>本文的实验场景中，要求被试者采用假身份并通过已知的信息进行排练，以达到伪装的目的。他们需要在现场的监测人员的监督下，在电脑上回答问题。问题分为了可预测问题（准备好答案的身份相关问题，例如出生年月）、不可预测问题（没有做好反应准备的身份相关问题，例如属相）和控制问题（包含个人信息且必须正确回答，因为这些问题的真实答案对于现场的监测人员是透明的，例如肤色）。对于不可预测问题，会在反应时间、错误数量以及鼠标轨迹上反映出来。</p>
<p>本文选取的特征数量较多（13个），在此之上选取了效果最好的 4 个进行训练，并使用了四种分类器：随机森林、Logistic、支持向量机和 Logistic Model Tree，用 10 折交叉验证来表明结果的可靠性。</p>
<p>本文的缺点在于数据集太少（不到 100 个样本）、数据分布缺少泛化性（被试者只有意大利和德国人）、只用了准确率做评估指标（没有使用 FAR、FRR、EER）。</p>
<h3 id="Keystroke-dynamics-as-a-biometric-for-authentication-9"><a href="#Keystroke-dynamics-as-a-biometric-for-authentication-9" class="headerlink" title="Keystroke dynamics as a biometric for authentication[9]"></a>Keystroke dynamics as a biometric for authentication[9]</h3><p>本文的亮点：</p>
<ol>
<li>提出一些基于击键特征的具体应用场景，例如任何访问服务器的用户都会被提示输入一些与他/她的用户名和密码相关联的短语。如果他/她的键入模式匹配在声明的标识的合理阈值内，则授予访问权限；或者通过检测打字节奏来判断困倦、疲劳等用户非正常状态，用于空中交通控制等；</li>
<li>主张使用结构化文本，而非任意文本（或称自由文本）来获得用户击键数据。</li>
</ol>
<h3 id="HMOG-New-Behavioral-Biometric-Features-for-Continuous-Authentication-of-Smartphone-Users-10"><a href="#HMOG-New-Behavioral-Biometric-Features-for-Continuous-Authentication-of-Smartphone-Users-10" class="headerlink" title="HMOG: New Behavioral Biometric Features for Continuous Authentication of Smartphone Users[10]"></a>HMOG: New Behavioral Biometric Features for Continuous Authentication of Smartphone Users[10]</h3><p>本文引入了一套行为特征，称为 HMOG（hand movement, orientation, and grasp，手的移动、定位和抓取），对移动设备上三种特征（HMOG、击键和轻触）单独和结合时分类结果进行了综合评价。</p>
<p>本文的亮点：</p>
<ol>
<li>讨论了在坐着和行走两种情况下收集到的数据的不同。坐着时 EER 为 10.05%，行走时 EER 为 7.16%，行走时数据使用时效果更好的原因是 HMOG 特征能够捕捉到行走所引起的独特的身体动作；</li>
<li>分析了认证过程对移动设备能耗的影响。</li>
</ol>
<h3 id="Silent-User-Identification-Via-Touch-and-Movement-Behavioral-Biometrics-11"><a href="#Silent-User-Identification-Via-Touch-and-Movement-Behavioral-Biometrics-11" class="headerlink" title="Silent User Identification Via Touch and Movement Behavioral Biometrics[11]"></a>Silent User Identification Via Touch and Movement Behavioral Biometrics[11]</h3><p>本文的研究重点在于提出了 SilentSense：一种通过利用用户触摸行为、生物识别技术和利用集成传感器来捕捉用户的屏幕触控动作所造成的微移动框架。</p>
<p>该框架通过集成了一个基于运动的生物识别技术，解决由触摸引起的移动设备的微移动被大规模的用户移动抑制的问题。所用的技术包括：</p>
<ol>
<li>考虑到用户可以用任何姿态握住手机，将手机坐标系中的原始加速度矢量实时转换为地球坐标系；</li>
<li>利用带通滤波器对线性加速度进行滤波；</li>
<li>从处理后的加速度数据中提取行走特征。步行者的垂直位移与他/她的步长和高度直接相关，因此是一个重要的特征。</li>
</ol>
<p>研究的用户行为包括轻触、滚屏、扔甩、多次触碰，选用特征包括垂直位移、步长、水平加速度的均值和标准差。</p>
<p>另外，本文还提出了一种新的在线决策机制，可以控制打开或关闭传感器，以提供了能耗成本、延迟和准确性之间的平衡。该在线决策机制会根用户的习惯，产生适应性的观察频率。</p>
<h3 id="Implicit-Smartphone-User-Authentication-with-Sensors-and-Contextual-Machine-Learning-12"><a href="#Implicit-Smartphone-User-Authentication-with-Sensors-and-Contextual-Machine-Learning-12" class="headerlink" title="Implicit Smartphone User Authentication with Sensors and Contextual Machine Learning[12]"></a>Implicit Smartphone User Authentication with Sensors and Contextual Machine Learning[12]</h3><p>本文系统地展示了如何在传感器和特征选择、机器学习技术、上下文检测和多设备的不同设计方案中实现高认证精度。提出的 SmarterYou 框架认证精确度为 98.1%，系统开销可忽略不计，电池消耗不足 2.4%。</p>
<p>本文的亮点在于：</p>
<ol>
<li>使用了 KRR（kernel ridge regression）算法；</li>
<li>使用 Fisher scores 来选取特征子集。Fisher scores 是广泛使用的监督特征选择方法之一；</li>
<li>较为详细地介绍了上下文检测：在不同环境下，传感器的测量结果可能不同。因此单独训练上下文检测模型来在做用户认证前的上下文检测。在初步实验后，将提出的四种上下文合并为两种，最终实现上下文检测精度超过 99%，时间小于 3 毫秒。数据获取方法是让用户在受控的实验室条件下使用他们的智能手机，使用过程中保持运动或静止；当为用户执行上下文检测时，使用的上下文检测模型是用其他用户的数据进行训练的。</li>
</ol>
<p>另外，本文包含了一个移动设备上相关工作效果比较的表格，可以参考。</p>
<p><img src="https://user-images.githubusercontent.com/18595460/38462995-1b1cdfce-3b22-11e8-8693-cafda9807f44.png" alt="2018-04-08 10 48 58"></p>
<h2 id="可以深入研究的方向"><a href="#可以深入研究的方向" class="headerlink" title="可以深入研究的方向"></a>可以深入研究的方向</h2><ol>
<li>将对上述研究的学习成果从“用户身份认证”迁移到“爬虫识别”。不过，基于行为特征的验证码实际上已经非常成熟了，例如通过拖动条采集响应时间、拖拽速度、位置、轨迹、重试次数等特征进行识别，以及 <a href="https://www.leiphone.com/news/201412/Hnux7n19OcNWwUFt.html">Google 的复选框点击验证码</a>。因此，如果要选择这个方向，需要有更多创新。</li>
<li>将对上述研究的学习成果从“用户身份认证”迁移到“用户体验分析”。根据用户行为特征的异常来判断用户的心情，或者内容对用户的吸引力。</li>
<li>移动设备验证码：现在移动端好像都是短信验证码，或者是最基本的图形验证码。能不能实现在触摸屏上画一个圈就能验证？或者与手机划线解锁相结合？</li>
<li>提出一个具体的应用场景，并调整选取特征、指标、算法等。</li>
</ol>
<h2 id="论文列表"><a href="#论文列表" class="headerlink" title="论文列表"></a>论文列表</h2><p>[1] 沈超, 蔡忠闽, 管晓宏,等. 基于鼠标行为特征的用户身份认证与监控[J]. 通信学报, 2010, 31(7):68-75.</p>
<p>[2] Saevanee, Hataichanok, and P. Bhatarakosol. “User Authentication Using Combination of Behavioral Biometrics over the Touchpad Acting Like Touch Screen of Mobile Device.” International Conference on Computer and Electrical Engineering IEEE Computer Society, 2008:82-86.</p>
<p>[3] 毛传武, 程阳, 余文明. 动态实时身份认证的方法研究[J]. 网络与信息安全学报, 2016, 2(3):76-85.</p>
<p>[4] 王淼, 蔡忠闽, 沈超,等. 行为截获技术对鼠标动力学身份认证的影响[J]. 微电子学与计算机, 2013, 30(4):14-21.</p>
<p>[5] Chen, Xiao Jun, et al. “A practical real-time authentication system with Identity Tracking based on mouse dynamics.” Computer Communications Workshops IEEE, 2014:121-122.</p>
<p>[6] Obaidat, M. S., and B. Sadoun. “Verification of computer users using keystroke dynamics.” IEEE Transactions on Systems Man &amp; Cybernetics Part B Cybernetics A Publication of the IEEE Systems Man &amp; Cybernetics Society 27.2(1997):261-9.</p>
<p>[7] Pusara, Maja, and C. E. Brodley. “User re-authentication via mouse movements.” The Workshop on Visualization &amp; Data Mining for Computer Security ACM, 2004:1-8.</p>
<p>[8] Monaro, M, L. Gamberini, and G. Sartori. “The detection of faked identity using unexpected questions and mouse dynamics.” Plos One 12.5(2017).</p>
<p>[9] Monrose, Fabian, and A. D. Rubin. “Keystroke dynamics as a biometric for authentication.” Future Generation Computer Systems 16.4(2000):351-359.</p>
<p>[10] Sitová, Zdeňka, et al. “HMOG: New Behavioral Biometric Features for Continuous Authentication of Smartphone Users.” IEEE Transactions on Information Forensics &amp; Security 11.5(2016):877-892.</p>
<p>[11] Bo, Cheng, et al. “SilentSense:silent user identification via touch and movement behavioral biometrics.” Computer Science (2013):187-190.</p>
<p>[12] Lee, Wei Han, and R. B. Lee. “Implicit Smartphone User Authentication with Sensors and Contextual Machine Learning.” (2017):297-308.</p>
]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>综述</tag>
        <tag>身份认证</tag>
        <tag>行为特征</tag>
        <tag>生物行为统计学</tag>
      </tags>
  </entry>
  <entry>
    <title>再探前端自动化－持续集成</title>
    <url>/blog/start-CI/</url>
    <content><![CDATA[<p>本篇博文承接前端工程自动化入门系列的第一篇：<a href="http://kyonhuang.top/start-front-end-test/">《初探前端自动化测试–以 Vue 为例》</a>。</p>
<p>传统开发模式中，项目经理等待所有模块都开发完成后再进行集成，出现 bug 则记录并分配责任人进行修改，之后再进行集成，直到通过测试为止持续循环。这个过程可能会出现如下问题：</p>
<ol>
<li>bug 总在最后才被发现（尤其是模块之间的依赖导致的 bug），并且越到项目后期，随着项目规模的膨胀，bug 变得愈发难以修复；</li>
<li>各个环节无效的等待时间较长，加上程序需要经常变更，导致软件交付时机无法保障；</li>
<li>用户无法随时看到项目演示原型，满意度低。</li>
</ol>
<p>为了解决这些问题，<strong>“持续集成”（Continuous Integration）</strong>的概念被提出。</p>
<span id="more"></span>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><strong>持续集成</strong>（CI）是指将所有开发者工作副本频繁地（每天多次）合并到主干，始终保持可发布状态的做法。而<strong>持续集成服务器</strong>就是能够采用自动化的手段，实现项目持续集成的工具。</p>
<p>持续集成的具体工作流程：</p>
<ol>
<li><strong>本地开发（developing）</strong></li>
<li><strong>静态代码检查（linting）</strong></li>
<li><strong>单元测试（testing）</strong>：代码仓库对 commit 操作配置钩子（hook），只要提交代码或者合并进入主干，就会跑自动化测试。这一轮可以先只跑单元测试。</li>
<li><strong>合并进入主干（merging）</strong></li>
<li><strong>自动构建（building）</strong>：将源码经过安装依赖、配置各种资源（CSS、JS、images），转换为可以运行的实际代码。之后会跑全面的测试。</li>
<li><strong>自动发布（publishing）</strong>：将可以直接部署的版本打包，发到生产服务器以启动应用。</li>
</ol>
<p>持续集成之后还有<strong>持续交付</strong>和<strong>持续部署</strong>，分别强调代码在任何时候都是可交付和可部署的。</p>
<h2 id="持续集成的优点"><a href="#持续集成的优点" class="headerlink" title="持续集成的优点"></a>持续集成的优点</h2><ol>
<li>自动化部署工作解放了重复性劳动，并减少手工集成的错误；</li>
<li>防止分支大幅偏离主干，而导致以后的集成难度变大，甚至难以集成；</li>
<li>持续集成缩短了开发、集成、测试、部署等各个环节的时间，从而减少等待时间，同时可以更快地发现、定位、修复问题并交付成果，使得产品可以快速迭代；</li>
<li>集成服务器一般都提供 Code review、代码质量检测等功能，帮助开发人员提高产品质量。</li>
</ol>
<h2 id="持续集成服务平台-Travis"><a href="#持续集成服务平台-Travis" class="headerlink" title="持续集成服务平台 - Travis"></a>持续集成服务平台 - Travis</h2><p>很多 PaaS 平台都提供了持续集成服务。Travis CI 是其中最著名的一个，对于开源项目可以免费使用。</p>
<p>每次跑测试时，Travis 提供的都是一个空白的环境。这个环境只有  Linux 基本的<code>build-essential </code>和<code>wget</code>、<code>git</code>那些依赖。连 Node.js 的运行时都是现跑现安装的。因为 Travis 默认带有的依赖都是每个用户的机器上都会有的，所以一旦应用能在 Travis 上跑通，别的用户就都能安装上。</p>
<p>Travis 的使用方法如下：</p>
<p>首先，在官网 <a href="https://travis-ci.org/">https://travis-ci.org/</a> 注册后选择需要开启集成测试的仓库。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-046bd7b6765f890e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="travis.png"></p>
<p>然后，需要在项目的根目录放一份配置文件<code>.travis.yml</code>来告诉 Travis 需要用什么版本的 Node 跑，以及跑测试的命令等信息。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">一份简单的</span> <span class="string">.travis.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&#x27;4.2.5&#x27;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&#x27;7.5.0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>

<p>如果有用到数据库，则<code>.travis.yml</code>还需要添加一些内容。详细内容参考 <a href="https://docs.travis-ci.com/user/database-setup/">Setting up Databases - Travis CI</a>。</p>
<p>之后将这份配置文件 push 上 github，Travis 就会被自动触发。下图是正在进行集成测试的 <a href="https://github.com/bighuang624/resume">我的简历项目</a>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-b96ac611cef2c347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CItesting.png"></p>
<p>P.S. e2e 测试需要装 chrome 浏览器这个坑又出现了…简直阴魂不散。是不是要用 PhantomJS 才行啊…</p>
<p>我们先只跑单元测试好了。把<code>.travis.yml</code>更改一下：<code>script: npm run unit</code>，再 push 到 github 上。过一会就看到测试通过了。可以把 BlingBling 的 build 徽章加进项目的 README.md 中，来显示项目的构建状态了（徽章添加方案可见参考资料）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-c8621de29eb8b3c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="badage-sample.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么？ - 阮一峰的网络日志</a></li>
<li><a href="https://juejin.im/post/599a3366518825241e221138">为什么我们迫切需要持续集成？</a></li>
<li><a href="https://github.com/alsotang/node-lessons/tree/master/lesson13">《持续集成平台：travis》</a></li>
</ul>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://efe.baidu.com/blog/front-end-continuous-integration-tools/">前端开源项目持续集成三剑客 | EFE Tech</a>：添加徽章步骤，可以说是非常具体了</p>
]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>前端工程</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title>初探前端自动化测试--以 Vue 为例</title>
    <url>/blog/start-front-end-test/</url>
    <content><![CDATA[<p>随着前端项目规模日益膨胀，自动化测试显得越来越重要。在开发过程中就进行测试，可以保障代码质量和功能实现完整度，提升后期开发效率，也便于项目维护。当然，对于需求变更频繁、复用度低的内容，维护测试用例的成本就显得过高；但对于稳定、多次复用以及需要长期维护的项目，自动化测试就尤为重要。</p>
<p>现在优秀的开源项目大多都经过了各种测试。最近我也想码一个规范性要求严格的小项目，于是兵马未动粮草先行，先对前端自动化测试进行学习，总结记录一下学习成果，以在之后项目上进行实践。</p>
<p>前端的测试类型分为<strong>单元测试（unit testing）</strong>、<strong>集成测试（integration testing）</strong>和<strong>端到端测试（e2e testing）</strong>。</p>
<ul>
<li><strong>单元测试</strong>将应用拆分为细小的组件（JS 中的一个函数/对象/模块等）方法，然后针对这些方法进行单独的测试工作；</li>
<li><strong>集成测试</strong>是针对产品的某个功能的测试，又称功能测试；</li>
<li><strong>e2e 测试</strong>则是从用户界面直达数据库的全链路测试，模拟用户进行页面操作，通过判断页面状态的变化来检查功能是否运行正常，需要用到浏览器环境。</li>
</ul>
<span id="more"></span>

<h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>先绕点路，了解一下 TDD、BDD等<strong>以测试为导向的开发模式</strong>，有助于我们更深入地理解自动化测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>TDD（Test Driven Development），即<strong>测试驱动开发</strong>。其先针对每个功能点抽象出接口代码，然后编写单元测试用例代码。之后实现接口，运行单元测试代码进行测试，循环往复直至所有单元测试通过。</p>
<p>TDD 要求测试先于编写功能代码。测试用例不仅是对于代码的验证，更成为对代码的规范与约束，确保在开发以及未来进行修改时能够极大程度地保证该模块行为仍然是正确的。</p>
<h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>BDD（Behavior Driven Development），即<strong>行为驱动开发</strong>。BDD 和 TDD 一样，都要求先写测试，再写代码。可以认为 BDD 是 TDD 的一个子集或分支，是测试驱动开发的扩展。</p>
<p>TDD 基于开发者角度，重点测试函数的输入输出；而 BDD 更侧重于使用者角度，重点测试对用户行为的反应。</p>
<p>BDD 测试中，客户与开发者共同考虑系统该如何运行，然后用通用的语言抽象描述系统的行为，使得双方从技术层面和业务需求都能理解，避免沟通障碍。</p>
<h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="测试管理工具"><a href="#测试管理工具" class="headerlink" title="测试管理工具"></a>测试管理工具</h3><p>用来组织和运行整个测试的工具，它能够将测试框架、断言库、测试浏览器、测试代码和被测试代码组织起来，并运行被测试代码进行测试。</p>
<p>可选择的有 Karma、Selenium、Mocha（Mocha既是测试工具，也是测试框架）。</p>
<h3 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h3><p>测试框架是单元测试的核心，提供了单元测试所需的各种API，并对测试用例分组。测试框架会抓取到代码抛出的 AssertionError 并提供附加信息。</p>
<p>选择较多，有名的有 Mocha、Jasmine等。不过 Mocha 既支持 TDD 也支持 BDD 的测试语法，Jasmine 只支持 BDD。</p>
<h3 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h3><p>断言库提供了很多语义化的方法来对值做各种判断。当然也可以不用断言库，Node.js 中也可以直接使用原生 assert 库。</p>
<p>可供选择的断言库也很多，包括 should.js、expect.js、chai.js等。</p>
<h3 id="测试浏览器"><a href="#测试浏览器" class="headerlink" title="测试浏览器"></a>测试浏览器</h3><p>前端代码是运行在浏览器中的，要对其进行单元测试，只能将其运行在浏览器上。目前大部分测试工具都支持调用和运行本地浏览器来进行测试，但如果测试仅仅是针对函数和模块的单元测试，则完全可以使用一款无界面的 webkit 内核浏览器：PhantomJS。</p>
<h3 id="测试覆盖率统计工具"><a href="#测试覆盖率统计工具" class="headerlink" title="测试覆盖率统计工具"></a>测试覆盖率统计工具</h3><p>测试覆盖率工具为代码在语法级分支上打点，之后运行代码，并在运行结束后根据收集到的信息统计出当前测试用例对源码的覆盖情况。</p>
<p>一般情况下你的测试管理工具会提供相关的覆盖率统计工具，但是有些情况下它们提供的工具未必是你想要的。比如当被测试的代码是经过了某些打包工具打包完了且被压缩和混淆了，同时打包工具还混入了很多自己的代码，这时覆盖率的统计就容易不准确。所以为了避免这种情况，测试覆盖率统计工具需要谨慎选择，至少你得确认它支持你的打包工具已经打包好的代码。</p>
<h2 id="vue-cli-的配置"><a href="#vue-cli-的配置" class="headerlink" title="vue-cli 的配置"></a>vue-cli 的配置</h2><p>vue-cli 的 webpack 模版内置了开箱即用的 Karma + Jasmine 单元测试配置，以及 Nightwatch + Selenium E2E 测试配置，<code>npm run test</code>即可测试自带的一个初始测试用例。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-50166ab65032fdd5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-unit-test.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-298692df753ab061.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuecli-e2e-test.jpg"></p>
<p>有坑请注意：</p>
<ol>
<li>建议使用 cnpm 对 vue-cli 项目进行依赖安装，否则可能有些东西装不上。</li>
<li>自带的 e2e 测试要求装有 chrome 浏览器，否则报错<code>Error retrieving a new session from the selenium server</code>。我被这个坑折腾了半天…</li>
</ol>
<h2 id="开始编写测试代码"><a href="#开始编写测试代码" class="headerlink" title="开始编写测试代码"></a>开始编写测试代码</h2><p><a href="https://github.com/bighuang624/resume">我的简历项目</a> 是我花了一天时间写的一个 vue-cli 初始化、只用了 Vue 的一个小项目，我们拿这个简单的小项目来入门测试代码的编写。我们直接利用 vue-cli 的初始配置，即用 Karma + Jasmine 进行单元测试，Nightwatch + Selenium 进行 E2E 测试。</p>
<p>你可以将我的项目 clone 下来进行测试代码的编写练习，不过项目里的测试代码可能已经因为更新而何下面的示例不一样了。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><code>/test/unit/index.js</code>中可以看到，单元测试的测试代码是<code>/specs</code>文件夹下以<code>.spec.js</code>结尾的文件。将自带的<code>Hello.spec.js</code>改写为<code>LeftNav.spec.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> LeftNav <span class="keyword">from</span> <span class="string">&#x27;@/components/LeftNav&#x27;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;LeftNav.vue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Constructor = Vue.extend(LeftNav);</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Constructor().$mount();</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should render correct name&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(vm.$el.querySelector(<span class="string">&#x27;.leftNav h1&#x27;</span>).textContent)</span><br><span class="line">      .to.equal(<span class="string">&#x27;Kyon Huang&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should render correct title&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(vm.$el.querySelector(<span class="string">&#x27;.leftNav h3&#x27;</span>).textContent)</span><br><span class="line">      .to.equal(<span class="string">&#x27;Web 开发工程师&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h3><p>同理，将<code>/test/e2e/specs/test.js</code>改写为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For authoring Nightwatch tests, see</span></span><br><span class="line"><span class="comment">// http://nightwatchjs.org/guide#usage</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">&#x27;default e2e tests&#x27;</span>: <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">browser</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// automatically uses dev Server port from /config.index.js</span></span><br><span class="line">    <span class="comment">// default: http://localhost:8080</span></span><br><span class="line">    <span class="comment">// see nightwatch.conf.js</span></span><br><span class="line">    <span class="keyword">const</span> devServer = browser.globals.devServerURL;</span><br><span class="line"></span><br><span class="line">    browser</span><br><span class="line">      .url(devServer)</span><br><span class="line">      .waitForElementVisible(<span class="string">&#x27;#app&#x27;</span>, <span class="number">5000</span>)</span><br><span class="line">      .assert.elementPresent(<span class="string">&#x27;.leftNav&#x27;</span>)</span><br><span class="line">      .assert.containsText(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;Kyon Huang&#x27;</span>)</span><br><span class="line">      .assert.elementCount(<span class="string">&#x27;img&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">      .end();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bd0c6382e613c281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unit-test-result.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-dbd1bfcc046e28fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e2e-test-result.png"></p>
<p>可以看到，我们的单元测试和 e2e 测试都通过了。不过单元测试的覆盖率有点低，只有 25%。如何写好测试代码，需要进一步的学习。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>前端工程自动化入门系列下一篇：<a href="http://kyonhuang.top/start-CI/">《再探前端自动化－持续集成》</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作资料"><a href="#写作资料" class="headerlink" title="写作资料"></a>写作资料</h3><p><a href="http://www.cnblogs.com/bigdataZJ/p/AutoTesting1.html">开发人员看测试之TDD和BDD - JackieZheng - 博客园</a></p>
<p><a href="http://www.jianshu.com/p/6726c0410650">前端自动化单元测试初探 - 简书</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p><a href="http://www.infoq.com/cn/articles/virtual-panel-tdd-bdd#">虚拟座谈会：代码测试比率、测试驱动开发及行为驱动开发</a></p>
<p><a href="https://www.qcloud.com/community/article/743451001489391682">PhantomJS 基础及示例 - 腾云阁 - 腾讯云</a></p>
]]></content>
      <categories>
        <category>前端工程</category>
      </categories>
      <tags>
        <tag>JavaScipt</tag>
        <tag>前端</tag>
        <tag>前端工程</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>单页面程序及组件化相关笔记</title>
    <url>/blog/SPA-learning-notes/</url>
    <content><![CDATA[<p>随着 Vue 文档的阅读，单页面程序、组件等概念出现地越来越频繁。但我始终感觉对这几个词缺少一种逻辑联系上的认知。直到看到 <a href="https://github.com/xufei/blog">xufei</a> 在 github 上的关于这个主题的一系列博文，始有醍醐灌顶之感。综合各方面资料，自己进行一个整理，帮助自己深入理解。</p>
<span id="more"></span>

<p>提高开发效率的两个主要途径：</p>
<ul>
<li>加快开发速度：少造轮子。</li>
<li>减少变更代价：清理模块之间的关系，合理分层。</li>
</ul>
<h2 id="单页面程序"><a href="#单页面程序" class="headerlink" title="单页面程序"></a>单页面程序</h2><p>SPA（单页面程序，Single Page Application）：在一个页面上集成多种功能，甚至整个系统就只有一个页面，所有的业务功能都是它的子模块，通过特定方式挂接到主页面上。</p>
<h3 id="优越性"><a href="#优越性" class="headerlink" title="优越性"></a>优越性</h3><p>高效，体现在用户体验和运行效率上。把 AJAX 的无刷新机制发挥到极致。</p>
<p>实现前后端的天然分离。后端不再承担模板渲染、输出页面等工作，专注于提供 API，同时不必再针对每个端作差异化设计。</p>
<h3 id="代码合并与加载策略"><a href="#代码合并与加载策略" class="headerlink" title="代码合并与加载策略"></a>代码合并与加载策略</h3><p>典型特征：部分加载。</p>
<p>一块界面可以是一个 HTML 片段，像请求数据一样用 AJAX 获取。如果有逻辑的 JavaScript 代码，也可以用 require 之类的<strong>异步加载机制</strong>去运行时加载。</p>
<p>因此，如果在页面间存在可复用的代码，一般提取成单独的文件，并按照每个页面的需求去进行合并。</p>
<h3 id="需要考虑的点"><a href="#需要考虑的点" class="headerlink" title="需要考虑的点"></a>需要考虑的点</h3><h4 id="路由与状态的管理"><a href="#路由与状态的管理" class="headerlink" title="路由与状态的管理"></a>路由与状态的管理</h4><p>界面上的各种功能区块是动态生成的，需要对路由进行管理以减少用户的导航成本。具体做法就是把产品功能分为若干状态，每个状态映射到相应的路由，然后通过 pushState 这样的机制，动态解析路由，使之与功能界面匹配。</p>
<h4 id="缓存与本地存储"><a href="#缓存与本地存储" class="headerlink" title="缓存与本地存储"></a>缓存与本地存储</h4><p>动态加载的界面模板或 JavaScript 代码可以做一些自定义的缓存机制，在非首次的请求中直接取缓存版本，以加快加载速度。</p>
<p>在本地存储一些临时数据可以用 localStorage。</p>
<h4 id="服务器通信"><a href="#服务器通信" class="headerlink" title="服务器通信"></a>服务器通信</h4><p>WebSocket 可以让服务端便利地使用反向推送，前端只响应确实产生业务数据的事件，减少无意义的 AJAX 轮询。</p>
<p>例如 socket.io 之类的库提供了在不同浏览器中的兼容方案，在不支持 WebSocket 的浏览器上会降级成使用 AJAX 或 JSONP 等方式，对业务代码完全透明、兼容。</p>
<h3 id="困难与缺陷"><a href="#困难与缺陷" class="headerlink" title="困难与缺陷"></a>困难与缺陷</h3><p>SPA 遇到的困难：代码组织的复杂度大为提高，难以保证对一个数据的更新能够实时反馈到所有使用它的地方。</p>
<p>缺陷：不利于 SEO；要注意内存管理。</p>
<h2 id="样式规划"><a href="#样式规划" class="headerlink" title="样式规划"></a>样式规划</h2><h3 id="基准样式的分离"><a href="#基准样式的分离" class="headerlink" title="基准样式的分离"></a>基准样式的分离</h3><p>包括浏览器样式的重设、全局字体的设置、布局的基本约定和响应式设计。</p>
<h3 id="组件样式的划分"><a href="#组件样式的划分" class="headerlink" title="组件样式的划分"></a>组件样式的划分</h3><p>组件样式应当尽量减少相互依赖，各组件的样式允许冗余。</p>
<h3 id="堆叠次序的管理"><a href="#堆叠次序的管理" class="headerlink" title="堆叠次序的管理"></a>堆叠次序的管理</h3><p>在单页应用中，需要提前为各种 UI 组件规划堆叠次序（z-index）。应预先分段，不同类型的组的 z-index 落到各自的区间，以避免相互冲突。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>整个应用形成倒置的组件树，每个组件提供对外接口，然后内部只关注自己的实现。</p>
<p>职责更专一。可以做单元测试的覆盖以保证质量，再通过场景测试来保证整体流程。</p>
<ul>
<li>HTML 的组件化：界面的片段化和模版化。界面片段在动态请求得到之后，借助模版引擎之类的技术，通过某种转换，放置到主界面相应的地方。</li>
<li>JavaScript 的组件化：目标是清晰的职责，松耦合，便于单元测试和重复利用。总的原则是先分层次，层内再作切分。</li>
<li>CSS 的组件化：传统 CSS 为扁平的文本结构，变更成本高。把实际使用的 CSS 当作输出结果，而另有一种适合变更的方式当作中间过程。探索结果包括预处理器、后处理器。</li>
</ul>
<h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>jQuery 轻量、灵活，但对代码缺乏约束。</p>
<p>需要在代码极具膨胀的情况下控制每个模块的内聚性，并适当在模块间产生数据传递与共享。</p>
<p>因此需要做一些架构方面的提升 =&gt; 设计模式 =&gt; MVC | MVP | MVVM 框架，基本思路都是在 JS 层创建模块分层和通信机制。</p>
<p>AngularJS, Vue：MVVM。通过类似模板的语法，描述界面状态与数据的绑定关系，然后通过内部转换，把这个结构建立起来，当界面发生变化的时候，按照配置规则去更新相应的数据，然后再根据配置好的规则，从数据更新界面状态。</p>
<p>React：函数式。推崇单项数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或数据的更新）。</p>
<p>依赖注入： </p>
<ul>
<li>核心理念：通过配置来实例化所依赖的组件。</li>
<li>缺点：性能以及跟踪调试的便利性上的损失。</li>
<li>优点：松耦合，可替代性 =&gt; 可单独测试，随手引入。</li>
<li>应用：对从事某一领域的企业，可将所有不常变动领域模型的业务代码都用此类办法维护。</li>
</ul>
<h3 id="MV-框架的基本原理"><a href="#MV-框架的基本原理" class="headerlink" title="MV*框架的基本原理"></a>MV*框架的基本原理</h3><p>充当前端逻辑工具的 JavaScript 不能做入口，因此逻辑要先挂在<strong>配置文件</strong>（HTML）上，先由另外的容器（浏览器或者 Hybird 的壳）把配置文件加载起来，然后才能从某个入口开始执行逻辑。从这时起，框架启动：</p>
<ul>
<li>初始化自身（bootstrap）</li>
<li>异步加载可能尚未引入的 JavaScript 代码（require）</li>
<li>解析定义在 HTML 上的规则（template parser）</li>
<li>实例化模型（scopr）</li>
<li>创建模型和 DOM 的关联关系（binding, injection）</li>
</ul>
<p>这些是主线流程，还有一些支线，比如：</p>
<ul>
<li>解析 url 的 search 字符串，恢复状态（route）</li>
<li>加载 HTML 部件模板（template url）</li>
<li>部件模板和模型的关联（binding）</li>
</ul>
<h2 id="业务模型"><a href="#业务模型" class="headerlink" title="业务模型"></a>业务模型</h2><p>指所处领域中的业务数据、规则、流程的集合。即使抛开所有展示层，这一层也应当能够运作。</p>
<p>Redux、Vuex 之类的辅助方案帮助将业务模型的每一个扰动都收敛到确切的状态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="博文参考资料"><a href="#博文参考资料" class="headerlink" title="博文参考资料"></a>博文参考资料</h3><ul>
<li><a href="https://github.com/xufei/blog/issues/6">Web应用的组件化（一）——基本思路</a></li>
<li><a href="https://github.com/xufei/blog/issues/5">构建单页Web应用</a></li>
<li><a href="https://github.com/xufei/blog/issues/33">关于新框架的学习</a></li>
</ul>
<h3 id="延伸阅读资料"><a href="#延伸阅读资料" class="headerlink" title="延伸阅读资料"></a>延伸阅读资料</h3><ul>
<li><a href="https://github.com/xufei/blog/issues/7">Web应用的组件化（二）——管控平台</a></li>
</ul>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>SPA</tag>
        <tag>单页面程序</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>对几个前端相关概念的理解——OO CSS、语义化、CSS hack</title>
    <url>/blog/some-FE-concepts/</url>
    <content><![CDATA[<p>极客学院的视频《CSS 在工程中改变》中讲到了OO CSS这个概念，而在知乎上看到别人的回答中提到了语义化和CSS hack这两个概念。在查找了相关资料后，我对这几个概念有了一些自己的理解。</p>
  <span id="more"></span>

<h2 id="OO-CSS"><a href="#OO-CSS" class="headerlink" title="OO CSS"></a>OO CSS</h2><p>OO CSS，全称为Object Oriented CSS，意为“面向对象的CSS”。</p>
<p>OO CSS是一种书写规则，看重代码的重用性、可维护性和可扩展性。OO CSS将页面可重用元素抽象成一个类，用Class加以描述，而与其对应的HTML即可看成是此类的一个实例。</p>
<p>OO CSS更加适合大型网站的开发，因为大型网站用到更多的可重用组件。为了更好地维护，最好给每个组件写一份说明文档。</p>
<p>作用：</p>
<ol>
<li>加强代码复用以便方便维护。</li>
<li>减小CSS体积。</li>
<li>提升渲染效率。</li>
<li>组件库思想、栅格布局可共用、减少选择器、方便扩展。</li>
</ol>
<p>注意事项：</p>
<ol>
<li><strong>不要直接定义子节点，应把共性声明放在父类。</strong></li>
<li><strong>结构与样式相互独立。</strong></li>
<li><strong>容器和内容相互独立。</strong></li>
<li>抽象出可重用的元素，建好组件库，在组件库内寻找可用的元素组装页面。</li>
<li>往你想要扩展的对象本身增加class而不是他的父节点。</li>
<li><strong>对象应保持独立性。</strong></li>
<li>避免使用ID选择器，权重太高，无法重用。（ID选择器大多数为JS服务）</li>
<li><strong>避免位置相关的样式。</strong></li>
<li>保证选择器相同的权重。</li>
<li>类名应简短、清晰并保有语义。OOCSS的名字并不影响HTML语义化。</li>
</ol>
<p>参考资料：</p>
<p><a href="http://www.w3cplus.com/css/oocss-concept">OOCSS——概念篇</a></p>
<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p><strong>语义化</strong>就是对数据和信息进行处理，使得机器可以理解。</p>
<p>如何在开放的网络、庞大的信息资源中找到需要的信息？我们当然需要借助包括搜索引擎、爬虫在内的智能程序的力量。而为了让这些程序能够理解内容、推演逻辑、建立索引并给予较高的权值，语义化变得越来越重要。SEO最有效的一种方法就是对网页的HTML结构进行重构，实质上就是语义化。</p>
<p>为了使机器能够尽可能理解内容，规范是必须的。程序肯定只会关注那些约定俗成的东西。某种规范被认可的程度越高，就越会成为机器算法的目标，人们就越可以根据它来实现各种功能。</p>
<p>HTML本身也是机器可读的语义信息，但由于HTML被设计的目的并不是为了机器可读，所以不尽完美。也因此，HTML规范一直在往语义化的方向上发展。HTML5更是在之前规范的基础上，将所有表现层的语义描述都进行了修改或者删除，增加了不少可以表达更丰富语义的元素。</p>
<p>当然，HTML5并非Web语义化唯一的规范。有很多组织都提出了有浏览器和搜索引擎支持的规范，为扩展、标准化Web语义做着自己的贡献。关于HTML5各个元素语义的描述，可参考 <a href="http://justineo.github.io/slideshows/semantic-html/#/">Semantic HTML</a>。</p>
<p>参考资料：</p>
<p><a href="https://www.zhihu.com/question/20455165">如何理解 Web 语义化？- 知乎</a></p>
<h2 id="CSS-hack"><a href="#CSS-hack" class="headerlink" title="CSS hack"></a>CSS hack</h2><p>由于不同厂商的浏览器和浏览器的不同版本对CSS有不一样的支持和解析结果，导致我们需要针对不同的浏览器及同一浏览器的不同版本写特定的样式，以获得统一的页面效果。这个过程叫做<strong>CSS hack</strong>。</p>
<p>使用CSS hack虽然有助于实现页面表现的一致性，但滥用会造成编码过于复杂、文档混乱不堪，增加管理和维护的负担。因此，hack要少用、慎用。等到未来浏览器厂商的标准能够完全统一时，就是hack退出历史舞台的时候了。</p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/freshlover/article/details/12132801">史上最全的CSS hack方式一览</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>概念理解</tag>
        <tag>OO CSS</tag>
        <tag>语义化</tag>
        <tag>CSS hack</tag>
      </tags>
  </entry>
  <entry>
    <title>神奇的CSS动画</title>
    <url>/blog/css-animation/</url>
    <content><![CDATA[<p>按照传统的方式，在页面上实现动画的方式有多种，包括使用 GIF 图片、使用 JavaScript 来动态修改 DOM 的位置并加上一个定时器、使用 Flash 等。但这些方法都存在自己的问题，比如引入额外的文件会导致页面尺寸变大，这样会导致页面加载变慢，从而影响用户体验。</p>
<p>通过浏览器对 CSS3 标准的支持，我们不必再依赖于大尺寸的外部文件，仅凭 CSS 就可以实现动画。我以前没有机会使用，所以基本没有接触功能强大的 CSS 动画。在这篇博文中系统地总结一下，后续补充几个使用示例进一步巩固。</p>
<p>17.04.03 更新：补充打字机动效示例。</p>
<img src="../images/type-writer.gif" />

<span id="more"></span>

<h2 id="transition-属性"><a href="#transition-属性" class="headerlink" title="transition 属性"></a>transition 属性</h2><p>transition 是一个速记属性，有以下四个属性：</p>
<ol>
<li>transition-property：指定 CSS 属性的 name, transition 效果；</li>
<li>transition-duration：transition 效果需要指定多少秒（或毫秒）才能完成；</li>
<li>transition-timing-function：指定 transition 效果的转速曲线，包括五个模式：ease（渐慢，默认）、linear（匀速）、ease-in（加速）、ease-out（减速）、cubic-bezier 函数（自定义速度模式，可使用<a href="http://cubic-bezier.com/">工具网站</a>定制）；</li>
<li>transition-delay：定义 transition 效果开始的时候。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 简写</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> <span class="number">1s</span> height ease;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单独定义</span><br><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition-property</span>: height;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中必须指定 transition-duration 属性，否则持续时间默认为 0 ，没有任何效果。</p>
<p>transition 的局限：</p>
<ul>
<li>需要事件触发，没法在网页加载时自动发生；</li>
<li>一次性，除非一再触发，否则不能重复发生；</li>
<li>只能定义开始状态和结束状态（即只有两个状态），不能定义中间状态；</li>
<li>需要明确知道开始状态和结束状态的具体<strong>数值</strong>，才能计算中间状态；</li>
<li>一条 transition 规则，只能定义一个属性的变化，不能涉及多个属性。</li>
</ul>
<h2 id="keyframes（关键帧）"><a href="#keyframes（关键帧）" class="headerlink" title="keyframes（关键帧）"></a>keyframes（关键帧）</h2><p>animation 属性可以利用 keyframes 关键字定义动画的各个状态，将指定时间段内的动画划分的更为精细。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="number">0%</span> &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  <span class="number">50%</span> &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  <span class="number">100%</span> &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0% 可以用 from 表示，100% 可以用 to 表示：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  <span class="number">50%</span> &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果省略某个状态，浏览器会自动推算中间状态。也可将多个状态写在一行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 以下都为合法的写法</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="number">50%</span> &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> pound &#123;</span><br><span class="line">  <span class="selector-tag">from</span>，<span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: none; &#125;</span><br><span class="line">  <span class="number">50%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从一个状态向另一个状态过渡，浏览器默认为平滑过渡。steps 函数可以实现分布过渡。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite <span class="built_in">steps</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="animation-常用属性"><a href="#animation-常用属性" class="headerlink" title="animation 常用属性"></a>animation 常用属性</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 简写</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: <span class="number">1s</span> <span class="number">1s</span> rainbow linear <span class="number">3</span> forwards normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单独定义</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">animation-name</span>: rainbow;</span><br><span class="line">    <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    ainmation-timing-function: linear;</span><br><span class="line">    <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">animation-fill-mode</span>: forwards;</span><br><span class="line">    <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">    <span class="attribute">animation-iteration-count</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>animation 有以下常用属性（其余和 transition 大致相似）：</p>
<p><strong>animation-iteration-count</strong>：指定动画播放次数，可指定为数值或 infinite（无限次）。</p>
<p><strong>animation-direction</strong>：指定动画播放方向，默认为 normal。其他可选值有 reverse，alternate 和 alternate-reverse（后两种浏览器支持情况不佳）。</p>
<p><strong>animation-fill-mode</strong>：规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。有四个可选值：</p>
<ol>
<li>forwards：让动画停留在结束状态；</li>
<li>none：回到动画没开始的状态；</li>
<li>backwards：让动画回到第一帧的状态；</li>
<li>both：根据 animation-direction 轮流应用 forwards 和 backwards 规则。</li>
</ol>
<p><strong>animation-play-state</strong>：指定动画播放突然终止时的状态，默认行为是跳回动画的开始状态。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 让动画保持突然终止时的状态</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">1s</span> linear infinite;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>IE 10、Firefox 16.0、Chrome 43.0、Safari 9.0、Opera 30.0 以上支持没有前缀的 animation。详见 <a href="http://www.runoob.com/cssref/css3-pr-animation.html">CSS3 animation（动画） 属性
</a> “浏览器支持”部分。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="打字机动效"><a href="#打字机动效" class="headerlink" title="打字机动效"></a>打字机动效</h3><p>依照 <a href="https://juntao.gitbooks.io/3-web-designs-in-3-weeks/content/animate_your_page/index.html">让页面动起来</a> 实现的打字机动效。图片素材为自制，因此部分数据与参照有出入。素材及代码见 <a href="https://github.com/bighuang624/Front-end_Learning/tree/master/%E6%89%93%E5%AD%97%E6%9C%BA%E5%8A%A8%E6%95%88">bighuang624/Front-end_Learning/打字机动效</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">CSS动画简介 - 阮一峰的网络日志</a></p>
<p><a href="http://www.runoob.com/cssref/css3-pr-animation.html">CSS3 animation（动画） 属性
</a></p>
<p><a href="https://github.com/junruchen/junruchen.github.io/wiki/CSS-%E5%8F%98%E6%8D%A2-%E8%BF%87%E6%B8%A1-%E5%8A%A8%E7%94%BB%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">CSS 变换 过渡 动画使用案例</a></p>
<p>补充：</p>
<p><a href="https://aotu.io/notes/2016/11/28/css3-animation-properties/">css3 animation 属性众妙</a></p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS动画</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统复习笔记</title>
    <url>/blog/database-systems-notes/</url>
    <content><![CDATA[<p>简单地复习一下数据库系统。重在思想，基本不会涉及到 SQL 语句，有需要可以在文末的参考资料中找到相应资料。</p>
<h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><h3 id="基于文件系统的局限根源"><a href="#基于文件系统的局限根源" class="headerlink" title="基于文件系统的局限根源"></a>基于文件系统的局限根源</h3><p><strong>基于文件的系统</strong>存在的局限性（分离孤立、冗余、依赖性、文件格式不相容）可以归结为两个原因：</p>
<ul>
<li>数据的定义被嵌入到应用程序中，而不是分开和独立地存储；</li>
<li>除了应用程序规定之外的那些数据访问和操作无法得到控制。</li>
</ul>
<p>因此，引入数据库和数据库管理系统。</p>
<h3 id="数据库与数据库管理系统"><a href="#数据库与数据库管理系统" class="headerlink" title="数据库与数据库管理系统"></a>数据库与数据库管理系统</h3><ul>
<li><strong>数据库</strong>：为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集。<ul>
<li>数据库是“逻辑相关的”，当分析一个组织需要的信息时，总是试图找出实体、属性和联系；</li>
<li><strong>实体</strong>是组织中一个独立的、将要在数据库中体现出来的对象（人、地点、东西、概念、事件）；</li>
<li><strong>属性</strong>描述我们想要记录的对象的某一方面的特性；</li>
<li><strong>联系</strong>描述实体之间的关联。</li>
</ul>
</li>
<li><strong>数据库管理系统（DBMS）</strong>：一个支持用户对数据库进行定义、创建、维护及控制访问的软件系统。<ul>
<li>允许用户定义数据库，通常是通过<strong>数据定义语言（DDL）</strong>；</li>
<li>允许用户在数据库中对数据进行增删改查，通常通过<strong>数据操作语言（DML）</strong>，最常见的查询语言是<strong>结构化查询语言（SQL）</strong>。</li>
<li>提供数据库的受控访问。</li>
</ul>
</li>
</ul>
<p>DBMS 的功能：</p>
<ul>
<li>数据存储、检索和更新；</li>
<li>提供用户可访问的目录；</li>
<li>提供事务支持；</li>
<li>并发控制的服务；</li>
<li>恢复服务、授权服务、完整性服务；</li>
<li>提高数据独立性的服务；</li>
<li>支持数据通信。</li>
</ul>
<p>DBMS 的优点：</p>
<ul>
<li>受控的数据冗余；</li>
<li>数据一致性；</li>
<li>相同数据量表示更多信息；</li>
<li>数据共享；</li>
<li>增强的数据完整性；</li>
<li>增强的安全性；</li>
<li>强制执行标准；</li>
<li>经济合算的规模；</li>
<li>平衡各种需求冲突；</li>
<li>增强的数据可访问性和响应性；</li>
<li>提高的生产率；</li>
<li>通过数据的独立性增强可维护性；</li>
<li>提高的并发性；</li>
<li>增强的备份和恢复服务。</li>
</ul>
<p>DBMS 的缺点：</p>
<ul>
<li>复杂性高；</li>
<li>规模大；</li>
<li>DBMS 的费用高；</li>
<li>需要附加的硬件费用；</li>
<li>转化费用大；</li>
<li>性能相对较低；</li>
<li>故障带来的影响较大。</li>
</ul>
<span id="more"></span>

<h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><h3 id="ANSI-SPARC-三层体系结构"><a href="#ANSI-SPARC-三层体系结构" class="headerlink" title="ANSI-SPARC 三层体系结构"></a>ANSI-SPARC 三层体系结构</h3><p><strong>三层体系结构</strong>包括<strong>外部层</strong>、<strong>概念层</strong>和<strong>内部层</strong>：</p>
<ul>
<li><strong>外部层</strong>：数据库的用户视图。这一层描述与每一个用户相关的数据库部分。</li>
<li><strong>概念层</strong>：数据库的整体视图。这一层描述了哪些数据被存储在数据库中，以及这些数据库之间的联系。</li>
<li><strong>内部层</strong>：数据库在计算机上的物理表示。这一层描述数据是如何存储在数据库中的。</li>
</ul>
<p>内部层之下的是<strong>物理层</strong>，物理层可能在 DBMS 的指导下受操作系统的控制。</p>
<p>三层体系结构的目的是将用户的数据库视图与数据库的物理描述分离开，以保证<strong>数据独立性</strong>。这意味着对较低层的修改不会对较高层造成影响。有两种类型的数据独立性：<strong>逻辑数据独立性</strong>和<strong>物理数据独立性</strong>：</p>
<ul>
<li><strong>逻辑数据独立性</strong>：指外部模式不受概念模式变化（例如添加或删除实体、属性或者联系）的影响；</li>
<li><strong>物理数据独立性</strong>：指概念模式不受内部模式变化（例如使用不同的文件组织方式或者存储结构、使用不同的存储设备、修改索引或散列算法）的影响。</li>
</ul>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><strong>数据模型</strong>是一组集成的概念，用于描述和操纵组织机构内的数据、数据间联系以及对数据的约束。其包含下列三个组件：</p>
<ul>
<li><strong>结构部分</strong>，由一组创建数据库的规则组成。</li>
<li><strong>操纵部分</strong>，定义允许对数据进行的操作的种类；</li>
<li><strong>一组完整性约束</strong>，确保数据的准确性。</li>
</ul>
<p>数据模型的分类：</p>
<ul>
<li>基于对象的数据模型：用到实体、属性和联系等概念<ul>
<li>实体-联系（ER）模型</li>
<li>语义模型</li>
<li>函数模型</li>
<li>面向对象模型</li>
</ul>
</li>
<li>基于记录的数据模型：数据库由不同类型的固定格式记录组成<ul>
<li>关系数据模型</li>
<li>网状数据模型</li>
<li>层次数据模型</li>
</ul>
</li>
<li>物理数据模型：描述数据如何存储在计算机中</li>
</ul>
<h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><h4 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h4><ul>
<li><strong>关系</strong>：由行和列组成的表；</li>
<li><strong>属性</strong>：关系中命名的列；</li>
<li><strong>域</strong>：一个或多个属性的取值集合；</li>
<li><strong>元组</strong>：关系中的每一行；</li>
<li><strong>维数</strong>：关系所包含的属性的个数；</li>
<li><strong>基数</strong>：关系所包含的元组的个数；</li>
<li><strong>关系模式</strong>：用一组属性和域名对定义的具名的关系。</li>
</ul>
<h4 id="关系关键字"><a href="#关系关键字" class="headerlink" title="关系关键字"></a>关系关键字</h4><ul>
<li><strong>超关键字（superkey）</strong>：一个属性或属性集合，它能唯一地标识出关系中的每个元组；</li>
<li><strong>候选关键字（candidate key）</strong>：最小的超关键字；</li>
<li><strong>主关键字（primary key）</strong>：被选用于唯一标识关系中各元组的候选关键字。没有被选为主关键字的候选关键字称为<strong>可替换关键字（alternate key）</strong>；</li>
<li><strong>外部关键字（foreign key）</strong>：当一个关系中的某个属性或属性集合与另一个关系（也可能就是自己）的候选关键字匹配时，就称这个属性或属性集合为外部关键字。</li>
</ul>
<h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><p><strong>域约束</strong>：限定关系中各个属性的取值集合。</p>
<p><strong>实体完整性</strong>：在基本关系中，主关键字的属性不能为空；</p>
<p><strong>引用完整性</strong>：如果在关系中存在某个外部关键字，则它的值与主关系中某个元组的候选关键字取值相等（或者全为空）。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>在关系模型中，“<strong>视图</strong>”指<strong>虚关系</strong>或称<strong>导出关系</strong>，即无需单独存在，必要时可从一或多个基本关系中<strong>动态地</strong>将其导出。</p>
<p>需要视图机制的原因有：</p>
<ul>
<li>通过对特定用户隐藏部分数据库信息，提供了一个强大而灵活的安全机制；</li>
<li>允许用户根据自己的需求自定义访问数据的方法；</li>
<li>可以简化对基本关系的复杂操作。</li>
</ul>
<p>不是所有的视图都可更新。</p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>事务</strong>指由一个或多个 SQL 语句组成的<strong>逻辑操作单位</strong>，可视为一组操作，通过<code>COMMIT</code>语句提交，通过<code>ROLLBACK</code>语句回退。其满足 ACID 特性：</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：事务被视为不可分割的最小单元，要么全部执行，要么都不执行。</li>
<li><strong>一致性（Consistency）</strong>：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li><strong>隔离性（Isolation）</strong>：事务的执行相互独立。未完成事务的中间结果对其它事务是不可见的。由并发控制子系统负责保证事务的隔离性。</li>
<li><strong>持久性（Durability）</strong>：成功完成（提交）的事务的结果要永久地记录在数据库中，不能因以后的故障而丢失。可以通过数据库备份和数据恢复来保证事务的持久性。</li>
</ul>
<!--## 实体-联系建模（E-R）-->

<!--12、13章-->

<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="规范化的目的"><a href="#规范化的目的" class="headerlink" title="规范化的目的"></a>规范化的目的</h3><p><strong>规范化</strong>是一种能够生成一组既具有所期望的特性又能满足企业数据需求的关系的技术，也是一种<strong>依靠关键字和属性之间的函数依赖对关系进行验证</strong>的形式化技术。</p>
<h3 id="数据冗余与更新异常"><a href="#数据冗余与更新异常" class="headerlink" title="数据冗余与更新异常"></a>数据冗余与更新异常</h3><p>存在数据冗余的关系可能产生<strong>更新异常</strong>问题，更新异常可分为<strong>插入异常</strong>、<strong>删除异常</strong>和<strong>修改异常</strong>。</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>规范化的一个重要的概念是<strong>函数依赖</strong>，函数依赖描述了属性之间的联系。例如，加入 A 和 B 是关系 R 的属性（或属性组），如果 A 的每个值都仅与 B 中的一个值对应，那么 B 就函数依赖于 A（记为 A -&gt; B）。函数依赖的<strong>决定方</strong>是位于箭头左端的属性或属性组。</p>
<p><strong>完全函数依赖</strong>：假设 A 和 B 是某一关系的属性（组），若 B 函数依赖于 A，但不函数依赖于 A 的任一真子集，则称 B 完全函数依赖于 A。</p>
<p><strong>传递依赖</strong>：假设 A、B、C 是某一关系的属性，若 A -&gt; B，B -&gt; C，则称 C 通过 B 传递依赖于 A（假设 A 并不函数依赖于 B 或 C）。</p>
<p>在规范化时使用的函数依赖具有以下特性：依赖左右两边的属性（组）之间具有一对一的联系，且恒成立，并且右边完全函数依赖于左边。</p>
<p>确定关系函数依赖集的<strong>主要目的</strong>是确定该关系必须满足的完整性约束集，从而确定候选关键字和主关键字。</p>
<h3 id="规范化过程"><a href="#规范化过程" class="headerlink" title="规范化过程"></a>规范化过程</h3><p><strong>非范式（UNF）</strong>是一个包含了一个或多个重复组的表</p>
<p><strong>第一范式（1NF）</strong>是指每一行和每一列相交的位置有且仅有一个值的关系。</p>
<p><strong>第二范式（2NF）</strong>是指已经是第一范式且每个非关键字属性都完全函数依赖于主关键字的关系。</p>
<p><strong>第三范式（3NF）</strong>是满足第一范式和第二范式的要求且所有非关键字属性都不传递依赖于主关键字的关系。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要参考机械工业出版社《数据库系统–设计、实现与管理（基础篇）》。</p>
<p>其他参考资料：</p>
<ul>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">Interview-Notebook/数据库系统原理.md at master · CyC2018/Interview-Notebook</a></li>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/SQL.md">Interview-Notebook/SQL.md at master · CyC2018/Interview-Notebook</a></li>
</ul>
]]></content>
      <categories>
        <category>学科补完计划</category>
      </categories>
      <tags>
        <tag>学科复习笔记</tag>
        <tag>数据库系统</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理复习笔记</title>
    <url>/blog/fundamentals-of-compiling-notes/</url>
    <content><![CDATA[<p>开始学科复习。选择编译原理作为第一门复习的课程，因为其内容不算太多，大部分计算过程可以暂时不用记录和练习，而且没什么前置知识。</p>
<p>选用课本是上课时用的清华大学出版社《编译原理》（其实我觉得这本书里给部分概念下定义时没有做到简洁明了，挺难理解的）。以下是记录的笔记。不求全面，只求适合自己之后再次复习使用。</p>
<span id="more"></span>

<h2 id="编译程序与编译过程"><a href="#编译程序与编译过程" class="headerlink" title="编译程序与编译过程"></a>编译程序与编译过程</h2><h3 id="编译程序（Compiler）"><a href="#编译程序（Compiler）" class="headerlink" title="编译程序（Compiler）"></a>编译程序（Compiler）</h3><ul>
<li>从功能上看，一个编译程序就是一个语言翻译程序；</li>
<li>基本任务：将源语言程序翻译成等价的目标语言程序。</li>
<li>重要性：使多数计算机用户不必考虑与机器有关的繁琐细节，使程序员独立于机器。</li>
</ul>
<h3 id="解释程序（Interpreter）"><a href="#解释程序（Interpreter）" class="headerlink" title="解释程序（Interpreter）"></a>解释程序（Interpreter）</h3><p>以语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源代码本身。</p>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ol>
<li><strong>词法分析</strong>：</li>
</ol>
<ul>
<li>功能：从左到右扫描源程序，并将该字符串转换成单词（Token）串；同时，检查词法错误、进行标识符登记——符号表管理</li>
<li>工具：正规表达式、自动机</li>
</ul>
<ol start="2">
<li><strong>语法分析</strong>：</li>
</ol>
<ul>
<li>功能：在词法分析的基础上将单词序列分解成各类语法短语；构造分析树，指出语法错误，指导翻译。</li>
</ul>
<ol start="3">
<li><strong>语义分析</strong>：</li>
</ol>
<ul>
<li>功能：审查源程序有无语义错误，为代码生成阶段收集类型信息；</li>
</ul>
<ol start="4">
<li><strong>中间代码生成</strong>：</li>
</ol>
<ul>
<li>功能：经过上述工作之后，将源程序变为独立于具体硬件的记号系统；</li>
</ul>
<ol start="5">
<li><strong>代码优化</strong>：</li>
</ol>
<ul>
<li>对前一阶段产生的中间代码进行等价变换，以获取更高的执行效率（速度、空间）；</li>
<li>分为机器有关和机器无关</li>
</ul>
<ol start="6">
<li><strong>目标代码生成</strong>：</li>
</ol>
<ul>
<li>功能：将中间代码转换成目标机上的<strong>机器指令代码或者汇编代码</strong>，完成最后的翻译，可以运行；</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/18595460/38497042-45ebb4d0-3c32-11e8-93a6-23fe52e5a752.png" alt="2018-04-09 20 01 19"></p>
<h3 id="翻译程序的结构"><a href="#翻译程序的结构" class="headerlink" title="翻译程序的结构"></a>翻译程序的结构</h3><p><img src="https://user-images.githubusercontent.com/18595460/38499719-0c12b9d0-3c3b-11e8-81ee-61f038b98d32.png" alt="default"></p>
<p>符号表管理、错误处理：前端后端都有出现。</p>
<p><strong>遍（pass）</strong>：</p>
<ul>
<li>对源程序或源程序的中间结果从头到尾扫描，并做相关的加工处理，生成新的中间结果或目标程序；</li>
<li>遍可以和阶段相对应，也可无关；</li>
<li>分遍可以使编译程序的结构清晰，但增加 I/O 时间；</li>
<li>影响分遍因素：内存不够、全局优化需要、某些语言需要（如名字先引用后定义）。</li>
</ul>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>单词的形式化描工具：</p>
<ul>
<li>正规文法（3 型文法）</li>
<li>正规式（正则表达式）</li>
<li>自动机（DFA、NFA）</li>
</ul>
<h3 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h3><p><strong>确定的有穷自动机（DFA）</strong>和<strong>不确定的有穷自动机（NFA）</strong>的区别：确定性 =&gt; 对任何状态和输入符号，唯一地确定了下一个状态。</p>
<ul>
<li>NFA 转换为等价的 DFA：子集法</li>
<li>DFA 的化简</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/18595460/38499639-d58926e2-3c3a-11e8-820d-42f6984acc18.png" alt="dfa"></p>
<h2 id="文法与语言"><a href="#文法与语言" class="headerlink" title="文法与语言"></a>文法与语言</h2><p>产生式（又称规则）：a -&gt; b   左部 -&gt; 右部</p>
<p><strong>文法</strong>：</p>
<ul>
<li>阐明语法的一个工具。</li>
<li>作用：<ol>
<li>严格地定义句子的结构；</li>
<li>用适当条数的规则描述语言的全部句子。</li>
</ol>
</li>
<li>4 种文法类型：逐渐增加限制<ul>
<li>0 型文法：对于每个产生式 A -&gt; B，A 含至少一个非终结符</li>
<li>上下文有关的（1 型）：每个产生式均满足 |B| &gt;= |A|（除非 B 为空）</li>
<li>上下文无关的（2 型）：每个产生式均满足 A 是一个非终结符</li>
<li>正规文法（3 型）：每个产生式的形式都是 A -&gt; aB 或 A -&gt; a（A、B 都是非终结符，a 是终结符）</li>
</ul>
</li>
</ul>
<h3 id="上下文无关文法及其语法树"><a href="#上下文无关文法及其语法树" class="headerlink" title="上下文无关文法及其语法树"></a>上下文无关文法及其语法树</h3><ul>
<li>推导：不断替换文法产生式左部的非终结符号，直至全部将非终结符号替换为终结符号的过程</li>
<li><strong>最左推导</strong>：总是优先替换产生式左部最左侧的非终结符号</li>
<li><strong>最右推导</strong>：总是优先替换产生式左部最右侧的非终结符号（在形式语言中称为<strong>规范推导</strong>）</li>
<li>二义文法：存在某个句子对应两棵不同的语法树的文法</li>
</ul>
<h3 id="句型分析"><a href="#句型分析" class="headerlink" title="句型分析"></a>句型分析</h3><ul>
<li><p><strong>自上而下的分析方法</strong>：</p>
<ul>
<li>从文法的开始符号出发，反复使用各种产生式，寻找“匹配”于输入符号串的推导；</li>
<li>通过最左推导从顶部（根结点）开始构造 AST；</li>
<li>常用的分析器有递归下降语法分析器、LL 语法分析器。</li>
</ul>
</li>
<li><p><strong>自下而上的分析方法</strong>：</p>
<ul>
<li>从输入符号串开始，逐步进行“规约”，直至规约到文法的开始符号；</li>
<li>通过最右推导从底部（叶子结点）开始构造 AST；</li>
<li>常用的分析器有 LR 语法分析器、SLR 语法分析器、LALR 语法分析器。</li>
</ul>
</li>
<li><p>短语：一个句型的语法树中任一子树叶节点所组成的符号串都是该句型的短语。</p>
</li>
<li><p>直接短语：当子树不包含其他更小的子树时，该子树叶节点所组成的字符串就是该句型的直接短语。</p>
</li>
<li><p>句柄：句柄是最左边的直接短语。</p>
</li>
</ul>
<p>例子：</p>
<p><img src="https://user-images.githubusercontent.com/18595460/38556812-8941d1b2-3cfd-11e8-8d48-4d4bdff4fef4.png" alt="20161213185118430"></p>
<p>可得<code>S=(Sd(T)db)</code>为此文法的一个句型：</p>
<ul>
<li>短语：<code>S</code>，<code>(T)</code>，<code>b</code>，<code>Sd(T)</code>，<code>Sd(T)db</code>，<code>(Sd(T)db)</code></li>
<li>直接短语：<code>S</code>，<code>(T)</code>，<code>b</code></li>
<li>句柄：<code>S</code></li>
</ul>
<h2 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h2><ul>
<li>自顶向下的确定分析方法：<ul>
<li>优点：实现方法简单、直观，便于手工构造或自动生成语法分析器</li>
<li>缺点：对文法有一定限制 </li>
</ul>
</li>
<li>自顶向下的不确定分析方法：<ul>
<li>带回溯</li>
<li>实际上是一种穷举的试探方法，效率低，代价高，极少使用</li>
<li>文法不满足 LL(1) 时使用</li>
</ul>
</li>
</ul>
<h3 id="确定的自顶向下分析思想"><a href="#确定的自顶向下分析思想" class="headerlink" title="确定的自顶向下分析思想"></a>确定的自顶向下分析思想</h3><p>LL(1) 文法是能够使用确定的自顶向下分析技术的。</p>
<p>LL(1) 的含义：</p>
<ul>
<li>第 1 个 L 表明自顶向下分析是从左向右扫描输入串；</li>
<li>第 2 个 L 表明分析过程中将用最左推导；</li>
<li>1 表明只需向右看一个符号便可决定选择哪个产生式进行推导。</li>
</ul>
<h3 id="LL-1-文法的判别"><a href="#LL-1-文法的判别" class="headerlink" title="LL(1) 文法的判别"></a>LL(1) 文法的判别</h3><p><img src="https://user-images.githubusercontent.com/18595460/38565503-1138b43a-3d14-11e8-8275-9488c8675389.png" alt="2018-04-10 22 48 10"></p>
<p>具体见课本。</p>
<h3 id="某些非-LL-1-文法到-LL-1-文法的等价变换"><a href="#某些非-LL-1-文法到-LL-1-文法的等价变换" class="headerlink" title="某些非 LL(1) 文法到 LL(1) 文法的等价变换"></a>某些非 LL(1) 文法到 LL(1) 文法的等价变换</h3><p>若文法中含有直接或间接左递归，或含有左公共因子，则该文法肯定不是 LL(1) 文法。因此，要做某些非 LL(1) 文法到 LL(1) 文法的等价变换，需要：</p>
<ol>
<li>提取左公共因子；</li>
<li>消除左递归。</li>
</ol>
<p>具体操作见课本。</p>
<h2 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h2><ul>
<li>又称<strong>移进-归约分析</strong></li>
<li>实现思想：对输入符号串自左向右进行扫描，并将输入符逐个<strong>移进</strong>一个后进先出栈中，边移入边分析，一旦栈顶符号串形成某个句型的句柄或其他可归约串（对应某产生式的右部）时，就用该产生式的左部非终结符代替右部的文法符号串。这个行为称为一步<strong>归约</strong>。</li>
</ul>
<h2 id="LR-分析"><a href="#LR-分析" class="headerlink" title="LR 分析"></a>LR 分析</h2><p>LR 分析法是一种能根据当前分析栈中的符号串和向右顺序查看输入串的 k 个符号就可以唯一确定分析器的动作是移进还是归约、用哪个产生式归约，因而能够唯一地确定句柄。</p>
<p>内容太多，图太多，但是对现阶段的我不太重要，故略。如果有学弟学妹看到了，这章是重点，所有例题都要自己推一遍。</p>
<h2 id="语法制导的语义计算"><a href="#语法制导的语义计算" class="headerlink" title="语法制导的语义计算"></a>语法制导的语义计算</h2><p>两种重要的语义计算模型：</p>
<ul>
<li><strong>属性文法</strong>：在文法基础上，为文法符号关联有特定意义的<strong>属性</strong>，并为产生式关联相应的<strong>语义动作</strong>或<strong>条件谓词</strong>。</li>
<li>翻译模式：在形式上类似于属性文法，但允许由<code>&#123;&#125;</code>括起来的语义动作出现在产生式右端的任何位置，以此显式地表达属性计算的次序。</li>
</ul>
<h3 id="基于属性文法的语义计算"><a href="#基于属性文法的语义计算" class="headerlink" title="基于属性文法的语义计算"></a>基于属性文法的语义计算</h3><ul>
<li><p><strong>综合属性</strong>：产生式左部的非终结符的某个属性。计算时自底向上传递信息。</p>
</li>
<li><p><strong>继承属性</strong>：产生式右部某个文法符号的某个属性。计算时自顶向下传递信息。</p>
</li>
<li><p><strong>遍历分析树进行语义计算</strong></p>
<ul>
<li>可以通过标注来表示属性的计算结果</li>
<li>在语法分析<strong>遍</strong>之后进行，不能体现语法制导方法的优势</li>
<li>实际的编译程序中，语法制导的语义计算大都采用单遍的过程（语法分析过程中完成语义动作） =&gt; 不是所有属性文法都适合单遍的处理过程 =&gt; 受限的属性文法</li>
</ul>
</li>
</ul>
<p>受限的属性文法：</p>
<ul>
<li><strong>S-属性文法</strong>：只包含综合属性的属性文法</li>
<li><strong>L-属性文法</strong>：既可以包含综合属性，也可以包含继承属性，但要求产生式右端某文法符号的继承属性的计算只取决于该符号左边符号的属性（对于产生式左部的符号，只能是继承属性）</li>
<li>S-属性文法是 L-属性文法的一个特例。</li>
</ul>
]]></content>
      <categories>
        <category>学科补完计划</category>
      </categories>
      <tags>
        <tag>学科复习笔记</tag>
        <tag>编译技术</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象程序设计复习笔记</title>
    <url>/blog/OOP-notes/</url>
    <content><![CDATA[<p>作为一个软件工程的大三学生，如果要求我立刻回答“面向对象程序设计是什么？”、“面向对象的特性是什么？”等问题，我想我是难以做到的。这是因为我们专业的“面向对象程序设计”这一门课程后有一个“(Java)”，在上这门课的时候我们可能更多地关注 Java 语法，而忽略了面向对象程序设计思想的一些精髓。实际上这些精髓映射出的是软件工程发展过程的智慧成果，只是当时我们什么也不懂。而面向对象程序设计的思想及设计模式的韵味则需要更大的代码量才能一探究竟。总之，这篇复习笔记会比较简洁地重温一下这些精髓的概念，真正去理解面向对象的思想，才会发现这些概念的设计精妙之处。</p>
<h3 id="概念重温"><a href="#概念重温" class="headerlink" title="概念重温"></a>概念重温</h3><ul>
<li><strong>对象</strong>：一个自包含的实体，用一组可识别的特性和行为来标识。</li>
<li><strong>类</strong>：具有相同的属性和功能的对象的抽象的集合。</li>
<li><strong>实例化</strong>：创建对象的过程。</li>
<li><strong>方法重载</strong>：提供创建同名的多个方法的能力，但这些方法需使用不同的参数类型。好处是在不改变原方法的基础上，新增功能。</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。在 OOP 中，<strong>不必关心对象的具体实现，只要能够满足用户的需求即可</strong>。</p>
<p>传统的结构化程序设计通过设计一系列的<strong>过程</strong>（即算法）来求解问题，首先确定如何操作数据，然后再决定如何组织数据。而 OOP 则把数据放在第一位，然后再考虑操作数据的算法。</p>
<h3 id="面向对象的好处"><a href="#面向对象的好处" class="headerlink" title="面向对象的好处"></a>面向对象的好处</h3><p><strong>封装、继承、多态</strong>，<strong>面向对象的三大特性</strong>降低了程序的耦合度，从而存在以下优点：</p>
<ul>
<li>可维护</li>
<li>可复用</li>
<li>可扩展</li>
<li>灵活性好</li>
</ul>
<span id="more"></span>

<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装（encapsulation）</strong>指每个对象都包含它能进行操作所需要的所有信息，因此对象不必依赖其他对象来完成自己的操作。</p>
<p>实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域，程序仅通过对象的方法与对象数据进行交互。</p>
<p>优点：</p>
<ol>
<li>良好的封装能减少耦合；</li>
<li>类内部的实现可以自由修改；</li>
<li>类具有清晰的对外接口。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承（inheritance）</strong>定义了类如何相互关联，共享特性。继承的工作方式是，定义父类和子类，其中子类不但继承父类所有特性，还可以定义新的特性。</p>
<p>在 Java 中，继承通过关键字<code>extends</code>实现。有些语言（如 C++）允许一个类有多个父类（称为多继承），而 Java 不支持多继承，而是选择用接口提供多继承的好处，并避免多继承的复杂性和低效性。</p>
<p>如果子类继承于父类：</p>
<ol>
<li>子类拥有父类非<code>private</code>的属性和功能；</li>
<li>子类具有自己的属性和功能；</li>
<li>子类还可以以自己的方式实现父类的功能（<strong>方法重写</strong>）。</li>
</ol>
<p>优点：</p>
<ol>
<li>使得所有子类公共部分都放在父类，使得代码得到共享，避免重复；</li>
<li>继承可使得修改或扩展继承而来的实现都较为容易。</li>
</ol>
<p>缺点：</p>
<ol>
<li>继承是一种类与类之间<strong>强耦合</strong>的关系。父类变，子类不得不变；</li>
<li>继承会破坏保障，父类实现细节暴露给子类。</li>
</ol>
<p>如果想要阻止某个类或方法被继承，可以使用<code>final</code>修饰符。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>表示不同的对象可以执行相同的动作，但要通过它们自己的实现代码来执行。</p>
<ol>
<li>子类以父类的身份出现；</li>
<li>子类在工作时以自己的方式来实现；</li>
<li>子类以父类的身份出现时，子类特有的属性和方法不可以使用。</li>
</ol>
<p>多态的原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。</p>
<p>实现多态的技术称为<strong>动态绑定（dynamic binding）</strong>，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<ul>
<li>静态绑定发生在编译时期，动态绑定发生在运行时；</li>
<li>使用<code>private</code>或<code>static</code>或<code>final</code>修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定；</li>
<li>静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成；</li>
<li>重载（Overload）的方法使用静态绑定完成，而重写（Override）的方法则使用动态绑定完成。</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>Java 中，使用<code>abstract</code>可以声明一个<strong>抽象方法</strong>。为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为<strong>抽象类</strong>。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;  <span class="comment">// 无需实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象方法充当着占位的角色，具体实现在子类中。若子类没有全部实现抽象方法，则子类也必须被声明为抽象类。</p>
<p>抽象类不能被实例化，但是可以定义一个抽象类的<strong>对象变量</strong>并引用非抽象子类的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student(<span class="string">&quot;Kyon Huang&quot;</span>, <span class="string">&quot;Software Engineering&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>接口（interface）</strong>是对类的一组需求描述，主要用来描述类具有什么功能，而并不给出每个功能的具体实现。一个类可以<strong>实现（implement）</strong>一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。</p>
<p>例如，<code>Arrays</code>类中的<code>sort</code>方法承诺可以对对象数组进行排序，但前提是对象所属的类必须实现了<code>Comparable</code>接口。<code>Comparable</code>接口的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 接口中所有方法自动为 public，不必提供关键字</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让类实现一个接口，通常需要下面两个步骤：</p>
<ol>
<li>将类声明为实现给定的接口（使用关键字<code>implements</code>）；</li>
<li>对接口中的所有方法进行定义。</li>
</ol>
<p>在上例中，让<code>Employee</code>类实现<code>Comparable</code>接口，则有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口不是类，不能使用<code>new</code>运算符实例化一个接口。但是可以声明接口的变量，并引用实现了接口的类对象。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Java 核心技术卷 I》</li>
<li>《大话设计模式》</li>
</ul>
]]></content>
      <categories>
        <category>学科补完计划</category>
      </categories>
      <tags>
        <tag>面向对象程序设计</tag>
        <tag>软件工程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Goodbye 2017, hello 2018</title>
    <url>/blog/bye2017hello2018/</url>
    <content><![CDATA[<blockquote>
<p>2017 年过去了，我很怀念它。</p>
</blockquote>
<p>时间匆匆，转眼又到了一年的结尾。现在我坐在图书馆里，周围很多考研的学长学姐明天就要奔赴考场，其中也包括院队的几个老大哥。明年的这时我在哪里？在做什么？没有答案。</p>
<p>这个博客的第一篇文章在去年的 12 月 4 号写下，迄今也有一年有余了。看了看去年的总结和展望，大部分的计划都实现了，大概是因为写的比较保守的缘故。而“早睡早起”、“尽量不翘课”、“在自己真正的兴趣上利用时间”、“每天过得健康、充实、开心”这几点没有做到，尤其是最后一点。</p>
<p>2017 年，尤其是下半年，我时常想要遵从兴趣、学习技术、保持自信、做到更好，但又日复一日地跟懒惰、压力、无所适从、自我怀疑、对未知的未来的恐惧作着斗争。20 岁的路口有了更多的分岔，很多以前从来没有想过的东西不停地折磨着我，而我又不是那种十分豁达开朗的性格，只能尽力不在这些负面情绪中沉沦。也许在新的一年里斗争还会继续下去，我希望最终乐观战胜忧郁，我战胜过去的自己。</p>
<p>总之，无论是论取得的各种成果，还是既有价值观的动荡，2017 年于我个人都是重要的一年。让所有的改变在 2018 年来得更猛烈一些吧，我喜欢这种改变。</p>
<span id="more"></span>

<h2 id="2017-年终总结"><a href="#2017-年终总结" class="headerlink" title="2017 年终总结"></a>2017 年终总结</h2><h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p>到落笔为止，值得一提的成果有：</p>
<ul>
<li>2017 年更新了博客 45 篇，总访问量达到 2400 余次（估计有一半是自己贡献的，哈哈）。</li>
<li>Github 有 599 次 contributions，9 个 star。</li>
<li>LeetCode 做了 106 道题，还在每日增加中。</li>
<li>砍下了花旗杯的三等奖，这是我第一个含金量比较高的奖，还是很有纪念意义的。</li>
<li>必修绩点保持在应该可以保研的水平。</li>
</ul>
<p>课余学习的技术：</p>
<ul>
<li>大二下学期自己学习前端，主要是玩 Vue 框架以及相关生态环境；</li>
<li>暑假在花旗杯项目开发的空余时间稍微学了一些 Node.js；</li>
<li>大三上学期在朱老师这里，初步地学了一些机器学习和 Spark 的东西，并有了包括读论文在内的学术研究的意识。</li>
</ul>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>我的一些观念和思想在这一年有了很大的变化，其中一些我觉得比较通用的，在这里和大家分享：</p>
<ul>
<li><p><strong>敏捷学习</strong>：在软件工程领域，有些知识是需要稳扎稳打的：数据结构与算法、Unix、数据库、计算机组织与体系结构、操作系统、计算机网络…但是，在实际开发中，也有很多东西需要快速上手，读一遍官方文档就可以慢慢地开始使用，在实践中加深理解。“工程师的工作大部分就是造轮子与用轮子，而工具的逐渐标准化使得重复造轮子的需求越来越弱，越来越多的工程师核心任务并不是研发，而是整合。”要善于利用各类工具，快速地实现自己的想法。尤其对于轮子满天飞的前端来说，快速地使用各类工具是必备的技能。很多工具可能只用一次，但对于更多比较常用的工具，需要记录自己的使用经验，方便自己下一次迅速上手。这也是为什么要写博客的原因之一。敏捷学习不代表用完就忘，也是要形成自己的知识体系的，我在这方面还有欠缺。</p>
</li>
<li><p><strong>敢于实践</strong>：紧接上一条。相信在学习的过程中，我们都会产生很多有意思的想法。对于我个人来言，很多想法都因为不愿投入时间和精力、担心半途而废，或是直接被难度给吓倒而成为空想，相关技术也失去了学习和实践的机会，目前只有 <a href="https://github.com/bighuang624/yuki">yuki</a> 算是写出来了。但是看到别人很多有意思的东西，又非常眼馋。这个月我创了一个 repo 作为专门记录这些想法的<a href="https://github.com/bighuang624/ideas">想法库</a>，以提醒自己，希望一步一步地去实现它们。</p>
</li>
<li><p><strong>社交</strong>：真正熟悉我的人，应该会知道我是一个大多数时候都喜欢独处的人，性格偏内向，不爱和陌生人打交道。通过这一年的很多经历和体验，我开始发觉社交的重要性。例如，当你想要找一些有技术特长、有时间的队友参加比赛，当你需要了解某方面的消息，当你需要获取一些资源和机会，等等。在新的一年里，我想要鼓励自己去开展更广泛的社交。当然，我还是比较偏爱有效交流以及不受他人打扰的独处时光。这需要一定的功力去保持平衡。</p>
</li>
<li><p><strong>个人品牌（个人影响力）</strong>：这一年开始通过 Github、知乎、掘金、微博、个人博客、微信公众号等途径了解一些大牛。他们在分享自身的技术心得、工作经验、生活体验的同时，也在打造自己的个人品牌，辐射自己的个人影响力。良好的个人品牌使得他们拥有更多机会结识同样优秀的业内外人士、在寻找新工作时能收获更多橄榄枝、更方便与人展开交流等优势。从博客和 Github 开始，我试着也去慢慢打造这样一张隐形的名片，也是社交的一种，并锻炼着我包括写作在内的各种能力。想要打造好这张名片，也需要更多技术历练和人生阅历。</p>
</li>
<li><p><strong>财务自由、投资理财</strong>：我一直是一个不太重视财务的人，因为我平时除了生活必需外基本不花钱，或者说，比较抠。随着愈发地喜欢这个行业，我也会发现很多时候，你的贫穷确实限制了你的想象力。比如我现在都不舍得掏钱买服务器，更别说买一些有意思的东西或者换电脑了。我希望自己开始培养投资理财的思维，慢慢实现财务自由，至少能够有一些收入来让自己的生活更舒服。</p>
</li>
<li><p><strong>程序员的第二技能（收入）</strong>：和上一条有关。这两天中兴技术主管跳楼的事也是沸沸扬扬，都说程序员吃青春饭，被认为是中年危机最严重的一个群体。我认为<a href="https://zhuanlan.zhihu.com/p/32147842">程序员如何保护自己？</a>这篇文章中有一个观点很棒：程序员一定要根据个人兴趣爱好选择第二技能并加以培养，使其成为特殊时期能够支撑自己的存在。第二技能也有助于树立之前说到的个人品牌。</p>
</li>
</ul>
<h2 id="2018-未来展望"><a href="#2018-未来展望" class="headerlink" title="2018 未来展望"></a>2018 未来展望</h2><ul>
<li><p><strong>各领域知识的查漏补缺</strong>：数据结构与算法、Unix、数据库、计算机组织与体系结构、操作系统、计算机网络等等。因为要找实习和夏令营，这大概会是 2018 上半年的主旋律。</p>
</li>
<li><p><strong>前端 / ML 学习</strong>：把这两个主攻方向单独拎出来。机器学习就跟着自己的节奏保持学习进度即可，当然也要重视实践。前端方面跟身边人聊了一下，可能考虑要暂时放一下了，以科研方面的学习为主。</p>
</li>
<li><p><strong>博客</strong>：继续保持高质量、较频繁的更新，将自己觉得不错的文章向知乎和掘金转移。其中，一些以前的、比较乱的读书笔记可能会根据知识点进行编排重整。另外，试着做一下 SEO，关注一下各类数据。</p>
</li>
<li><p><strong>学术研究</strong>：慢慢培养看论文的习惯。按照标准认真读，做一些简短的笔记。和朱老师经常交流一下，争取一些项目、论文的机会。</p>
</li>
<li><p><strong>社交</strong>：可以在在其他社区适当推广自己 Github 上的项目以及博客的文章，和他人保持友好的互动交流。</p>
</li>
<li><p><strong>比赛</strong>：到暑假为止可能还要参加一到两个比赛。做好准备工作，到时全身心投入，不后悔即可。</p>
</li>
<li><p><strong>实习</strong>：希望能找到行业领先的、氛围良好的、自成文化的公司，去体验，去学习。顺其自然吧。</p>
</li>
<li><p><strong>保研</strong>：尽力去追求更好的、更适合自己的。</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>新的一年，博客继续努力更新，欢迎保持关注，经常来逛逛（如果你使用 RSS，也是极好的）。另外，你可以在博客的左边栏中的“站点梗概”找到我的 <strong>Github 和知乎账号</strong>，在这里我会经常点赞、分享我看到的有价值的 repo 和文章。<strong>关注</strong>它们可以更详细地了解我最近在学什么、做什么、玩什么，也欢迎在这些地方分享、点赞我的 repo 和文章。</p>
<p>感谢你看到这里。让更好的我们在 2018 相会！</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>未来展望</tag>
      </tags>
  </entry>
  <entry>
    <title>Bye,2016 and Hello,2017</title>
    <url>/blog/bye2016hello2017/</url>
    <content><![CDATA[<p>开始写的时候是 12 月 30 日晚上，刚刚考完的大物感觉还不错。然后马上就到了 2016 年的最后一天。希望能在2016年内写完这篇博文，给自己的这一年做一个回顾。更重要的是，认真地考虑一下，2017 年应该去做些什么。</p>
  <span id="more"></span>

<h2 id="Goodbye-2016"><a href="#Goodbye-2016" class="headerlink" title="Goodbye, 2016"></a>Goodbye, 2016</h2><ol>
<li>从软件工程的萌新变成半萌新。感觉算是摸到了大门，往内斗胆一窥，发现这个世界广阔无垠。东瞧西瞥，还没有考虑好自己今后的发展方向，目前还是打算先以 java 的进阶为主，向 web 开发方面学习。</li>
<li>今年的学期感觉除了课业上按部就班外，在技术自学上没有激情。倒是暑假自学 java 有很大的收获。希望自己能够不忽视小块的时间去学习技术。当然，首先找到至少短期内的一个学习目标。</li>
<li>大一下学期进了院长实验室，但是总觉得项目安排上有点难受。外包任务让自己没什么长进。下学期看看怎么协调一下，当然也有可能下学期会参加花旗杯。</li>
<li>拿了一些院级活动的奖（而且基本都是产品&amp;设计方面的工作）。希望自己能做一些负责技术方面的、有价值的项目。</li>
<li>体测比去年同期略瘦，50米快了整整一秒。希望自己能保持锻炼，还能在院队有个位置。</li>
</ol>
<h2 id="Hello-2017"><a href="#Hello-2017" class="headerlink" title="Hello, 2017"></a>Hello, 2017</h2><ol>
<li>先顺利地过了上学期所有期末考。希望自己的绩点还能保持在3.5以上。认真复习，少浪，别懒！</li>
<li>寒假先定个小目标，比如啃啃 javascript，啃啃java 的高级特性，啃啃 lintcode，写几篇有用的技术博客，顺便把博客再折腾一下，最好买个域名。总之，要让 27 天的寒假过的有意义。寒假开始时再列个日程表。</li>
<li>早睡早起，勤奋刻苦，下学期尽量不翘课。都是专业课，认真听。还要在课余时间继续学技术。</li>
<li>希望能做一个真正意义上的大项目（比如花旗杯）。为了这个目标，学技术。</li>
<li>在自己真正的兴趣上利用时间，而不是无所事事地浪费。</li>
<li>每天过得健康、充实、开心！</li>
</ol>
<img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/2017bignews.gif" />]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>未来展望</tag>
      </tags>
  </entry>
  <entry>
    <title>yuki-目录文档生成工具</title>
    <url>/blog/yuki-intro/</url>
    <content><![CDATA[<blockquote>
<p>技术的学习一定要辅以代码的实践，菜鸟程序员扑在轮子上要像饥饿的人扑在面包上。<br>——沃兹基硕德</p>
</blockquote>
<p>受到掘金上看到的 <a href="https://github.com/kenshinji/yddict">yddict：一个命令行查单词的工具</a> 的启发，原来摸一个 Node.js 的 demo 不一定非要写一个服务器。恰逢最近开始看《算法（第4版）》，把练习代码和笔记传到 github 上时需要在 README.md 里放一份带链接的目录，方便在线跳转查阅。两者综合，就有了开发一个能够将项目内文件结构自动映射并生成为 README.md 的项目目录管理工具的灵感。</p>
<p>看上去是一个简单的小工具，实际上花了 3 天才基本成型（当然不是整的）。随着思路从项目目录管理到图书管理再到书籍再到文艺社，我决定将这个小工具命名为 <a href="https://github.com/bighuang624/yuki">yuki</a>，蕴含了我个人满满的宅趣味。</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/yuki/Yuki.jpg" />

<p>幸运的是，这个日语里常见的词竟然在 NPM 里还没被抢用。我也因此不用为其加个后缀，直接就可以用这个名字传上 NPM，以供使用。</p>
<p>这篇文章剩下来的篇幅一是介绍这个小工具的使用场景、实际用法等，二是大概谈一谈开发过程中稍微值得一记的东西。</p>
<span id="more"></span>

<h2 id="关于-yuki"><a href="#关于-yuki" class="headerlink" title="关于 yuki"></a>关于 yuki</h2><p>使用 Node.js 开发的项目目录管理工具，能够将项目内文件结构自动映射并生成为 README.md</p>
<img src="https://raw.githubusercontent.com/bighuang624/yuki/master/example.gif">

<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/bighuang624/yuki">bighuang624/yuki</a></p>
<h3 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h3><p>当一份 README.md 的主体内容是项目目录，而你又厌倦了每次增加、修改、删除项目中文件时都要对 README 进行维护，那么不妨试试 yuki！</p>
<p>它可以在极短时间内帮你生成符合要求的 README.md 文档。你更可以通过配置一份 yuki.config.json 来满足你的以下需求：</p>
<ul>
<li>固定文档标题</li>
<li>目录前后增加固定内容</li>
<li>映射时忽略指定文件夹、文件、扩展名</li>
<li>根据指定扩展名选择是否去掉文件名的扩展名或加上书名号</li>
<li>让每个文件都带上 Github 的链接以方便在线跳转查看</li>
</ul>
<p>你可以用 yuki 帮助你轻松维护 github 上类似博客、笔记、代码汇总等项目！</p>
<h3 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h3><p>我的<a href="https://github.com/bighuang624/Algorithms-notes">《算法》笔记及代码</a>项目的 README.md 完全通过 yuki 生成。你可以点击以查看效果。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>请确认你使用的电脑有 Node 环境，越新越好。</p>
<h4 id="安装-yuki"><a href="#安装-yuki" class="headerlink" title="安装 yuki"></a>安装 yuki</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g yuki</span><br></pre></td></tr></table></figure>

<h4 id="进入需要生成-README-md-的文件夹"><a href="#进入需要生成-README-md-的文件夹" class="headerlink" title="进入需要生成 README.md 的文件夹"></a>进入需要生成 README.md 的文件夹</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 请将 &lt;dirname&gt; 换为文件夹路径</span></span><br><span class="line"><span class="built_in">cd</span> &lt;dirname&gt;</span><br></pre></td></tr></table></figure>

<h4 id="创建-yuki-config-json（可选）"><a href="#创建-yuki-config-json（可选）" class="headerlink" title="创建 yuki.config.json（可选）"></a>创建 yuki.config.json（可选）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch yuki.config.json</span><br></pre></td></tr></table></figure>

<h4 id="配置-yuki-config-json（可选）"><a href="#配置-yuki-config-json（可选）" class="headerlink" title="配置 yuki.config.json（可选）"></a>配置 yuki.config.json（可选）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // README.md的大标题（h1），默认为所在文件夹名</span><br><span class="line">  &quot;title&quot;: &quot;《算法（第4版）》笔记及代码&quot;,</span><br><span class="line">  // github库地址，如果配置了这项会给每个文件加上超链接</span><br><span class="line">  // 如果配置，请保证index填写无误，且所有文件名不含空格（否则链接无法正确表示）</span><br><span class="line">  // branch默认为master</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;https://github.com/bighuang624/Algorithms-notes&quot;,</span><br><span class="line">    &quot;branch&quot;: &quot;master&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 目录开始的标题等级</span><br><span class="line">  // 默认为2，即该目录下的文件夹名等级从3开始，随层级深入递减</span><br><span class="line">  &quot;startLevel&quot;: 2,</span><br><span class="line">  // 需要忽略的目录、扩展名和文件，都以数组表示</span><br><span class="line">  &quot;ignore&quot;: &#123;</span><br><span class="line">    &quot;dir&quot;: [&quot;.git&quot;],</span><br><span class="line">    &quot;extname&quot;: [&quot;.json&quot;],</span><br><span class="line">    &quot;file&quot;: [</span><br><span class="line">      &quot;yuki.config.json&quot;,</span><br><span class="line">      &quot;.gitignore&quot;,</span><br><span class="line">      &quot;README.md&quot;,</span><br><span class="line">      &quot;.DS_Store&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  // 根据扩展名选择对展示的文件名做一些处理</span><br><span class="line">  // 每个扩展名的配置需要单独一个对象</span><br><span class="line">  // 目前支持省略扩展名&quot;withoutExt&quot;: true</span><br><span class="line">  // 和加上书名号&quot;withBookmark&quot;: true</span><br><span class="line">  &quot;format&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;extname&quot;: &quot;.md&quot;,</span><br><span class="line">      &quot;withoutExt&quot;: true,</span><br><span class="line">      &quot;withBookmark&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // 在大标题之后，目录之前添加的内容</span><br><span class="line">  // 每个对象可选择包含标题、标题等级和内容</span><br><span class="line">  // 其中，标题和标题等级需在一个对象中一同填写</span><br><span class="line">  &quot;prefix&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;content&quot;: &quot;[![作者](https:\//img.shields.io\/badge/%E4%BD%9C%E8%80%85-KyonHuang-7AD6FD.svg)](http:\//kyonhuang.top)&quot;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      &quot;title&quot;: &quot;目录&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  // 在README.md末尾添加的内容</span><br><span class="line">  // 和prefix相同，每个对象可选择包含标题、标题等级和内容</span><br><span class="line">  &quot;append&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;title&quot;: &quot;维护&quot;,</span><br><span class="line">      &quot;level&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;content&quot;: &quot;本文档由 [yuki](https://github.com/bighuang624/yuki) 维护&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 JSON 标准中不含注释，请在使用时将注释去掉。项目中也提供一份不带注释、可供修改使用的 yuki.config.json 模版。</p>
<p>不需要的配置选项请全部删除。</p>
<h4 id="创建-README-md"><a href="#创建-README-md" class="headerlink" title="创建 README.md"></a>创建 README.md</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yuki</span><br></pre></td></tr></table></figure>

<h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p><a href="https://github.com/bighuang624/yuki/blob/master/LICENSE">Apache License 2.0</a></p>
<h2 id="开发中的那些事"><a href="#开发中的那些事" class="headerlink" title="开发中的那些事"></a>开发中的那些事</h2><h3 id="Cli-命令工具开发的准备工作"><a href="#Cli-命令工具开发的准备工作" class="headerlink" title="Cli 命令工具开发的准备工作"></a>Cli 命令工具开发的准备工作</h3><p>我们来了解一下围绕 NPM 开发的准备工作。第一步自然是在文件夹下使用命令<code>npm init</code>生成 package.json 文件。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>可以通过以下命令在 NPM 资源库中注册用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm adduser</span><br></pre></td></tr></table></figure>

<p>之后跟着要求填写 Username、Password、Email 就 ok 了。项目发布前可能需要<code>npm login</code>一下。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>NPM 使用语义版本号来管理代码。语义版本号分为 X.Y.Z 三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新：</p>
<ul>
<li>如果只是修复 bug，需要更新 Z 位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新 Y 位。</li>
<li>如果有大变动，向下不兼容，需要更新 X 位。</li>
</ul>
<p>当然我这个小项目比较随便，bug 修的多了次版本号看心情也往上升一次。</p>
<p>你可以用<code>npm view &lt;pkg&gt; version</code>来查看你发布到 NPM 项目的现在版本号。</p>
<h4 id="测试小窍门"><a href="#测试小窍门" class="headerlink" title="测试小窍门"></a>测试小窍门</h4><p>这两个小窍门可以节省你在一边开发一边测试的时间（没发现之前，3 天的开发时间花在这上面的不少…）。</p>
<ul>
<li><p>在 package.json 所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p>
</li>
<li><p>使用<code>npm update &lt;pkg&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p>
</li>
</ul>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><p>想要在全局使用你编写的 cli 工具，你需要在 package.json 加一个 bin 属性：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;bin&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;yuki&quot;</span>: <span class="string">&quot;./index.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>yuki 换做你启动这个程序所要在命令行输入的命令。属性的值是项目的入口文件。添加这个属性后，在命令行执行<code>yuki</code>就等同于执行<code>node ./index.js</code>。</p>
<h4 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h4><p>项目写了一个版本准备发布，先在 package.json 所在目录下用<code>npm version</code>看一下版本号，然后就可以 publish 了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> yuki</span><br><span class="line">npm version</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<p>之后就可以通过全局安装来使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g yuki</span><br></pre></td></tr></table></figure>

<h3 id="获得程序运行的路径"><a href="#获得程序运行的路径" class="headerlink" title="获得程序运行的路径"></a>获得程序运行的路径</h3><p>说实话，一个我很不擅长的东西就是 API，哪怕是那些非常常用的。这次我一开始就遇到了麻烦：如何获得程序开始遍历的“根目录”路径？</p>
<p>在查找的同时顺便了解了一下获得各种路径的方法，有以下几种：</p>
<ul>
<li><p><code>process.cwd()</code>获得 Node.js 进程当前工作的路径（即执行命令行时候的路径，而非代码路径。例如在根目录下执行<code>node ./xxx/xxx/example.js </code>，则<code>process.cwd()</code>返回的是根目录地址）；</p>
</li>
<li><p><code>__dirname</code>: 获得代码存放的位置（例如运行位于<code>/usr/a</code>目录下的<code>example.js</code>文件：<code>node example.js</code>，则<code>__dirname</code>返回<code>/usr/a</code>）；</p>
</li>
<li><p><code>process.execPath</code>: 返回返回启动 Node.js 进程的可执行文件所在的绝对路径（也就是当前执行的 Node 自身的路径，例如：<code>/usr/local/bin/node</code>）。</p>
</li>
</ul>
<p>根据查询结果和实际需求，应该使用<code>process.cwd()</code>（我们要求在 package.json 所在目录下使用 yuki）。不过实际上使用的是<code>path.resolve()</code>。<code>path.resolve()</code>不含参数时，返回返回当前工作目录的绝对路径，也符合要求。</p>
<p>yuki 的编写也帮助我熟悉了 Node 里的很多 API，尤其是和 path 和 fs 相关的。</p>
<h3 id="先遍历文件再深度遍历文件夹"><a href="#先遍历文件再深度遍历文件夹" class="headerlink" title="先遍历文件再深度遍历文件夹"></a>先遍历文件再深度遍历文件夹</h3><p>开发的过程中发现一个问题：遍历文件夹 a 下的所有文件时，经常先深度遍历了其中的文件夹，导致文件排在这些文件夹深度遍历的结果之后，在生成的 README 中无法看出其准确位置。</p>
<p>解决方法还比较简单，就是在每一次递归的遍历方法中都建立一个队列，遍历到文件夹先推入队列，遍历到文件则展示。所有文件遍历结束后，将队列中的文件夹依次取出并遍历。这样既满足了要求，也没有对深度优先遍历造成影响。</p>
<p>更好的是，JS 的数组原生支持了<code>push</code>方法，使得我不用再写一个队列的实现。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尽管只是一个微不足道的小工具，我还是很开心能够根据自己的实际需求开发了 yuki，更开心的是，我有机会能在项目中夹带一点私货。早在看到尤大给 Vue 定下的版本名时，我就非常羡慕。这次终于如愿以偿。</p>
<p>如果你觉得这个小工具还不错，或者使用时觉得很方便、减轻了重复的工作负担，那么不妨为 <a href="https://github.com/bighuang624/yuki">yuki</a> 点一个 star，因为我憧憬着能在毕业前拥有一个自己的 100+ star 项目。</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/yuki/give-him-first.jpg" />

<p>当然，我更希望这些 star 是凭借我自己的开发创意和技术所得到的认可的。而我的开发经验确实不太足，所以如果你觉得这个工具不太好使、代码糟糕、发现了 bug，或是有可以增加的功能，也欢迎你开 issue 或者提交 PR 来告知我。</p>
]]></content>
      <categories>
        <category>开源小项目</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>yuki</tag>
        <tag>NPM</tag>
        <tag>cli-app</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Java的BiliBili视频信息爬虫</title>
    <url>/blog/biliInfoCrawler/</url>
    <content><![CDATA[<p>该项目要求设计并实现一个 BiliBili 视频信息爬虫，并且能够将每个分类收藏数前三的视频下载至本地。</p>
<img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/info.jpg" width="700px"/>

<p>该项目使用的软件有Eclipse（IDE）、Charles（抓包工具）、MySQL（数据库）、Navicat Premium（数据库可视化工具）。以下代码截图全部基于OS X系统上自己编写的代码。</p>
<span id="more"></span>

<h2 id="了解相关知识"><a href="#了解相关知识" class="headerlink" title="了解相关知识"></a>了解相关知识</h2><p>该实验所用到的知识有且不仅限于：</p>
<ol>
<li>HTTP 请求、响应和重定向；</li>
<li>使用 apache-httpclient 来实现对服务器的请求并收到响应；</li>
<li>用 jsoup 处理 html 文件；</li>
<li>数据库设计与使用；</li>
<li>Java IO下载视频文件；</li>
<li>同时，该程序使用了 Maven 来管理项目的依赖关系。</li>
</ol>
<h2 id="抓包并分析"><a href="#抓包并分析" class="headerlink" title="抓包并分析"></a>抓包并分析</h2><p>用一个抓包工具来分析浏览器打开 BiliBili 视频网时重要的请求与响应。这里我选用的是 Charles，当然也可以使用 Fiddler 或者其他好用的。</p>
<img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/debugger.jpg" width="700px"/>

<p>可以看到，图中选中的项即为访问 BiliBili 视频网分类页面时服务器向浏览器发送的 json 文件。路径中 tid 后的数字代表种类，pn 后的数字代表页数。可以看到访问时浏览器发出的请求参数，爬虫程序同样也要设置这些参数使服务器认为是浏览器在访问。而在每一个 json 文件中，有 20 个视频的信息，包括我们感兴趣的 av 号（Bilibili 视频 id号）、作者、种类、收藏数、硬币数等信息。我们之后将要对 json 文件进行处理来获得这些信息，并把它们存进数据库。</p>
<h2 id="爬虫相关方法"><a href="#爬虫相关方法" class="headerlink" title="爬虫相关方法"></a>爬虫相关方法</h2><ol>
<li><p>使用apache-httpClient来实现请求并得到响应，最终得到json文件。</p>
 <img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/code1.jpg" width="700px"/></li>
<li><p>通过JSONArray和JSONObject两个类方法对请求到的json文件进行处理，将得到的视频信息初始化为一个Bilibili对象（Bilibili类在Bilibili.java中定义），并调用JDBC.java中定义的方法将数据存入数据库。</p>
 <img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/code2.jpg" width="700px"/></li>
</ol>
<h2 id="视频下载相关方法"><a href="#视频下载相关方法" class="headerlink" title="视频下载相关方法"></a>视频下载相关方法</h2><ol>
<li><p>通过SQL语句选出该种类中收藏数前三的视频，返回其av号及其他信息。通过<a href="http://www.ibilibili.com加上av号,对其发出请求,获得html文件./">www.ibilibili.com加上av号，对其发出请求，获得HTML文件。</a></p>
 <img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/code3.jpg" width="700px"/></li>
<li><p>使用jsoup，利用标签对HTML文件进行解析，获得以<code>www.bilibilijj.com/Files/DownLoad/</code>为开头的视频下载地址。</p>
 <img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/code4.jpg" width="700px"/></li>
<li><p>利用 JAVA IO 的相关方法编写<code>readInputStream</code>和<code>getVideo</code>方法，下载视频保存至本地指定地址。</p>
 <img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/biliCrawler/code5.jpg" width="700px"/></li>
</ol>
<h2 id="调用方法并开多线程加速"><a href="#调用方法并开多线程加速" class="headerlink" title="调用方法并开多线程加速"></a>调用方法并开多线程加速</h2><p>在<code>main</code>方法中调用之前写好的方法，并开多线程加速爬取和视频下载。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过反复的设计、编程、测试、修改，最终的程序能够爬取 BiliBili 视频网音乐区 7 个类别约 62 万个视频的信息（由于校园网波动，最后只爬了62w，实际上音乐区应该不止这么多视频），将其存入数据库，并将每个类别收藏数前三的视频下载至本地，符合实验要求。</p>
<p>完整代码已经放在我的 Github 中。由于个人水平有限，可能存在错误或者性能优化方面的问题，欢迎讨论。</p>
<h2 id="项目中参考的资料"><a href="#项目中参考的资料" class="headerlink" title="项目中参考的资料"></a>项目中参考的资料</h2><ul>
<li><a href="http://czj4451.iteye.com/blog/1983889">普通Java工程转换成maven工程</a></li>
<li><a href="http://www.tuicool.com/articles/fAVzu2">Jsoup+json-lib解析xml带中括号的数组Json数据</a></li>
</ul>
]]></content>
      <categories>
        <category>开源小项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>demo</tag>
        <tag>爬虫</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Vue 撸一份线上简历有哪些坑</title>
    <url>/blog/make-a-resume/</url>
    <content><![CDATA[<p>昨天花了一天时间，用 Vue 给自己撸了一份线上简历，并借助 Github Pages 实现了在线预览的效果。</p>
<ul>
<li>项目地址：<a href="https://github.com/bighuang624/FE-resume">bighuang624/FE-resume
</a></li>
<li>在线预览地址：<a href="http://kyonhuang.top/FE-resume/">http://kyonhuang.top/FE-resume/</a></li>
</ul>
<p>目前实现的是最简单的效果，可以说只用了 Vue，不涉及全家桶里其他产品。从 UI、文字、性能、测试等各种角度都有改进的空间。这个小项目应该是会长期维护的。今天先总结一下，做到目前为止遇到的坑。</p>
<span id="more"></span>

<h2 id="在-Vue-中使用-sass"><a href="#在-Vue-中使用-sass" class="headerlink" title="在 Vue 中使用 sass"></a>在 Vue 中使用 sass</h2><p>这个步骤之前已经总结过，现在再在博客上记录一次，方便之后查找。</p>
<p>在 Webpack 中，所有的预处理器需要匹配相应的 loader。因此要使用 sass 或 scss，首先下载依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>

<p>然后在单文件组件中的<code>&lt;style&gt;</code>标签中加上<code>lang=&quot;sass&quot;</code>。<code>vue-loader</code>会根据<code>lang</code>属性推断出要使用的 loaders，并将内容交给相应的 loaders 处理：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;sass&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/* write sass here */</span></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与名称相反，sass-loader 默认解析 scss 语法，因此如果想使用 sass 语法，还需要在 build/vue-loader.conf.js 配置 vue-loader 的选项：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-0e5c5d774fa3e00a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:vue-loader.conf.png"></p>
<p>这样的修改不会影响 scss 的使用，记得修改<code>&lt;style&gt;</code>标签中为<code>lang=&quot;scss&quot;</code>即可。</p>
<h2 id="项目资源无法加载"><a href="#项目资源无法加载" class="headerlink" title="项目资源无法加载"></a>项目资源无法加载</h2><p>直接<code>npm run build</code>得到的项目，默认引用资源文件的路径为<code>/static/js/app.js</code>。所以程序若不在根目录下，就会出现资源文件引用错误的情况。</p>
<p>最简单的解决方案就是改动 webpack 的配置文件。将<code>/config</code>文件夹中的 index.js 文件中的<code>assetsPublicPath: &#39;/&#39;</code>改为<code>assetsPublicPath: &#39;./&#39;</code>即可，截图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-52590cfcce2b12ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="config:index.png"></p>
<p>如果你还使用了 vue-router，你需要在 router 的配置中加上一行<code>base: &#39;/[项目所在文件夹的名字]/&#39;</code>，如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e6de7fc323ef16e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router.png"></p>
<p>注意：如果启用了 vue-router 的 history 模式，你需要跟着 <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html">vue-router 官方文档的后端配置例子</a> 对服务器进行一定的配置。</p>
<p>这是因为在 history 模式下，router 只是通过 JS 操作 window.history 来改变浏览器地址栏里的路径，并没有发起 http 请求。但是直接在地址栏中输入形如<code>http://www.example.com/example/item/1</code>这样的地址时，就一定先要对服务器发起 http 请求。此目标在服务器上不存在，于是会返回 404。修改服务器的配置，以将所有的请求全部转发到<code>index.html</code>上。</p>
<p>当然，这意味着单纯使用 Github Pages 的在线预览功能没办法进行这样的配置。你也可以关注知乎上的这个问题 <a href="https://www.zhihu.com/question/64173754">怎样为Github pages Hack使用了vue-router history模式的vue应用？ - 知乎</a> 来看别人的解决方法。</p>
<h2 id="iconfont-无法加载"><a href="#iconfont-无法加载" class="headerlink" title="iconfont 无法加载"></a>iconfont 无法加载</h2><p>字体图标无法正确加载。参考 <a href="https://github.com/vuejs-templates/webpack/issues/166">https://github.com/vuejs-templates/webpack/issues/166</a> ，得到的解决方法是修改 build/utils.js 文件，增加一行<code>publicPath: &#39;../../&#39;</code>，如截图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-4154f0ddd63f0953.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build:utils.png"></p>
<p>保存后，<code>npm run build</code>打包得到的项目中 iconfont 就可以正常显示了。</p>
<h2 id="实现-Github-Pages-在线预览"><a href="#实现-Github-Pages-在线预览" class="headerlink" title="实现 Github Pages 在线预览"></a>实现 Github Pages 在线预览</h2><p>参考 <a href="https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/">Configuring a publishing source for GitHub Pages - User Documentation</a>，实现 Github Pages 在线预览功能有好几种方法，可以设置从<code>master</code>分支、<code>gh-pages</code>分支或者<code>master</code>分支下的<code>/docs</code>文件夹中读取。我就选择了最简单的一种方法，把<code>npm run build</code>打包下来的<code>/dist</code>文件夹改名为<code>/docs</code>。</p>
<p>之后，在 Github 项目主页的 Settings 下的 Github pages 下进行设置 Source 为<code>master branch /docs folder</code>即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-ec745a361c794183.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="githubpage.png"></p>
<p>如果你之前使用过 Github Pages 并绑定了一个域名，那么这个项目的预览地址会像<code>http://kyonhuang.top/resume/</code>这样在这个域名下，看起来很爽。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://vue-loader.vuejs.org/zh-cn/configurations/pre-processors.html">预处理器 · vue-loader</a></li>
<li><a href="http://upyang.com/2017/07/25/Vue%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0github%E5%B9%B6%E9%A2%84%E8%A7%88/">Vue项目打包上传到github预览</a></li>
<li><a href="https://www.zhihu.com/question/46630687/answer/157166318">vuejs怎么在服务器部署？ - 知乎</a></li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>撸这份简历，是一个总结，也是一个激励。</p>
<p>真正撸完简历，才发现自己在技术层面上的项目经历少的可怜，而技术也不敢说有什么掌握。以后看到这份简历，会让我非常想写一些拿得出手的开源项目，然后对项目经历进行修改。</p>
<p>读完《你不知道的JavaScript（中卷）》，就给 JS 的技能条涨 5 个百分点；用 Node 开发一个支持登录注册的后台，就给 Node 的技能条涨 5 个百分点；或者再点亮一个新的技能。</p>
<p>随着我的不断学习，希望这份简历越来越吸引人。</p>
]]></content>
      <categories>
        <category>开源小项目</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>Vue</tag>
        <tag>github 预览</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 使用技巧笔记</title>
    <url>/blog/sublime-text-learning/</url>
    <content><![CDATA[<p>作为一款主流前端开发编辑器软件，Sublime Text具有代码高亮、语法提示、自动完成，轻量级，易上手，并且支持插件扩展机制，可以说功能十分强大。</p>
<p>我用Sublime Text已经有一段时间了，但是只是浮于表面，没有进一步探索。作为一名准备在Web方面继续深研的软工学生，我决定对Sublime Text的使用技巧进行学习，并写下这篇笔记。</p>
<span id="more"></span>

<h2 id="快捷键-OS-X"><a href="#快捷键-OS-X" class="headerlink" title="快捷键(OS X)"></a>快捷键(OS X)</h2><ul>
<li>Command + 光标 多点编辑</li>
<li>Command + p 快速打开文件</li>
<li>Command + Shift + p 打开命令行面板</li>
<li>Command + + / - 字体放大/缩小</li>
<li>Command + K + B 面板显示/隐藏</li>
<li>Command + ] / [ 缩进/退回一个级别</li>
<li>Command + L 选择当前行</li>
<li>Command (+ Shift) + Enter (在上一行)下一行开辟新行</li>
<li>Option + 鼠标左键 块选择(自动进入多点编辑)</li>
<li>Alt(Command) + 左右键 单词(行)粒度的跳跃</li>
<li>Alt(Command) + Shift + 左右键 单词(行)选择(可以叠加使用多次)</li>
<li>Command + A 全选</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>编辑器右下角可以更改语法，也可以在命令行面板输入语法名进行选择。</p>
<p>命令行面板输入”Key Bindings - Default”可以看到所有的快捷键设置。</p>
<img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/sublime.jpg" />

<p>“Key Bindings - User”中自己可以设置快捷键，遵循JSON语法：</p>
<pre><code>[
  &#123; &quot;keys&quot;: [&quot;shift+tab&quot;],&quot;command&quot;: &quot;reindent&quot;,&quot;args&quot;: &#123;&quot;single_line&quot;:false&#125;&#125;
]
</code></pre>
<p>“Reindent Lines”调整缩进（已经被我设置快捷键Shift + Tab）。</p>
<p>如何得到命令名和参数：</p>
<ol>
<li>Ctrl + ` 打开控制台，输入”sublime.log_commands(True)”；</li>
<li>再在命令行面板中输入操作；</li>
<li>在工作台即可看到命令名和参数；</li>
</ol>
<h2 id="自定制"><a href="#自定制" class="headerlink" title="自定制"></a>自定制</h2><p>用户的设置保存在<code>/~/Library/Application Support/Sublime Text 3/Packages/User</code>中，写到这里的数据是不会因自动升级而被覆盖的。</p>
<p>推荐将这个文件夹中的内容同步到Github上。这样，在更换系统或电脑时，将文件夹clone下来进行替换，可以迅速按照自己的要求配置好。</p>
<p>15.05.17 更新：</p>
<p>把 sublime 中的 Tab 换成两个空格的缩进。方法详见<a href="http://blog.csdn.net/aerchi/article/details/50395288"> sublime text3里 修改TAB键为缩进为四个空格 </a>。</p>
<h2 id="扩展包"><a href="#扩展包" class="headerlink" title="扩展包"></a>扩展包</h2><p>到 <a href="https://packagecontrol.io/installation">https://packagecontrol.io/installation</a> 可以看到 sublime3 中的安装方式，Control + ` 打开控制台，运行代码就可以安装上了。</p>
<p>Command + Shift + p 打开命令行面板，敲<code>Install Package</code>来搜索并安装想要的包。<code>Remove Package</code>卸载插件。</p>
<p><code>Packages/User/</code> 下面的文件 <code>Package Control.sublime-settings</code> 里面列出已经安装的包。</p>
<p>我安装的包有（不定期更新）：</p>
<p>Git：这个包可以帮助我们在编辑器里完成git相关操作。在命令行面板中输入”Git Add Current File”、”Git Commit”、”Git Push”来完成相应操作。</p>
<p>emmet：Web前端开发必装包，敲 tab 键代码补齐。具体触发词参见 <a href="http://docs.emmet.io/cheat-sheet/">http://docs.emmet.io/cheat-sheet/</a>。如果我想用标签来包裹一些内容，我就先把内容选中，然后 Ctrl-w 。这个命令也可以在命令面板上呼叫 Wrap with Abbreviation 。要是忘了快捷键了，就求助命令面板。弹出的输入框中输入后回车就可以看到效果了，语法上跟前面 tab 补齐的时候没有区别。如果要删除一层标签，用 Command + , (Remove Tag)。</p>
<h2 id="快速查找文件或字符串"><a href="#快速查找文件或字符串" class="headerlink" title="快速查找文件或字符串"></a>快速查找文件或字符串</h2><p>Command + P 快捷键打开的功能叫做goto anything，见menu-&gt;Goto。支持模糊匹配，同时支持下面几种操作形式，让定位更准确：</p>
<pre><code>filename:lineno    //定位至具体行号
filename@css-selector    //定位至具体CSS选择器
filename@function    //定位至具体函数
</code></pre>
<p>还可以直接在新打开的文件中定位字符串。</p>
<pre><code>filename#searchtext       
</code></pre>
<p>Command + (Alt) + F **当前文件内查找(替换)**。Enter 查找下一处，Shift-Enter 查找上一处。敲 esc 就可以停在那里进行编辑。</p>
<p>把光标停留在要找的单词上面，然后 Command + D 连续敲多次，就可以找出所有当前文件中的这个单词，而且是直接在多点编辑模式下，可以直接进行替换。</p>
<p>如果要<strong>在一个文件夹内全局查找</strong>，鼠标右击文件夹，Find in Folder 就可以了。打开下一个匹配项用 F4，上一处 Shift+F4。</p>
<p>Ctrl + - 跳回老位置（jump_back），Ctrl + Shift + - 反向操作跳（jump_forword）</p>
<hr>
<p>参考资料：</p>
<p><a href="http://c.haoduoshipin.com/happysublime/">HappySublime</a></p>
<p><a href="http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/">如何优雅地使用Sublime Text</a></p>
<p>牛人总结的Sublime Text的心得经验 <a href="https://github.com/jikeytang/sublime-text">jikeytang/sublime-text · GitHub</a>        </p>
]]></content>
      <categories>
        <category>程序猿的好伙伴</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Sublime Text</tag>
        <tag>编辑器</tag>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>用 hexo+github 搭建这个博客的一点经验</title>
    <url>/blog/hexo-begin/</url>
    <content><![CDATA[<p>博客基本算是搭好了。当然，还有很多地方可以改进，比如加上包括评论（主要是多说不知道为什么一申请就告诉我出错）在内的第三方服务，比如样式还可以再漂亮一些，而且也没有申请自己的域名（毕竟也没什么人看吧…大概）。但是一个博客，内容的质量应该是最重要的。从现在开始，先写点东西吧，比如，先谈谈搭建这个博客时遇到的一些问题以及解决的方案。注意，我是用 mac 搭建的，以下很多内容可能只适用于 OS X 系统。</p>
<p>这个博客后期做的样式等修改也会在这篇博文中进行实时更新记录。</p>
  <span id="more"></span>
<h3 id="初始搭建"><a href="#初始搭建" class="headerlink" title="初始搭建"></a>初始搭建</h3><p>前期准备：安装 XCode、Node.js，注册 Github。除开Node.js外都是已有的，也没遇到什么问题。</p>
<p>hexo 的安装推荐查看<a href="https://hexo.io/zh-cn/docs/index.html">hexo的官方文档</a>，说的很详细。看网上七七八八的教程反而可能遇到一些莫名其妙的问题。整个搭建过程中花费时间最多的就是在解决 DTrace 错误上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Error: Cannot find module &#x27;./build/Release/DTraceProviderBindings&#x27;] code: &#x27;MODULE_NOT_FOUND&#x27; </span><br></pre></td></tr></table></figure>

<p>按照百度的解决方法折腾半天（是真的半天！）也不奏效，最后的解决方案还是按照文档从安装hexo开始重新走了一遍，再使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo --no-optional</span><br></pre></td></tr></table></figure>
<p>  这才解决。果然官方文档才是坠吼的！</p>
<p>  然后就是主题选择了。根据知乎上<a href="http://www.zhihu.com/question/24422335">有哪些好看的 Hexo 主题？－知乎</a>问题的回答，果断选择github上star最多的NexT主题，<a href="http://theme-next.iissnan.com/getting-started.html">官方文档</a>也同样详细易懂。Muse 实在太丑，开始时我选用的 Scheme 是 Mist。后来百度看到好多大佬选用 Pisces，感觉要比 Mist 好看一些，于是换了。其实就是改改配置文件，很简单。之后加入不蒜子统计，设置 RSS（其实我并不清楚这个是干什么的…就是橙色的图标蛮好看的），加上标签、分类、关于页面、搜索功能和侧边栏社交链接。这些在官方文档写的都很清楚。</p>
<p>我还改了一些什么呢？第一，背景颜色。原来NexT的默认背景颜色是浅灰色，不仅沉闷，而且和其他博客的重复率太高。在网上搜到改动方法：hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _schemes -&gt; Pisces（Mist和Muse也行），找到路径下的index.styl文件，改动文件的最上方的那一行代码即可。这个方法应该也可以将背景换成图片，但是每次我用hexo server在本地看是正常的，传到github上就显示不了图片。还没找到解决方法，只好作罢。</p>
<p>17.04.27更新：解决了，现在背景图片为《言叶之庭》中的截图，CSS 代码为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../../../images/back1.jpeg&quot;</span>); <span class="attribute">background-repeat</span>:no-repeat; <span class="attribute">background-attachment</span>:fixed; <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>第二，我对底部 powered by 的 logo 栏进行了更改。其实按理说这个地方作为对 hexo 和 NexT 的开发者的感谢不应该修改的…还是更想个性化一点，抱歉抱歉。修改方法参见 <a href="http://www.jianshu.com/p/4fbc57269f1b">Hexo-Next底部powered by的logo栏更改以及注意事项（附官方文档,文末有福利链）</a>。我把这里当作一个随时修改的心情栏了。（17.04.27：我改回来了）</p>
<p>大概就这些了。希望搭建这个博客能够督促我写下更多编程学习中的经验之谈。但我也没有打算只把这个博客当作一个写技术性文章的地方，随笔、填词什么的也会放在这里。欢迎大家多多来看，相互交流 :)</p>
<h3 id="后期更新"><a href="#后期更新" class="headerlink" title="后期更新"></a>后期更新</h3><p>  16.12.31更新：加上了鼠标点击出爱心的特效。详见 <a href="http://longhaoteng.com/2016/08/01/hexo%E5%BC%95%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89js%E6%96%87%E4%BB%B6%E5%92%8Ccss%E6%A0%B7%E5%BC%8F/">hexo引用自定义js文件和css样式</a>。这个blog还有粒子特效的背景，说不定哪天也给自己加上。</p>
<p>  17.02.20更新：申请了现在的域名，域名解析详见 <a href="http://www.cnblogs.com/penglei-it/p/hexo_domain_name.html">Hexo站点之域名配置【2】</a>。</p>
<p>  17.02.21更新：增加多说评论并修改样式，详见 <a href="http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/">动动手指，给你的Hexo站点添加最近访客（多说篇）</a>。（17.04.08更新：多说归西）</p>
<p>  17.02.26更新：NexT主题支持自行设定CDN以加速静态资源的加载，详见 <a href="http://theme-next.iissnan.com/advanced-settings.html">进阶设定 - NexT 使用文档</a>。但是经过测试，感觉修改CDN后并没有实现预期的加速（也有可能是我没找到比较好的CDN）。所以现在暂时还是保持没有修改的状态。</p>
  <!--17.03.14更新：增加复制文本自带版权信息，详见[版权狗退散 — 仿知乎复制文本自带版权声明](https://www.anotherhome.net/2298)。-->
<p>  17.04.27更新：NexT 主题更新至 5.1.1 版本，更换背景图片（好看多了w）。</p>
<p>  17.12.20更新：感觉字体不好看，修改了 /themes/next/source/css/_variables 文件。</p>
<p>  18.04.12更新：Next 升级到 v6.1.0。加上评论区。</p>
]]></content>
      <categories>
        <category>程序猿喜欢折腾</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>在把玩中学习——typewriter.js</title>
    <url>/blog/typewriter-js/</url>
    <content><![CDATA[<p>大约两周前我在空间里发了一条说说，说感觉自己的创造力日渐枯竭。很多同学不以为然，实际上我是真的有这样的认知。我感觉自己在失去对代码之美的感知，而这种创造力的枯竭也一定程度影响着我的动手能力。我在看书、看视频，却不太愿意去写百度前端训练营里一些基础的代码（而且并不大会）。我安慰自己，我正在修炼内力，一旦出关便是绝世神功威震武林。然而事实是金庸小说中光有内力而不懂一点外家功夫的货，都只有乖乖挨揍的份，至于之后能否成功报仇又是两说。就像我昨天想写一个很简单的动画效果，却最终一筹莫展，只能暂时放弃。</p>
<p>好吧，让我把自己从枯燥的读书笔记中暂时解放出来吧。正好有一个有趣的小 demo，从我还没有打算系统学习前端开发时就躺在收藏夹里了。不妨把玩一下，看看别人能凭借着兴趣写出怎样有意思的小东西。</p>
<img src="https://raw.githubusercontent.com/bighuang624/blog/master/images/typewriter.jpg" />

<span id="more"></span>

<p>这个有打字和仿光标闪烁效果的 <a href="http://www.jq22.com/jquery-info6035">typewriter.js</a> 好像是我在看什么“程序员表白利器”时加到收藏夹里的。现在学习了 js，敢看看源码了，发现 js 代码只有20行不到。作者说：“原生JavaScript就是这么牛。”确实是这样的。虽然效果也很简单，但也能从里面学到一些东西。</p>
<p>HTML 源代码（大致结构）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mainDiv&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;code&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span>/**<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;space&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span>* We are both XXX Unversity  business administration and programmers,<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;space&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;comments&quot;</span>&gt;</span>* so I write some code to show my love to you.<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.getElementById(<span class="string">&quot;code&quot;</span>).typewriter();</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 源代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Element.prototype.typewriter=<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> d = <span class="built_in">this</span>,</span><br><span class="line">				c = d.innerHTML,</span><br><span class="line">				b = <span class="number">0</span>;</span><br><span class="line">			d.innerHTML=<span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">var</span> e = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">				<span class="keyword">var</span> f = c.substr(b, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span> (f == <span class="string">&quot;&lt;&quot;</span>) &#123;</span><br><span class="line">					b = c.indexOf(<span class="string">&quot;&gt;&quot;</span>, b) + <span class="number">1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					b++</span><br><span class="line">				&#125;</span><br><span class="line">				d.innerHTML=c.substring(<span class="number">0</span>, b) + (b &amp; <span class="number">1</span> ? <span class="string">&quot;_&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (b &gt;= c.length) &#123;</span><br><span class="line">					<span class="built_in">clearInterval</span>(e)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, <span class="number">75</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在这份 js 代码中可以学习的点：</p>
<ol>
<li><strong>原型模式定义方法</strong>：给 Element 添加实例方法<code>typewriter()</code>（在 html 文件中调用），这里有一个参数 a，实际上没什么用。顺便一说，源码在 head 处引入了 js 文件，这是为了先加载 js 文件。如果按照代码规范将引入放在 body 部分的最后，则有一瞬间所有字先出现再消失，不符合效果要求。可见代码规范也要根据实际来遵守。</li>
<li>声明三个变量，d 保存当前对象（”code”）。这个操作是必要的，因为后面要给 “code” 的 innerHTML 赋值的时候有时在函数作用域中，this 取不到 “code”。</li>
<li>代码逻辑很清晰，包括对标签的处理、光标效果的实现和定时器的清除等。要对自己想要实现的效果有一个全面的认知和大致的构思再开始写代码。</li>
<li>末尾<code>return this</code>以<strong>支持链式操作</strong>。</li>
</ol>
<p>想要用功能强大的JavaScript实现一些小效果不难，但是怎样一步步规划、修改到实现对现在的我来说还是比较有挑战性的。希望自己能在欣赏、借鉴、吸收的过程中去实现一些有趣的 demo，重拾对代码的兴趣和创造力。</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScipt</tag>
        <tag>前端</tag>
        <tag>学习笔记</tag>
        <tag>随笔</tag>
        <tag>typewriter.js</tag>
      </tags>
  </entry>
  <entry>
    <title>如何给终端安上炫酷的皮神黄皮肤？</title>
    <url>/blog/pikachu-iterm/</url>
    <content><![CDATA[<p>昨天看 Trending repositories on GitHub today 时，发现了一个不得了的东西：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-17d0934182abb9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pokemon-Terminal，已经有 1200+ star"></p>
<p>给终端安上超炫酷的皮神黄皮肤！<br>作为一个铁杆口袋迷+程序员，还有什么能比这更打动我的心吗？</p>
<p>一天后，在一番说麻烦也不麻烦，说不麻烦又学了很多新东西的折腾后，我成功入手了这款至尊皮神黄皮肤！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-bc1f7d006fb2f0e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="感觉又能元气满满地查 bug 了呢"></p>
<p>如果你也是口袋迷，也想给终端安上这款皮肤（或者在 493 只不同的口袋妖怪皮肤中任选一款），那么你可以看看我对这趟折腾之旅的全过程介绍，或许可以少跳几个坑。</p>
<span id="more"></span>

<h3 id="从零开始的项目安装"><a href="#从零开始的项目安装" class="headerlink" title="从零开始的项目安装"></a>从零开始的项目安装</h3><p>打开 <a href="https://github.com/LazoCoder/Pokemon-Terminal">Pokemon-Terminal 项目的 github 主页</a>，我发现安装前有两个要求：</p>
<ol>
<li>3.5及以上版本的 python；</li>
<li>已安装 iTerm2。</li>
</ol>
<p>巧了，这两个要求我都不符合！</p>
<p>iTerm2 我从来没有接触过，根本不知道是什么。而比较久远的时候，我在试图将 OS X 系统自带的 python 2.+ 升级为 3.+ 时，跟着网上不知道靠不靠谱的教程误操作，以致 2.+ 删掉了 3.+ 却没安好，依赖于 python 的以 Xcode 为首的一系列软件全部罢工（而且过了一周左右才查出来是这个原因），最后灰溜溜地又下了一遍 2.+，从此留下了对 python 的心理阴影（但是我们这篇教程还是很靠谱的）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-cbaa6148775a471f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="吃瘪了"></p>
<p>没关系，作为（准）程序员，要勇于折腾！我们一步一步的搞起。</p>
<h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>我是先下载的 iTerm2，<a href="http://www.iterm2.com/">官网</a>在此，下载即可。</p>
<p>iTerm2 是 OS X 系统下很好用的一款命令行工具，至于具体怎么好用，敬请百度了解。因为我现在只是为了皮神黄皮肤。当然之后我也会进一步学习使用。</p>
<h3 id="python-3-5"><a href="#python-3-5" class="headerlink" title="python 3.5+"></a>python 3.5+</h3><p>昨晚吃瘪后的我心有不甘，发了一条说说。然后幸得初中同学救驾：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-6bbe74dae5518c8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="向蔡老师低头"></p>
<p>这个允许用户方便地安装不同版本的 python 并可以快速切换的 anaconda 帮助我解决了问题。<a href="https://www.continuum.io/downloads/">官网</a>提供了图形化安装和命令行安装两种方式，根据自己的专业程度选择下载即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-7a10e852f127c605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选择 3.6 版本，安装后会自动帮你把 python 版本切换为3.6"></p>
<p>这个 anaconda 据说也是 python 开发的利器之一，不过我也不会 python。也许之后机缘巧合会深入学习（想了解可以参照这篇文章<a href="http://www.jianshu.com/p/2f3be7781451#">Anaconda使用总结</a>）。说实话为了给终端换个皮肤，让我本不宽裕的存储空间又少了 1G 左右，有些心疼。但是折腾还是给了我很多乐趣，也许之后有用呢。</p>
<p>那么要求都满足了。按照项目 README 要求，在 iTerm 2 中输入以下三条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Pokemon Installation</span><br><span class="line">git clone https://github.com/LazoCoder/Pokemon-Terminal $HOME/.Pokemon-Terminal</span><br><span class="line">echo PATH=&quot;$HOME/.Pokemon-Terminal:$&#123;PATH&#125;&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>安装完毕，皮神我来了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pokemon pikachu</span><br></pre></td></tr></table></figure>

<p>然后…出现以下报错提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Pokemon-Terminal/./Scripts/background.scpt:39:46: script error: Expected end of line but found identifier. (-2741)</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2702529-31f620e842cc120a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错了，就很难受"></p>
<h3 id="翻越最后一座-bug-高山"><a href="#翻越最后一座-bug-高山" class="headerlink" title="翻越最后一座 bug 高山"></a>翻越最后一座 bug 高山</h3><p>想去给作者提一个 issue，就发现作者对于这个 bug 已经给出了<a href="https://github.com/LazoCoder/Pokemon-Terminal/issues/15">解决方法</a>。</p>
<p>按照解决方法，我们需要对 .Pokemon-Terminal/scripter.py 文件进行一些修改（当然，不一定每个人都碰上了这个 bug）。其实我也不太会用 vim，所以以下操作参照了这篇文章<a href="http://blog.csdn.net/bruce0532/article/details/7842384">修改文件内容 vi命令</a>。</p>
<p>用以下命令在终端打开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi .Pokemon-Terminal/scripter.py</span><br></pre></td></tr></table></figure>

<p>然后按一下 i，从命令行模式进入插入模式。找到函数<code>__terminal_script</code>（在比较靠上的位置），将：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content = &quot;tell application \&quot;iTerm\&quot;\n&quot;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content = &quot;tell application \&quot;iTerm2\&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>按 Esc 键进入命令行模式，再按<code>:wq</code>保存退出。大功告成！</p>
<p>再在 iTerm2 中输入<code>pokemon pikachu</code>，就会发现黑漆漆（或者白晃晃）的背景变成了皮神黄！</p>
<h3 id="深度使用"><a href="#深度使用" class="headerlink" title="深度使用"></a>深度使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    pokemon [parameter]</span><br><span class="line"></span><br><span class="line">Parameters:</span><br><span class="line">    [name]        -   Change the terminal background to the specified Pokemon.</span><br><span class="line">    [index]       -   Change the terminal background to a Pokemon by its index.</span><br><span class="line">    [region]      -   List all the Pokemon of the specified region.</span><br><span class="line">    [one letter]  -   List all Pokemon who&#x27;s names begin with a particular letter.</span><br><span class="line">    [two letters] -   List all Pokemon who&#x27;s names begin with those two letters.</span><br><span class="line"></span><br><span class="line">Other Parameters:</span><br><span class="line">    pokemon all             -   List all the Pokemon supported.</span><br><span class="line">    pokemon regions         -   List all the available regions.</span><br><span class="line">    pokemon extra           -   List all the Pokemon from the &#x27;Extra&#x27; folder.</span><br><span class="line">    pokemon random          -   Change the terminal background to a random Pokemon.</span><br><span class="line">    pokemon random-kanto    -   Change the terminal background to a random Pokemon from the specified region.</span><br><span class="line">    pokemon ?               -   Identify the current Pokemon in the terminal.</span><br><span class="line">    pokemon _pikachu        -   Change the wallpaper to the specified Pokemon.</span><br><span class="line">    pokemon _random         -   Change the wallpaper to a random Pokemon.</span><br><span class="line">    pokemon _random-kanto   -   Change the wallpaper to a random Pokemon from the specified region.</span><br><span class="line">    pokemon _?              -   Identify the current Pokemon in the wallpaper.</span><br><span class="line">    pokemon slideshow       -   Iterate through each Pokemon.</span><br><span class="line">    pokemon slideshow-kanto -   Iterate through each Pokemon in the specified region.</span><br><span class="line">    pokemon help            -   Display this menu.</span><br></pre></td></tr></table></figure>

<p>以上是作者提供的用法。可以通过口袋妖怪的英文名或者编号切换皮肤，或者用<code>pokemon random</code>来切换成随机的皮肤。</p>
<p>我们现在还得每次打开 iTerm 后输入命令来切换皮肤。作者同样提供了点开就换的方法，只用在 iTerm 的 Preferences 里做一点配置：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-e7b439a27bbb15e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可以去掉; clear以使终端界面不自己下滑来隐藏这条命令"></p>
<p>想一想，通过配置为<code>pokemon random</code>，每次打开都是不同皮肤说不定更爽到。</p>
<p>最后作者建议你改变一下透明度之类的，使皮神看起来更酷炫有范：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-f45392ab4550af00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="作者的配置"></p>
<p>我的配置是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-1d60fdcb28354450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的配置"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-16299e1b9b28d546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="再看一次"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实一个皮肤也没有那么重要（还是有那么一点爽的啦），重要的是通过这一番折腾，接触到了很多常规学习中可能不会接触的东西，包括 iTerm 和 anaconda。这也是我第一次有目的性地去看项目的 issue。希望自己以后能多一点这样地非常规学习。</p>
]]></content>
      <categories>
        <category>程序猿喜欢折腾</category>
      </categories>
      <tags>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据清理 5 天挑战</title>
    <url>/blog/5-days-data-cleaning/</url>
    <content><![CDATA[<p>偶然看到了 Kaggle 的数据清理 5 天挑战，大致看了一下，还是比较实用的。因此全部做完后记录一下。不是很想在无谓的整理上花太多时间，因此各类标题直接使用原文中的英文标题，用于串联内容的文字较少，且代码不一定完整（主要是缺少导入包和数据的语句）。如果你希望能够全面地了解这 5 次挑战的内容，以下是 Kaggle 上原 kernel 的地址：</p>
<ul>
<li>Day 1: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-handling-missing-values">Data Cleaning Challenge: Handling missing values | Kaggle</a></li>
<li>Day 2: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data">Data Cleaning Challenge: Scale and Normalize Data | Kaggle</a></li>
<li>Day 3: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/">Data Cleaning Challenge: Parsing Dates | Kaggle</a></li>
<li>Day 4: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-character-encodings/">Data Cleaning Challenge: Character Encodings | Kaggle</a></li>
<li>Day 5: <a href="https://www.kaggle.com/rtatman/data-cleaning-challenge-inconsistent-data-entry">Data Cleaning Challenge: Inconsistent Data Entry | Kaggle</a></li>
</ul>
<span id="more"></span>

<h2 id="Handling-missing-values"><a href="#Handling-missing-values" class="headerlink" title="Handling missing values"></a>Handling missing values</h2><h3 id="Take-a-first-look-at-the-data"><a href="#Take-a-first-look-at-the-data" class="headerlink" title="Take a first look at the data"></a>Take a first look at the data</h3><p>看一下数据的前几行有没有缺失值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">nfl_data.sample(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 使用 nfl_data.head() 效果相同</span></span><br></pre></td></tr></table></figure>

<h4 id="See-how-many-missing-data-points-we-have"><a href="#See-how-many-missing-data-points-we-have" class="headerlink" title="See how many missing data points we have"></a>See how many missing data points we have</h4><p>统计每种属性包含的缺失值的数量：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get the number of missing data points per column</span></span><br><span class="line">missing_values_count = nfl_data.isnull().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># look at the # of missing points in the first ten columns</span></span><br><span class="line">missing_values_count[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>看一看缺失值占总体数量的百分比：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># how many total missing values do we have?</span></span><br><span class="line">total_cells = np.product(nfl_data.shape)</span><br><span class="line">total_missing = missing_values_count.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># percent of data that is missing</span></span><br><span class="line">(total_missing/total_cells) * <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h4 id="Figure-out-why-the-data-is-missing"><a href="#Figure-out-why-the-data-is-missing" class="headerlink" title="Figure out why the data is missing"></a>Figure out why the data is missing</h4><p>分析数据缺失的原因以及缺失对数据分析所造成的影响被称为<strong>“data intution”</strong>，决定了是否需要填充该缺失，以及填充的策略。</p>
<p>面对数据缺失，一个必须要考虑的问题是：</p>
<blockquote>
<p>某个数据的缺失是因为它没有被记录还是根本不存在？</p>
</blockquote>
<p>对于根本不存在的缺失数据，没有必要对其进行操作；而没有被记录的缺失值，则应该基于同行同列的其他值来猜想其可能的值，尝试进行填充。</p>
<p>例如，<code>Street Number Suffix</code>应该是其本身不存在，而<code>Zipcode</code>则应该是没有记录。</p>
<h3 id="Drop-missing-values"><a href="#Drop-missing-values" class="headerlink" title="Drop missing values"></a>Drop missing values</h3><p>移除包含缺失值的<strong>行</strong>是可行的，但是如果缺失值较多且分布较散，可能导致所有的数据全部被移除：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">nfl_data.dropna()</span><br></pre></td></tr></table></figure>

<p>也可以移除包含至少一个缺失值的<strong>列</strong>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">columns_with_na_dropped = nfl_data.dropna(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Filling-in-missing-values-automatically"><a href="#Filling-in-missing-values-automatically" class="headerlink" title="Filling in missing values automatically"></a>Filling in missing values automatically</h3><p>将某个数值型属性的缺失值全部补 0：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get a small subset of the NFL dataset</span></span><br><span class="line">subset_nfl_data = nfl_data.loc[:, <span class="string">&#x27;EPA&#x27;</span>:<span class="string">&#x27;Season&#x27;</span>].head()</span><br><span class="line">subset_nfl_data</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># replace all NA&#x27;s with 0</span></span><br><span class="line">subset_nfl_data.fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>若存在字符串类型的数据，也可以通过<code>method = &#39;bfill&#39;</code>，选择将空值置为与它相邻的下一行对应的数据，没有下一行数据就置为 0：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># replace all NA&#x27;s the value that comes directly after it in the same column, </span></span><br><span class="line"><span class="comment"># then replace all the reamining na&#x27;s with 0</span></span><br><span class="line">subset_nfl_data.fillna(method = <span class="string">&#x27;bfill&#x27;</span>, axis=<span class="number">0</span>).fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Scale-and-Normalize-Data"><a href="#Scale-and-Normalize-Data" class="headerlink" title="Scale and Normalize Data"></a>Scale and Normalize Data</h2><p>主要搞清两个概念：</p>
<ul>
<li>scaling（缩放）: change the <strong>range</strong> of data</li>
<li>normalize（标准化）: change the <strong>shape of the distribution</strong> of data，即将数据尽可能地描述为正态分布。常用于 t-tests, ANOVAs, linear regression, linear discriminant analysis (LDA) and Gaussian naive Bayes</li>
</ul>
<h3 id="import-packages"><a href="#import-packages" class="headerlink" title="import packages"></a>import packages</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for Box-Cox Transformation</span></span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># for min_max scaling</span></span><br><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> minmax_scaling</span><br><span class="line"></span><br><span class="line"><span class="comment"># plotting modules</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># select the usd_goal_real column</span></span><br><span class="line">usd_goal = kickstarters_2017.usd_goal_real</span><br><span class="line"></span><br><span class="line"><span class="comment"># scale the goals from 0 to 1</span></span><br><span class="line">scaled_data = minmax_scaling(usd_goal, columns = [<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the original &amp; scaled data together to compare</span></span><br><span class="line">fig, ax=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(kickstarters_2017.usd_goal_real, ax=ax[<span class="number">0</span>])</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&quot;Original Data&quot;</span>)</span><br><span class="line">sns.distplot(scaled_data, ax=ax[<span class="number">1</span>])</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">&quot;Scaled data&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/18595460/38077516-c4b4a1c0-336b-11e8-9f14-8cdbf6ec6919.png" alt="scale"></p>
<h3 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h3><p>使用 Box-Cox 转换法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get the index of all positive pledges (Box-Cox only takes postive values)</span></span><br><span class="line">index_of_positive_pledges = kickstarters_2017.usd_pledged_real &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get only positive pledges (using their indexes)</span></span><br><span class="line">positive_pledges = kickstarters_2017.usd_pledged_real.loc[index_of_positive_pledges]</span><br><span class="line"></span><br><span class="line"><span class="comment"># normalize the pledges (w/ Box-Cox)</span></span><br><span class="line">normalized_pledges = stats.boxcox(positive_pledges)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot both together to compare</span></span><br><span class="line">fig, ax=plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sns.distplot(positive_pledges, ax=ax[<span class="number">0</span>])</span><br><span class="line">ax[<span class="number">0</span>].set_title(<span class="string">&quot;Original Data&quot;</span>)</span><br><span class="line">sns.distplot(normalized_pledges, ax=ax[<span class="number">1</span>])</span><br><span class="line">ax[<span class="number">1</span>].set_title(<span class="string">&quot;Normalized data&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/18595460/38077612-1e69eb80-336c-11e8-8783-7cd178cfecef.png" alt="normalize"></p>
<h2 id="Parsing-Dates"><a href="#Parsing-Dates" class="headerlink" title="Parsing Dates"></a>Parsing Dates</h2><h3 id="Get-our-environment-set-up"><a href="#Get-our-environment-set-up" class="headerlink" title="Get our environment set up"></a>Get our environment set up</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure>

<h3 id="Check-the-data-type-of-our-date-column"><a href="#Check-the-data-type-of-our-date-column" class="headerlink" title="Check the data type of our date column"></a>Check the data type of our date column</h3><p>pandas 用<code>object</code>表示各类数据类型，一般含有字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">landslides[<span class="string">&#x27;date&#x27;</span>].dtype</span><br><span class="line"><span class="comment"># dtype(&#x27;O&#x27;)</span></span><br><span class="line"><span class="comment"># &#x27;O&#x27; 表示 &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="Convert-our-date-columns-to-datetime"><a href="#Convert-our-date-columns-to-datetime" class="headerlink" title="Convert our date columns to datetime"></a>Convert our date columns to datetime</h3><p>将字符串转化为 datetime 时，要注明原字符串在表示日期时所遵循的格式，例如：</p>
<ul>
<li>1/17/07 has the format “%m/%d/%y”</li>
<li>17-1-2007 has the format “%d-%m-%Y”</li>
</ul>
<p>可以看到，<code>%y</code>代表 2 个数字表示的年份，<code>%Y</code>代表 4 个数字表示的年份。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">landslides[<span class="string">&#x27;date_parsed&#x27;</span>] = pd.to_datetime(landslides[<span class="string">&#x27;date&#x27;</span>], <span class="built_in">format</span> = <span class="string">&quot;%m/%d/%y&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>补充：由于数据中还有个别不是 “month/day/four-digit year” 格式，直接转换的话会报错，Pandas 提供了一个可选的参数 errors，传入 errors=’coerce’，当遇到不能转换的数据就会将其置为 NaN，我们之后再对其进行手工处理。但如果我们不设定 format，这个错误就会被忽略，不过就无法得到特定格式的日期数据了，可能影响之后分析工作。详见<a href="https://zhuanlan.zhihu.com/p/35058099">Kaggle 数据清洗挑战 Day 3 - 快速解析日期（date）数据</a></p>
<h3 id="Select-just-the-day-of-the-month-from-our-column"><a href="#Select-just-the-day-of-the-month-from-our-column" class="headerlink" title="Select just the day of the month from our column"></a>Select just the day of the month from our column</h3><p>在处理后的数据中按 month 选取 day：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">day_of_month_landslides = landslides[<span class="string">&#x27;date_parsed&#x27;</span>].dt.day</span><br></pre></td></tr></table></figure>

<h3 id="Plot-the-day-of-the-month-to-check-the-date-parsing"><a href="#Plot-the-day-of-the-month-to-check-the-date-parsing" class="headerlink" title="Plot the day of the month to check the date parsing"></a>Plot the day of the month to check the date parsing</h3><p>可视化，用于确认没有搞混“月“和”日“：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remove na&#x27;s</span></span><br><span class="line">day_of_month_landslides = day_of_month_landslides.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the day of the month</span></span><br><span class="line">sns.distplot(day_of_month_landslides, kde=<span class="literal">False</span>, bins=<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><a href="https://www.kaggle.com/residentmario/time-series-plotting-optional">时间序列可视化</a></p>
<h2 id="Character-Encodings"><a href="#Character-Encodings" class="headerlink" title="Character Encodings"></a>Character Encodings</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># helpful character encoding module</span></span><br><span class="line"><span class="keyword">import</span> chardet</span><br></pre></td></tr></table></figure>

<h3 id="What-are-encodings"><a href="#What-are-encodings" class="headerlink" title="What are encodings?"></a>What are encodings?</h3><p>UTF-8 天下第一！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start with a string</span></span><br><span class="line">before = <span class="string">&quot;This is the euro symbol: €&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># check to see what datatype it is</span></span><br><span class="line"><span class="built_in">type</span>(before)</span><br><span class="line"><span class="comment">#str</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">after = before.encode(<span class="string">&quot;utf-8&quot;</span>, errors = <span class="string">&quot;replace&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check the type</span></span><br><span class="line"><span class="built_in">type</span>(after)</span><br><span class="line"><span class="comment"># bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># take a look at what the bytes look like</span></span><br><span class="line">after</span><br><span class="line"><span class="comment"># b&#x27;This is the euro symbol: \xe2\x82\xac&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># convert it back to utf-8</span></span><br><span class="line"><span class="built_in">print</span>(after.decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># This is the euro symbol: €</span></span><br></pre></td></tr></table></figure>

<h3 id="Reading-in-files-with-encoding-problems"><a href="#Reading-in-files-with-encoding-problems" class="headerlink" title="Reading in files with encoding problems"></a>Reading in files with encoding problems</h3><p>读取非 UTF-8 编码的文件会出错。先试着读取前几行看一下能不能判断编码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># look at the first ten thousand bytes to guess the character encoding</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;../input/kickstarter-projects/ks-projects-201801.csv&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> rawdata:</span><br><span class="line">    result = chardet.detect(rawdata.read(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># check what the character encoding might be</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>判断为 Windows-1252 编码。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># read in the file with the encoding detected by chardet</span></span><br><span class="line">kickstarter_2016 = pd.read_csv(<span class="string">&quot;../input/kickstarter-projects/ks-projects-201612.csv&quot;</span>, encoding=<span class="string">&#x27;Windows-1252&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># look at the first few lines</span></span><br><span class="line">kickstarter_2016.head()</span><br></pre></td></tr></table></figure>

<h3 id="Saving-your-files-with-UTF-8-encoding"><a href="#Saving-your-files-with-UTF-8-encoding" class="headerlink" title="Saving your files with UTF-8 encoding"></a>Saving your files with UTF-8 encoding</h3><p>默认以 UTF-8 编码保存。</p>
<h2 id="Inconsistent-Data-Entry"><a href="#Inconsistent-Data-Entry" class="headerlink" title="Inconsistent Data Entry"></a>Inconsistent Data Entry</h2><p>将包括加了空格、大小写不一致、个别拼写错误等类型的不同值整理为一致。</p>
<h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fuzzywuzzy</span><br><span class="line"><span class="keyword">from</span> fuzzywuzzy <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">import</span> chardet</span><br></pre></td></tr></table></figure>

<h3 id="Do-some-preliminary-text-pre-processing"><a href="#Do-some-preliminary-text-pre-processing" class="headerlink" title="Do some preliminary text pre-processing"></a>Do some preliminary text pre-processing</h3><p>看一看有哪些值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get all the unique values in the &#x27;City&#x27; column</span></span><br><span class="line">cities = suicide_attacks[<span class="string">&#x27;City&#x27;</span>].unique()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort them alphabetically and then take a closer look</span></span><br><span class="line">cities.sort()</span><br><span class="line">cities</span><br></pre></td></tr></table></figure>

<p>去空格、全部调小写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># convert to lower case</span></span><br><span class="line">suicide_attacks[<span class="string">&#x27;City&#x27;</span>] = suicide_attacks[<span class="string">&#x27;City&#x27;</span>].<span class="built_in">str</span>.lower()</span><br><span class="line"><span class="comment"># remove trailing white spaces</span></span><br><span class="line">suicide_attacks[<span class="string">&#x27;City&#x27;</span>] = suicide_attacks[<span class="string">&#x27;City&#x27;</span>].<span class="built_in">str</span>.strip()</span><br></pre></td></tr></table></figure>

<h3 id="Use-fuzzy-matching-to-correct-inconsistent-data-entry"><a href="#Use-fuzzy-matching-to-correct-inconsistent-data-entry" class="headerlink" title="Use fuzzy matching to correct inconsistent data entry"></a>Use fuzzy matching to correct inconsistent data entry</h3><p><code>fuzzywuzzy</code>包可以帮助辨认那些拼写接近的字符串。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get the top 10 closest matches to &quot;d.i khan&quot;</span></span><br><span class="line">matches = fuzzywuzzy.process.extract(<span class="string">&quot;d.i khan&quot;</span>, cities, limit=<span class="number">10</span>, scorer=fuzzywuzzy.fuzz.token_sort_ratio)</span><br><span class="line"></span><br><span class="line"><span class="comment"># take a look at them</span></span><br><span class="line">matches</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[(&#x27;d. i khan&#x27;, 100),</span></span><br><span class="line"><span class="string"> (&#x27;d.i khan&#x27;, 100),</span></span><br><span class="line"><span class="string"> (&#x27;d.g khan&#x27;, 88),</span></span><br><span class="line"><span class="string"> (&#x27;khanewal&#x27;, 50),</span></span><br><span class="line"><span class="string"> (&#x27;sudhanoti&#x27;, 47),</span></span><br><span class="line"><span class="string"> (&#x27;hangu&#x27;, 46),</span></span><br><span class="line"><span class="string"> (&#x27;kohat&#x27;, 46),</span></span><br><span class="line"><span class="string"> (&#x27;dara adam khel&#x27;, 45),</span></span><br><span class="line"><span class="string"> (&#x27;chaman&#x27;, 43),</span></span><br><span class="line"><span class="string"> (&#x27;mardan&#x27;, 43)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以考虑写一个函数做总体的转化：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function to replace rows in the provided column of the provided dataframe</span></span><br><span class="line"><span class="comment"># that match the provided string above the provided ratio with the provided string</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_matches_in_column</span>(<span class="params">df, column, string_to_match, min_ratio = <span class="number">90</span></span>):</span></span><br><span class="line">    <span class="comment"># get a list of unique strings</span></span><br><span class="line">    strings = df[column].unique()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get the top 10 closest matches to our input string</span></span><br><span class="line">    matches = fuzzywuzzy.process.extract(string_to_match, strings, </span><br><span class="line">                                         limit=<span class="number">10</span>, scorer=fuzzywuzzy.fuzz.token_sort_ratio)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># only get matches with a ratio &gt; 90</span></span><br><span class="line">    close_matches = [matches[<span class="number">0</span>] <span class="keyword">for</span> matches <span class="keyword">in</span> matches <span class="keyword">if</span> matches[<span class="number">1</span>] &gt;= min_ratio]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get the rows of all the close matches in our dataframe</span></span><br><span class="line">    rows_with_matches = df[column].isin(close_matches)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># replace all rows with close matches with the input matches </span></span><br><span class="line">    df.loc[rows_with_matches, column] = string_to_match</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># let us know the function&#x27;s done</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;All done!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>之后只需要对那些疑似相同的字符串逐个调用该函数即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use the function we just wrote to replace close matches to &quot;d.i khan&quot; with &quot;d.i khan&quot;</span></span><br><span class="line">replace_matches_in_column(df=suicide_attacks, column=<span class="string">&#x27;City&#x27;</span>, string_to_match=<span class="string">&quot;d.i khan&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据科学笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据科学</tag>
        <tag>数据清理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据预处理及常用处理方法</title>
    <url>/blog/intro-to-data-preprocessing/</url>
    <content><![CDATA[<p>作为互联网上最著名的数据科学竞赛平台之一，Kaggle 无疑是数据从业者和爱好者最喜欢的社区之一。最近，Kaggle 发布了 <a href="https://www.kaggle.com/amberthomas/kaggle-2017-survey-results">2017 用户调查报告</a>，共有 16000 余名用户参与的这份调查可以让我们对数据工作者的各类信息有一个了解。</p>
<p>其中，对于“工作中遇到的障碍主要是什么？”这个问题，有 49.4% 的被调查者选择了“脏数据（dirty data）”这一项，占该问题所有选项的第一位。也就是说，数据科学家一般最常见的困扰就是要对手头的数据进行大量的预处理工程。</p>
<p>在业界有一句广泛流传的话：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。从这句话可以看出，数据的好坏对于机器学习模型的最终效果有着极大的影响。</p>
<p>然而，现实世界中数据大体上都是不完整、不一致、含噪声的脏数据，无法直接使用，或结果差强人意。为了提高数据的质量，数据预处理技术应运而生。实际上，在一个基于机器学习模型的实际应用中，对于数据的预处理工作所需的时间和精力可能远大于模型和算法的选择和应用。</p>
<span id="more"></span>

<h2 id="数据预处理的概念"><a href="#数据预处理的概念" class="headerlink" title="数据预处理的概念"></a>数据预处理的概念</h2><p><strong>数据预处理</strong>是指对所收集数据进行分类或分组前所做的审核、筛选、排序、变换、规约、汇总等必要的处理。</p>
<h2 id="数据预处理针对的问题"><a href="#数据预处理针对的问题" class="headerlink" title="数据预处理针对的问题"></a>数据预处理针对的问题</h2><p>通过数据获取，我们能够得到未经处理的数据，这时的数据可能存在一些问题。在解决这些问题后，我们才能选择和提取合适的特征进行模型的训练。</p>
<p>这里简述了一部分问题及其解决方法，还有一些问题的解决方案会在下节展开讨论：</p>
<ul>
<li><p>不属于同一量纲：特征的规格不同，不能放在一起比较。后文提到的无量纲化可以解决这一问题。</p>
</li>
<li><p>信息不规整：由于数据收集或存储时的错误、技术问题或漏洞，以及软硬件故障等因素，可能存在一些不规整数据。这些不规整的数据需要被过滤掉。</p>
</li>
<li><p>数据点缺失：缺失或不规整的数据需要根据其他数据进行填充，方法包括用零值、全局期望或中值，或是根据相邻或类似的数据点来做插值等。需要根据数据、应用场景和个人经验来选择正确的方式。</p>
</li>
<li><p>异常值问题：异常值的主要问题在于即使它们是极值也不一定就是错的，对错非常难以分辨。异常值可被移除或是填充，但鲁棒回归等统计技术可用于处理异常值或是极值。另外，利用如对数或高斯核对异常值进行转换也有利于降低值跳跃的影响。</p>
</li>
<li><p>数据类型不合要求：对于某些类型的特征，我们可能希望将其转换为另一类型进行使用。比如，我们可以将考试分数这个数值特征转换为是否及格这个二元特征，这个可以通过二值化（设定一个阀值）实现。其他的转换也可以通过自己定义的函数实现。</p>
</li>
<li><p>数据不能直接使用：对于例如文本特征、类别特征等特定类别的特征，机器学习算法和模型不能直接使用，那么需要对其做一些转化。对于文本特征，可以使用词袋（bag-of-word）表示法；而对于类别特征，可以使用 One-hot 编码进行处理。这些方法的核心都是编码，会在下一节再出现。</p>
</li>
</ul>
<h2 id="数据预处理的常用方法"><a href="#数据预处理的常用方法" class="headerlink" title="数据预处理的常用方法"></a>数据预处理的常用方法</h2><p>除开过滤、填充等方法之外，下列方法在实际问题的数据预处理中也比较常用。</p>
<h3 id="无量纲化"><a href="#无量纲化" class="headerlink" title="无量纲化"></a>无量纲化</h3><p><strong>无量纲化</strong>使不同规格的数据转换到同一规格。常见的无量纲化方法有<strong>标准化</strong>和<strong>归一化</strong>。</p>
<p>标准化的前提是特征值服从正态分布，标准化后，其转换成标准正态分布。</p>
<p>归一化利用了边界值信息，将特征的取值区间缩放到某个特点的范围，例如[0, 1]等。</p>
<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>标准化也叫 <strong>z-score</strong> 规范化（零均值规范化）。公式如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1b64f8328595283.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标准化.png"></p>
<p>其中 μ 是样本数据的<strong>均值（mean）</strong>， σ 是样本数据的<strong>标准差（std）</strong>。</p>
<p>通过标准化，样本数据被变为一个均值为 0，方差为 1 的分布。对于梯度下降，标准化可以达到<strong>加速收敛</strong>的效果，且不改变原始数据的几何分布。</p>
<h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p><strong>归一化</strong>一般是将数据按比例缩放到指定的范围，用于<strong>去除不同维度数据的量纲以及量纲单位</strong>。</p>
<p>最常见的归一化方法就是 <strong>Min-Max</strong> 归一化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-8a1730b90c9336f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归一化.png"></p>
<p>经过归一化处理过后的数据，各个特征维度对目标函数的影响权重是一致的，不会发生某一特征因维度过高而起主导作用，从而遮盖住其他特征的问题。</p>
<p>有一点值得注意的是，在归一化测试数据时，<strong>测试集和训练集应该使用相同的归一化方法</strong>。即保存从训练集上取得的归一化参数，使用同样的公式和保存的参数来归一化测试集。这是因为我们需要保持测试集和训练集的分布一致。</p>
<p>另外，归一化和标准化的英文都为 Normalization，需要<strong>根据其用途（或公式）的不同去理解或翻译</strong>。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p><strong>编码</strong>将无法作为输入的原始类别特征或文本特征表示为数字形式。其思想为用一个变量的字典来实现变量到索引序号的映射。</p>
<p>编码的方式也有很多，下面介绍两个常用的编码方式－One-hot 编码和哑编码。</p>
<h4 id="One-hot-编码"><a href="#One-hot-编码" class="headerlink" title="One-hot 编码"></a>One-hot 编码</h4><p>假设变量可取的值有 k 个，如果对这些值用 1 到 k 编序，则可以用长度为 k 的二元向量来表示一个变量的取值。在这个向量里，该取值对应的序号所在的元素为 1，其他元素都为 0。</p>
<h4 id="哑编码"><a href="#哑编码" class="headerlink" title="哑编码"></a>哑编码</h4><p><strong>哑编码</strong>是一种状态编码，前文提到的词袋表示法用的是这种编码方式。将这些文本特征转化为数字时，数字与数字之间是没有大小关系的，纯粹只是分类标记，这时候就需要用哑编码对其进行编码。比如 0 用 0001，1 用 0010，2 用 0100 以此类推。有点类似文本矩阵，最终会构成一个<strong>稀疏矩阵</strong>。一份文本数据中各种词可能达数百万，因此使用稀疏矩阵表示能够节省内存和磁盘空间，以及计算时间。</p>
<h5 id="补充：稀疏矩阵"><a href="#补充：稀疏矩阵" class="headerlink" title="补充：稀疏矩阵"></a>补充：稀疏矩阵</h5><p>在矩阵中，若数值为 0 的元素数目远远多于非 0 元素的数目，并且非 0 元素分布没有规律时，则称该矩阵为<strong>稀疏矩阵</strong>；与之相反，若非 0 元素数目占大多数时，则称该矩阵为<strong>稠密矩阵</strong>。定义非零元素的总数比上矩阵所有元素的总数为<strong>矩阵的稠密度</strong>。</p>
<p>稀疏矩阵算法的最大特点是通过只存储和处理非零元素从而大幅度降低存储空间需求以及计算复杂度，代价则是必须使用专门的稀疏矩阵压缩存储数据结构。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上介绍的只是一些数据预处理中的常用方法。实际上，还有许多根据不同场合选用的效果更好的处理方法。对于这些暂时没有机会使用的处理方法，限于个人水平和文章篇幅，就不一一详谈了。</p>
<p>在进行完数据预处理后，我们还需要选择和提取有意义的特征，将其作为输入来训练机器学习的算法和模型。之后还有选择模型、调整参数、评估、交叉验证等步骤，之后会继续整理这些方面的学习成果。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/30603579?group_id=908678758198726656">Kaggle发布首份数据科学&amp;机器学习从业者现状调查</a></li>
<li><a href="https://www.zhihu.com/question/29316149/answer/110159647">特征工程到底是什么？ - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29957294">ML 入门：归一化、标准化和正则化</a></li>
<li>《Spark 机器学习》第三章：Spark 上数据的获取、处理与准备</li>
<li><a href="http://blog.csdn.net/big_talent/article/details/53887238">关于特征工程入门中的一些基本知识（整理） - CSDN博客</a></li>
<li><a href="http://blog.csdn.net/pipisorry/article/details/52247379">数据标准化/归一化normalization - 皮皮blog - CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>数据科学笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据科学</tag>
        <tag>数据预处理</tag>
        <tag>特征工程</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统演进简述</title>
    <url>/blog/evolution-of-distributed-systems/</url>
    <content><![CDATA[<p>“网络与分布式计算”课程布置了一个作业，要求写一篇题目为“构建分布式系统技术发展历史”的小论文。我个人以为“历史”二字应该是要我们去了解每项技术诞生的时间点，然而踏破铁鞋无处可觅。最后写成的文章主题，我个人认为比起“历史”来说，“演进过程”可能更为恰当。</p>
<p>事实上我们可能也更为注重演进过程，因为分布式系统的演进过程，就是一代代工程师们对抗随时代和应用自身发展而逐渐升高的访问量的一部血泪史。这个过程是每一个健康发展的网站都要经历的。</p>
<p>这次作业也给了我一个机会，去大致了解网站在发展过程中为了提升性能、简化部署、弹性扩展而做出的种种措施，受益匪浅。因此将文章放到博客上。</p>
<span id="more"></span>

<h2 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h2><p>在应用诞生初始，用户量、数据量规模都比较小。因此应用程序、数据库、文件等所有的资源都部署在同一台服务器上即可。这样的架构既简单实用、便于维护，成本又低，成为了这个时代的主流架构方式。在 2003 年淘宝最初上线的时候，就是以一套当时十分风靡的 LAMP 架构（Linux+Apache+MySQL+PHP）实现并部署的。</p>
<p>单体应用架构的特点就是功能和代码集中、一个发布包部署后运行在一个进程内的应用程序。</p>
<h2 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h2><p>随着应用的发展，用户访问量逐渐增加，单台服务器性能及存储空间不足，因此服务器的压力在访问高峰期会上升到比较高，响应时间逐渐变长。这时，工程师们考虑增加几台服务器，将应用程序、数据库、文件分别部署在独立的资源上。一个大的单体应用被拆分成若干个小的单体应用，这就是垂直应用架构。这种拆分方法内含分治的思想，即将一个大的问题按一定业务规则分成若干个小的问题，逐个解决。</p>
<p>通过采用垂直应用架构，应用服务和数据服务得以分离，并发处理能力和数据存储空间得到了很大改善。</p>
<h2 id="使用缓存改善性能"><a href="#使用缓存改善性能" class="headerlink" title="使用缓存改善性能"></a>使用缓存改善性能</h2><p>将大的单体应用拆分后，对业务有所了解和调查的工程师们发现，系统访问的特点遵循二八定律，即 80% 的业务访问集中在 20% 的数据上。那么，使用缓存技术将这 20% 访问较集中的数据缓存下来，就有助于减少数据库的访问次数，降低数据库的访问压力。同时，引入缓存也有助于降低存储成本，因为缓存+数据库服务器可以承担原本需要多台数据库服务器才能承担的请求量，因此节省了机器成本。</p>
<p>缓存分为本地缓存（Local Cache）和远程分布式缓存（Remote Distributed Cache）。本地缓存访问速度更快，但内存资源以及承载能力有限，存在与应用程序争用内存的情况。因此，分布式缓存在如今的大型网站中得到广泛的使用。</p>
<h2 id="使用应用服务器集群-amp-负载均衡"><a href="#使用应用服务器集群-amp-负载均衡" class="headerlink" title="使用应用服务器集群 &amp; 负载均衡"></a>使用应用服务器集群 &amp; 负载均衡</h2><p>虽然做了这么多工作，但是请求量还是水涨船高。当请求量达到需要排队等待的规模时，即使单台应用服务器性能强大，处理请求速度很快，响应速度也依然会变慢。这时，工程师们就要考虑使用多台服务器所组成的集群，通过向集群中追加资源，提升系统的并发处理能力，解决单台服务器处理能力和存储空间上限的问题。</p>
<p>在数据中心内部，外部请求首先被定向到<strong>负载均衡器</strong>，以主机当前的负载作为函数来在主机之间负载均衡。其作为中继站向外部提供服务，使得服务器的负载压力不再成为整个系统的瓶颈。负载均衡器同时也进行外部 IP 地址和内部适当主机 IP 地址的互相转换，防止客户直接接触主机，从而具有隐藏网络内部结构和防止客户直接与主机交互等安全性益处。</p>
<p>负载均衡的策略包括：</p>
<ul>
<li><p>轮询：每一次来自网络的请求轮流分配给内部中的服务器，从 1 至 N 然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。实现简单，但存在服务器的处理能力不同的情况；</p>
</li>
<li><p>权重：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。考虑了服务器处理能力的不足；</p>
</li>
<li><p>随机均衡：把来自网络的请求随机分配给内部中的多个服务器。</p>
</li>
</ul>
<p>反向代理也是负载均衡的一种方法。反向代理指隐藏了真实的服务端，帮用户把请求转发到真实的服务器那里去。Nginx 就是性能非常好的反向代理服务器，可以用来做负载均衡。它会将请求在读取完整之前缓冲，这样交给后端的就是一个完整的 HTTP 请求，而不是断断续续的传递（互联网上连接速度一般比较慢），以此减少网络 IO 次数，从而提高后端的效率。</p>
<h2 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h2><p>在一系列架构的增强后，用户量增加所带来的系统瓶颈可能转移到数据库上。每次读和写的操作都要经过同一个数据库服务器，在大量用户访问的情况下，资源竞争激烈。数据库的并发量有限，在保证数据库事务的 ACID 特性（原子性、一致性、隔离性和持久性）时难免发生阻塞。</p>
<p>为了保证数据库的高可用性，工程师们将数据库进行读写分离，写操作全部引入主库，读操作引入从库。这种做法极大程度地缓解了数据库锁之间的竞争，提高了并发吞吐量和负载能力。当然，读写分离架构适用的应用中，由于读库需要不断做批量的更新操作，读操作不应要求数据强一致，即对数据的实时性要求并没有那么高。</p>
<h2 id="CDN-加速和反向代理"><a href="#CDN-加速和反向代理" class="headerlink" title="CDN 加速和反向代理"></a>CDN 加速和反向代理</h2><p>鉴于网站的访问速度基于页面包含的内容传输到用户电脑的速度，如果用户到服务器的链路之间有一段比较缓慢的话，整体访问速度会受到很大的影响。因此，让用户从就近的服务器获取网页内容是一个理想的选择。</p>
<p>对于业务加载需要的一些不经常改变的静态数据（一般是 css 和 js 文件），可以考虑将其缓存到 CDN 服务器上，而不是每次都到应用服务器进行获取。CDN（内容分发网络）是运营商提供的服务，服务器部署在机房，可以根据用户访问的链路直接选择最近的 CDN 服务器，将已缓存的静态数据返回，以加快静态数据加载速度。这样可以减少服务器的压力，并解决不同地区访问速度差距较大的问题。</p>
<h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>就在工程师们忙碌的时候，数据量仍然随着业务的发展在悄无声息地增长。数据库读写分离最终也将无法满足业务需求，因此需要将数据库再次拆分。比较常用的数据库拆分手段是<strong>业务垂直分库</strong>，因为不同业务中表和表之间的数据大多没有关联，因此可以将不同的业务数据库部署在不同的物理服务器上。</p>
<p>如果单表数据规模非常庞大，还需要使用分布式数据库来支撑，即对这些表进行水平拆分，将同一个表中的数据拆分到两个甚至多个数据库中。</p>
<h2 id="使用-NoSQL-和搜索引擎"><a href="#使用-NoSQL-和搜索引擎" class="headerlink" title="使用 NoSQL 和搜索引擎"></a>使用 NoSQL 和搜索引擎</h2><p>随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如 NoSQL 和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p>
<h2 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h2><p>为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。</p>
<p>业务拆分包括纵向拆分和横向拆分：</p>
<ul>
<li><p>纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</p>
</li>
<li><p>横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务。横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</p>
</li>
</ul>
<h2 id="其他问题：异步、冗余、自动化"><a href="#其他问题：异步、冗余、自动化" class="headerlink" title="其他问题：异步、冗余、自动化"></a>其他问题：异步、冗余、自动化</h2><p>在漫长的演变过程中，除开以上，分布式系统的构建还有一些值得考虑的问题：</p>
<ul>
<li><p>异步：将一个复杂的业务操作转换为多个阶段操作，每个阶段的操作通过消息队列进行异步处理。可以理解为生产者-消费者模式，好处是加快系统响应速度和消除并发高峰。Node.js 正是因为其为异步而生，才逐渐成为服务端开发的选择之一。</p>
</li>
<li><p>冗余：为抵抗一些不可控因素，如自然灾害（火灾、地震）等因素导致系统不可用，应考虑异地建立容灾中心，实时备份数据。</p>
</li>
<li><p>自动化：自动化包括监控、告警、失效转移恢复、降级等功能，这些功能让系统在无人值守的情况下仍可以正常运行。</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>每个小节看似容易理解，真正想要实现起来都是学问，更别谈考虑每个细节，选择最好的方式。之前看《淘宝技术这十年》，里面谈到淘宝作为中国互联网前几个称得上是超大规模的互联网系统，其发展历程中遇到了很多前人根本没有遇到过的问题。淘宝的一代代工程师们或主动或被动的开始进行一次次技术变革，这才造就了如今双十一每秒巨额的并发量。也因此，大麦、12306 等短时间要接受大量访问的网站时常瘫痪，也情有可原。架构是一门学问，想真正将每个环节都研究透彻，不是简简单单看几篇文章，做一个总结就够了的，需要和业务紧密结合。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/yuxin6866/article/details/53038840">分布式架构的演进，分析的很详细，很到位 - CSDN博客</a></li>
<li><a href="https://blog.csdn.net/world6/article/details/72803089?locationNum=12&fps=1">All-In-One到SOA的分布式架构演进 - CSDN博客</a></li>
<li><a href="https://blog.csdn.net/xinzun/article/details/79412150">分布式系统漫谈【壹】_发展历程 - CSDN博客</a></li>
<li><a href="https://www.zhihu.com/question/60199333">为什么数据库读写分离能提高数据库的性能？ - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>架构笔记</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>分布式架构</tag>
      </tags>
  </entry>
  <entry>
    <title>吴恩达《深度学习》系列课程个人笔记</title>
    <url>/blog/Andrew-Ng-Deep-Learning-notes/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/Andrew-Ng-Deep-Learning-notes.png" alt="Andrew-Ng-Deep-Learning-notes"></p>
<p>早在吴恩达（deeplearning.ai）的《深度学习》系列课程在网易云课堂刚刚发布时，它就已经躺在我的计划列表中了。当时还没有特别坚定说要深入学习这方面的知识，因此搁置了一段时间。这几个月终于下定决心，排除万难，开始对这个系列的课程进行学习。</p>
<p>这个系列的课程给我的感觉是，对 DL 新人，以及像我这样数学不是非常好的学习者非常友好。吴恩达老师真正做到了深入浅出，但又没有抛弃那些重要的细节。在我一边看视频，一边想看看花书对应章节时，发现晦涩到根本看不动。而这个系列的课程作为入门启蒙，是再合适不过的。</p>
<p>另外，这个系列课程的作业全都是精心设计过的，虽然难度不大，但对巩固视频所学知识、帮助理解细节非常有帮助。如果只是听课而不独立完成作业，我认为和没有学过没有什么区别。我也打算过一段时间再重新将这些作业再写一遍。</p>
<p>在学习的同时，像网上很多同学一样，我也记录了自己的笔记，并将其发布在 Github 上。因为在 Github 上，在 md 文件中用 LaTex 写的公式不能正常显示，之前都是用 MacDown 由 md 文件生成 html，虽然公式可以看了，但是不太美观。之后，我恰好发现了 docsify ，一个可以由 md 文件动态生成文档网站的库。于是折腾了一会，将自己的笔记全部用它生成，最终效果如题图所示，非常美观（虽然折腾的途中也踩了几个小坑）。</p>
<p>因为在学习的过程中，我也看了很多网上的笔记。它们对我起到了很大的帮助，因此我也想将我的笔记分享出来，也许能够帮助到其他的同学。两周前在学完前两门课时，我在知乎的专栏发了一篇<a href="https://zhuanlan.zhihu.com/p/32527718">文章</a>（即这篇博文的前身）。到目前为止，知乎的文章收获了 147 个赞，而 Github 上的 repo 得到了 42 个 star。这对我简直是受宠若惊。因此，即使这两周是考试周，我还是抽出时间学完了第三门课，并更新了笔记。一方面，这个系列课程的内容确实非常吸引我，另一方面，也是很多同道中人的认可对我有着很大的鼓励。</p>
<p>第四门课是有关计算机视觉和卷积神经网络的。我们知道近年来深度学习的爆红很大程度上是缘于 2012 年 ImageNet 图像识别比赛中 Hinton 课题组构建的 CNN 网络 AlexNet 有着碾压级的表现，因此我对这门课也是非常期待，希望能够在寒假结束前完成对这门课的学习。</p>
<p>最后，再次将笔记的 Github 的 repo 地址公布如下：</p>
<ul>
<li>笔记：<a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/">吴恩达《深度学习》系列课程笔记</a></li>
<li>Github 仓库（包含写完的作业）：<a href="https://github.com/bighuang624/Andrew-Ng-Deep-Learning-notes">bighuang624/Andrew-Ng-Deep-Learning-notes</a></li>
</ul>
<p>欢迎查阅，欢迎在 Issues 中交流或提出意见，更欢迎 star 一下以兹鼓励！</p>
]]></content>
      <categories>
        <category>深度学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>胶囊网络初探</title>
    <url>/blog/capsule-networks-intro/</url>
    <content><![CDATA[<p>如果你有关注我的 Github，可以看到我和小伙伴们正在做一个<a href="https://github.com/bighuang624/sentiment-analysis-webapp">中文短文本情感分析 web 应用</a>。恰逢 WWW 2018 收录了一篇<a href="https://dl.acm.org/citation.cfm?id=3186015">《Sentiment Analysis by Capsules》</a>，借着这个机会了解一下“神经网络之父” Geoffrey Hinton 大神花费近十年心血的胶囊网络（Capsule Networks）。如果能够用于我们的应用中就更好了，即使因为缺少计算资源等原因而无法实现，了解前沿技术、吸收大牛思想也是极好的。</p>
<p>先简单介绍一下 Capsule。NIPS 2017 发表的<a href="https://arxiv.org/pdf/1710.09829v2.pdf">《Dynamic Routing Between Capsules》</a>[1]使得这一概念开始走红，虽然 Capsule 本用于 CV 领域，不过目前也已经在各领域有了积极的尝试。Capsule 是 Hinton“反 CNN”的一面旗帜，他认为导致深度学习如火如荼的 CNN 其实有着重大的缺陷。我接下来就将介绍这个缺陷、Capsule 如何通过其工作原理避免这个缺陷、Capsule 的结构，以及 Capsule 的训练算法与损失函数等。不过因为篇幅有限，这篇文章暂时不会介绍 CapsNet 的具体架构，这部分可以看一下参考资料列的一些或者直接看原论文。顺便一提，Capsule 和胶囊两个词可能在本文中互有使用，但我实际上想用它们指同一个东西。</p>
<span id="more"></span>

<h2 id="CNN-的缺陷"><a href="#CNN-的缺陷" class="headerlink" title="CNN 的缺陷"></a>CNN 的缺陷</h2><p>如果你了解 CNN（不了解请移至<a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Convolutional_Neural_Networks/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">《卷积神经网络 - 吴恩达《深度学习》系列课程笔记》</a>），你会知道 CNN 依靠卷积层检测图像中的特征。前几层学习一些例如边缘的简单特征，而较深的层组合简单特征形成更为复杂的特征，最后再将复杂特征组合并输出分类预测。</p>
<p>而在层与层之间，前一层的激活与下一层神经元的权重相乘并相加，接着传递到非线性激活函数。这种简单的加权和导致 <strong>CNN 难以察觉平移和旋转（以及类似变化）后图像的一致性</strong>，例如，将一张狗的照片旋转 5 度，训练好的 CNN 可能会认为两张图片都是狗，但是不会认为它们是同一只狗。</p>
<p>CNN 解决这个问题的方法是使用最大池化，对于一定区域内的特征取最大值，以此缓解一定的平移和旋转的影响（平均池化同理）。事实证明，CNN 的效果惊人，以至于“它表现如此优异是一场灾难”。引号内是 Hinton 的原话，因为他认为最大池化损失了很多有价值的信息。最重要的是，CNN 只考虑简单对象的存在，而<strong>没有考虑简单对象和复杂对象之间的空间层级关系</strong>。举个例子，对于 CNN 而言，下面两张图片都是一张脸，因为它们包含相似的部件，尽管我们知道散落的器官不能被称为脸。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702529-5c96a8e0b1fb2b64.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="人脸.jpg"></p>
<p>以上问题导致的结果是，CNN 难以分类和辨识不同视角的同一物体。对于人类，即使你只看过几张自由女神像的照片，也能够轻松辨认不同角度的自由女神像。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702529-252e3955a7502bb9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自由女神.jpg"></p>
<p>但对于 CNN，这个任务就非常困难了，因为它没有内建对三维空间的理解。它只能与以前训练过的照片进行对比，这导致训练 CNN 往往需要百万数量级的图像才能训练出较为精准的效果，并且当遇到角度奇怪的图像时分类正确率可能受到影响。最重要的是，我们知道神经网络本就是为了尽可能还原人脑的功能，但明显人类根本不需要对每个物体都看如此规模的图片才能学会辨认。</p>
<h2 id="Why-Capsule？"><a href="#Why-Capsule？" class="headerlink" title="Why Capsule？"></a>Why Capsule？</h2><p>基于以上分析，尽管目前 CNN 看似效果非常出色，但是它不会是未来。实际上，Hinton 早在 2011 年就提出 Capsule 的结构[2]，但是在当时还没有提出一种算法可以实现并成功学习胶囊网络。而在[1]中，Hinton 提出一种名为<strong>动态路由（Dynamic Routing）</strong>的算法解决了这个问题。</p>
<p>CNN 通过一层层的过滤，将信息一步步由下而上的进行抽象；而 Hinton 认为人类在识别图像时是遵循类似决策树的方式。Capsule 同样遵循这个结构的思路，每个活动的 Capsule 将选择一个上层的 Capsule 作为父节点。</p>
<p>Capsule 更好地建模神经网络中内部知识表示的分层关系，这使得训练它所需的数据量大大降低。关键的一点是，Capsule 背后的直觉非常简单优雅，易于理解。尽管目前训练胶囊网络速度比起已经成熟的深度学习模型来说要慢很多，但是假以时日，也许胶囊网络能够在更多训练集上快速高效训练。</p>
<h2 id="Capsule-的工作原理"><a href="#Capsule-的工作原理" class="headerlink" title="Capsule 的工作原理"></a>Capsule 的工作原理</h2><p>Capsule 的工作原理归纳成一句话就是，<strong>所有胶囊检测中的特征的状态的重要信息，都将以向量的形式（神经元输出的则是标量）被胶囊封装</strong>。</p>
<p>进一步来说，一个胶囊捕捉一个特征。胶囊将特征存在的<strong>概率</strong>作为其<strong>输出向量的长度</strong>进行编码，这与目前的神经元同理。而检测出的特征的<strong>状态</strong>被编码为该向量指向的<strong>方向</strong>（“实例参数”）。因此，当检测出的特征在图像中平移或旋转，向量长度没有改变（因为概率保持不变），但它的方向改变了。</p>
<p>从标量到向量，这是一个让人初次听闻时拍案叫绝、但仔细思考过后又觉得理所当然的改变。这种改变使得平移或旋转导致的“变化”与“不变”被转化为向量的长度与方向，从而自然分离开来，而不是像 CNN 使用最大池化一样将“变化”全部简单粗暴地抹平为“不变”。</p>
<h2 id="Capsule-的运算步骤"><a href="#Capsule-的运算步骤" class="headerlink" title="Capsule 的运算步骤"></a>Capsule 的运算步骤</h2><p><img src="https://upload-images.jianshu.io/upload_images/2702529-b09707696facdfda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="胶囊vs人工神经元.jpg"></p>
<p>上图中左边为胶囊，右边为普通神经元。本质上，普通神经元的运算步骤分为 3 步：</p>
<ol>
<li>输入标量的标量加权；</li>
<li>对加权后的标量求和；</li>
<li>对和进行非线性变换生成新标量。</li>
</ol>
<p>而胶囊则在向量版的基础上有少许改动，共 4 步：</p>
<ol>
<li>输入向量的矩阵乘法；</li>
<li>输入向量的标量加权；</li>
<li>对加权后的向量求和；</li>
<li>对和进行非线性变换生成新向量。</li>
</ol>
<h3 id="输入向量的矩阵乘法"><a href="#输入向量的矩阵乘法" class="headerlink" title="输入向量的矩阵乘法"></a>输入向量的矩阵乘法</h3><p>上层胶囊的输入向量来自下层胶囊。这些向量相乘的权重矩阵 W 编码了低层特征和高层特征之间包括空间关系在内的重要关系。</p>
<p>我在这里有一个疑问：这个 W 怎么得到？如果是通过训练迭代得到，那么用的是什么算法？原 paper 对这点略过不表，有一篇文章说 W 是固定不变的，但是也没有说如何获得。如果有看到这篇文章并有答案的同学，欢迎评论指出或者邮件联系我。</p>
<h3 id="输入向量的标量加权"><a href="#输入向量的标量加权" class="headerlink" title="输入向量的标量加权"></a>输入向量的标量加权</h3><p>在这一步中，我们可能比较关心如何通过学习得到权重矩阵 W’。通常神经网络通过反向传播算法学习，而胶囊则使用<strong>动态路由算法</strong>。我们将在后文详细介绍动态路由算法，这里先简单介绍一下 W’ 中权重 cij 的一些性质：</p>
<ol>
<li>权重均为非负标量；</li>
<li>对每个低层胶囊 i，所有权重 cij 的总和等于 1；</li>
<li>对每个低层胶囊 i，权重的数量等于高层胶囊的数量。</li>
</ol>
<p>这三条性质均在表明，这里的权重表示概率。</p>
<h3 id="对加权后的向量求和"><a href="#对加权后的向量求和" class="headerlink" title="对加权后的向量求和"></a>对加权后的向量求和</h3><p>除开求的是向量的和（而非标量和），这一步与通常的神经网络没有区别。</p>
<h3 id="对和进行非线性变换生成新向量"><a href="#对和进行非线性变换生成新向量" class="headerlink" title="对和进行非线性变换生成新向量"></a>对和进行非线性变换生成新向量</h3><p>Capsule 使用了一个新颖的非线性激活函数——squash 函数。它可以压缩输入向量的长度，而不改变其方向。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702529-bf5baae6af4e1020.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="squash.png"></p>
<p>容易看出，蓝色矩形部分将输入向量缩放至单位长度，而红色矩形部分进行额外的缩放操作。函数图像如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702529-0b21e542874bff2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="suqash-function-graph.png"></p>
<p>总结来说，对于上一个胶囊层输出的所有胶囊向量，通过转换矩阵转换为更高层的胶囊向量，最后通过动态路由算法聚合成一个胶囊向量，最后通过 squash 激活函数输出最后结果。</p>
<h2 id="动态路由（Dynamic-Routing）算法"><a href="#动态路由（Dynamic-Routing）算法" class="headerlink" title="动态路由（Dynamic Routing）算法"></a>动态路由（Dynamic Routing）算法</h2><p>动态路由算法的思想是，低层胶囊将其输出发送给对此表示“同意”的高层胶囊。这种同意表现为<strong>向量的点积</strong>。</p>
<p>贴一张论文中对动态路由算法的伪代码描述：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2702529-b66e0182d94d57c0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="伪代码.jpg"></p>
<p>我们只看几个算法中的关键点：</p>
<ul>
<li>第一行指明算法的输入：l 是低层的层数，\hat u 是低层输出的所有胶囊向量，r 是迭代次数。</li>
<li>第四行使用 Softmax 的原因是强制实施“对每个低层胶囊 i，所有权重 cij 的总和等于 1”这一条性质。</li>
<li>初始化时，所有 cij 均相等，说明底层胶囊被高层胶囊接受的概率相等。随着迭代，这种均匀分布将被改变。</li>
<li>第七行更新了权重，也是路由算法的本质所在。在这一步中，我们查看了每个高层胶囊 j，然后检查每个输入并根据公式更新相应的权重 bij。公式表明，胶囊 j 的当前输出和从低层胶囊 i 处接收的输入的点积，加上旧权重，等于新权重。点积检测胶囊的输入和输出之间的相似性。</li>
</ul>
<p>论文表示，通过在 MNIST 和 CIFAR 两个数据集上的检验，实践中建议使用 3 次迭代。更多的迭代容易导致过拟合。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="https://upload-images.jianshu.io/upload_images/2702529-32d23ca1dcb57f67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代价函数.png"></p>
<p>对于数字 c（或者说类别 c），代价函数如上图所示。MNIST 数据集中，当数字 c 与标签对应时，Tc = 1，否则为 0；m+ = 0.9，m- = 0.1。λ 取 0.5 以确保训练中的数值稳定性。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>了解 CapsNet 的具体架构有助于理解以上内容，所以我还是建议看一下原论文中这部分的内容。另外，虽然原论文相对于很多深度学习论文显得简洁而易于理解，但是有些细节并没有完全解释，我会试着再找一些资料阅读。我的下一个目标是阅读文章开头提到的《Sentiment Analysis by Capsules》。显然这篇新鲜出炉的 paper 没有什么辅助我理解的文章，我打算打印下来仔细读一读。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><ul>
<li>[1] <a href="https://arxiv.org/pdf/1710.09829v2.pdf">Dynamic Routing Between Capsules</a></li>
<li>[2] <a href="http://www.cs.utoronto.ca/~hinton/absps/transauto6.pdf?origin=publication_detail">Transforming Autoencoders</a></li>
</ul>
<h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODkxODU3Mg==&mid=2247484099&idx=1&sn=97e209f1a9860c8d8c51e81d98fc8a0a&chksm=eb4ee600dc396f16624a33cdfc0ead905e62ae9447b49b20146020e6cbd7d71f089101512a40&scene=21#wechat_redirect">CapsNet入门系列之一：胶囊网络背后的直觉</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODkxODU3Mg==&mid=2247484165&idx=1&sn=0ca679e3a5f499f8d8addb405fe3df83&chksm=eb4ee7c6dc396ed0a330fcac12690110bcaf9a8a10794dbc5e1a326c69ecbb140140f55fd6ba&scene=21#wechat_redirect">CapsNet入门系列之二：胶囊如何工作</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODkxODU3Mg==&mid=2247484433&idx=1&sn=3afe4605bc2501eebbc41c6dd1af9572&chksm=eb4ee0d2dc3969c4619d6c1097d5c949c76c6c854e60d36eba4388da2c3855747818d062c90a&scene=21#wechat_redirect">CapsNet入门系列之三：囊间动态路由算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/6CRSen8P6zKaMGtX8IRfqw">CapsNet入门系列之四：胶囊网络架构</a></li>
<li><a href="https://blog.csdn.net/jessican_uestc/article/details/79587096">初读Geoffrey Hinton颠覆之作《Dynamic Routing Between Capsules》 - CSDN博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35409788">胶囊网络（Capsule Network）在文本分类中的探索</a></li>
</ul>
<h3 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h3><ul>
<li><a href="https://github.com/Sarasra/models/tree/master/research/capsules">Sarasra/models</a>：由《Dynamic Routing Between Capsules》第一作者编写</li>
<li><a href="https://github.com/llSourcell/capsule_networks">llSourcell/capsule_networks</a></li>
<li><a href="https://github.com/XifengGuo/CapsNet-Keras">XifengGuo/CapsNet-Keras</a></li>
</ul>
]]></content>
      <categories>
        <category>深度学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>胶囊网络</tag>
        <tag>Capsule</tag>
        <tag>CapsNet</tag>
        <tag>Dynamic Routing</tag>
      </tags>
  </entry>
  <entry>
    <title>自动编码器一览（二）</title>
    <url>/blog/autoencoder-intro-2/</url>
    <content><![CDATA[<p>这是“自动编码器一览”系列的第二篇博文。在本文中，我会介绍一些最近看过并且比较感兴趣的自动编码器的变形，说是介绍，可能更像是论文笔记合集。比起第一篇提到过那些更为通用的经典变形，这些相对而言比较新颖的自动编码器在结构上进行修改，使得它们更符合所对应的特定任务的需求。如果我之后又看到一些有意思的自动编码器，也可能在这篇博文中继续更新。</p>
<p>本文中包含以下内容：</p>
<ul>
<li>递归自动编码器（Recursive Autoencoder）</li>
<li>Additional Stacked Denoising Autoencoder（aSDAE）</li>
</ul>
<p>“自动编码器一览”系列：</p>
<ul>
<li><a href="http://kyonhuang.top/autoencoder-intro-1/">自动编码器一览（一）</a></li>
<li><a href="http://kyonhuang.top/autoencoder-intro-2/">自动编码器一览（二）</a></li>
<li><a href="http://kyonhuang.top/autoencoder-intro-3/">自动编码器一览（三）</a></li>
</ul>
<span id="more"></span>

<h2 id="递归自动编码器"><a href="#递归自动编码器" class="headerlink" title="递归自动编码器"></a>递归自动编码器</h2><p>我们首先介绍论文 “Semi-Supervised Recursive Autoencoders for Predicting Sentiment Distributions”[1] 提出的<strong>递归自动编码器（Recursive Autoencoder）</strong>。在这篇论文中，递归自动编码器被用于通过无监督或半监督的训练方式，学习不定长句子的表征向量。这样学习到的表征可以被用于下游任务。在情感预测任务上，递归自动编码器达到了当时的 state-of-the-art。递归自动编码器最大的创新之处是加入了独特的层次结构，并使用语义的组合来理解情感。递归自动编码器既可以在没有标签的领域数据上，也可以在有标签的情感数据上进行训练。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/Recursive-Autoencoder.png"></p>
<h3 id="传统递归自动编码器"><a href="#传统递归自动编码器" class="headerlink" title="传统递归自动编码器"></a>传统递归自动编码器</h3><p>传统递归自动编码器要求在以一组词向量的形式给出要输入的句子 $(x_1, x_2, \dots, x_m)$ 的同时，给出句子的二叉树形结构，这个树形结构通过一组父节点和两个子节点的三元组表示：$(p \rightarrow c_{1} c_{2})$。例如在图中，我们有 $((y_{1} \rightarrow x_{1} x_{2}), (y_{2} \rightarrow y_{1} x_{3}), \dots)$ 等三元组。因为对于每组子节点，我们使用同一个神经网络来处理，因此 $y_i$ 的维度和 $x_i$ 相同。</p>
<p>对于每个三元组 $(p \rightarrow c_{1} c_{2})$，我们通过公示：</p>
<p>$$p=f\left(W^{(1)}\left[c_{1} ; c_{2}\right]+b^{(1)}\right),$$</p>
<p>来得到父节点 $p$ 的表征。注意 $f(\cdot)$ 表示非线性的激活函数。为了评估父节点 $p$ 的表征有多好，我们从父节点的表征重建其两个子节点的表征（图中橙色的节点）：</p>
<p>$$\left[c_{1}^{\prime} ; c_{2}^{\prime}\right]=W^{(2)} p+b^{(2)}$$</p>
<p>在训练过程中，我们的目标就是最小化这个重建的误差。对于每个子节点对，我们使用欧式距离来计算误差：</p>
<p>$$E_{r e c}\left(\left[c_{1} ; c_{2}\right]\right)=\frac{1}{2}\left|\left[c_{1} ; c_{2}\right]-\left[c_{1}^{\prime} ; c_{2}^{\prime}\right]\right|^{2}$$</p>
<p>我们只需要自底向上来重复以上步骤即可。</p>
<h3 id="用于预测结构的无监督递归自动编码器"><a href="#用于预测结构的无监督递归自动编码器" class="headerlink" title="用于预测结构的无监督递归自动编码器"></a>用于预测结构的无监督递归自动编码器</h3><p>我们可以从三个方面来优化传统的递归自动编码器。</p>
<p>第一点是，对于输入的句子 $x$，不再需要给出其树形结构，而是自己构建。方法是使用贪婪算法在每一步去尝试每个可能选择的子节点，最后选择这一步重构损失最低的方式构建整棵树。</p>
<p>第二点是，之前采用的重构损失是平均的惩罚所有父节点的子节点重构损失。一个改进是，对于更上层的、包含更多单词的子节点对应的重构损失，给一个更高的权重，因为它对这个句子的表征的影响更大。例如，在重构时，设 $n_1$ 和 $n_2$ 是潜在子节点 $c_1$ 和 $c_2$ 包含的单词数量，则重新定义重构损失为</p>
<p>$$E_{r e c}\left(\left[c_{1} ; c_{2}\right] ; \theta\right)= \frac{n_{1}}{n_{1}+n_{2}}\left|c_{1}-c_{1}^{\prime}\right|^{2}+\frac{n_{2}}{n_{1}+n_{2}}| | c_{2}-c_{2}^{\prime}| |^{2}$$</p>
<p>第三点是，由于每次得到的父节点表征会马上被用于重建，因此为了降低重构误差，机器会倾向于学习值非常小的表征。为了避免这个现象出现，在每次计算得到父节点的表征 $p$ 时，可以做一个正则化 $p = \frac{p}{| p |}$。</p>
<h3 id="半监督递归自动编码器"><a href="#半监督递归自动编码器" class="headerlink" title="半监督递归自动编码器"></a>半监督递归自动编码器</h3><p>到现在为止，递归自动编码器已经可以无监督地生成捕捉了句子的语义结构的表征。我们将这个表征输入到下游任务的模型中，这样，可以通过下游任务的训练来进行微调，从而使模型学习在表征中包含更多对下游任务更为重要的信息。</p>
<h2 id="Additional-Stacked-Denoising-Autoencoder"><a href="#Additional-Stacked-Denoising-Autoencoder" class="headerlink" title="Additional Stacked Denoising Autoencoder"></a>Additional Stacked Denoising Autoencoder</h2><p>接下来我们来到推荐系统领域，介绍在论文 “A Hybrid Collaborative Filtering Model with Deep Structure for Recommender Systems”[2] 被提出的 <strong>Additional Stacked Denoising Autoencoder（aSDAE）</strong>。如果一定要翻译的话，这个模型应该称为“有附加信息的堆叠去噪自动编码器”，因为这个名字有点太长了，因此我们在接下来的叙述中用 aSDAE 来代指这个自动编码器。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/aDAE-aSDAE.png"></p>
<p>其实 aSDAE 的思想非常简单，就是在堆叠去噪自动编码器的基础上，受到 Seq2Seq 模型的启发，在每一层接受一个相同的、对应输入的附加信息（side information），然后在自动编码器的最后同时重构输入和附加信息。</p>
<p>用公式表示 aSDAE 模型。对于 aSDAE 的隐藏层 $l \in { 1, \dots, L-1 }$，其隐藏表征 $h_l$ 的计算方法为</p>
<p>$$h_{l}=g\left(W_{l} h_{l-1}+V_{l} \tilde{x}+b_{l}\right),$$</p>
<p>其中，$h_0 = \tilde{s}$ 是用噪声处理过的输入，$\tilde{x}$ 是附加信息，$f(\cdot)$ 和 $g(\cdot)$ 都是激活函数。</p>
<p>对于 aSDAE 的输出层 $L$，输出的计算为</p>
<p>$$\begin{aligned} \hat &amp;=f\left({W}_{L} {h}_{L}+{b}_{\hat{s}}\right) \\ \hat &amp;=f\left({V}_{L} {h}_{L}+{b}_{\hat{x}}\right) \end{aligned}$$</p>
<p>因此，aSDAE 的损失函数为</p>
<p>$$L = \alpha|{s}-\hat|_{F}^{2}+(1-\alpha)|{x}-\hat|_{F}^{2} + \lambda\left(\sum_{l}\left|{W}_{l}\right|_{F}^{2}+\left|{V}_{l}\right|_{F}^{2}\right),$$</p>
<p>其中，$\alpha$ 是一个用于保持平衡的超参数，$\lambda$ 是正则化参数。</p>
<p>aSDAE 本身就介绍完了。在论文 [2] 中，aSDAE 学习用户和商品对应的隐向量矩阵，并将用户的基本个人信息、用户画像信息、物品的基本信息等附加信息引入，从而解决协同过滤中的稀疏性与冷启动问题。这些和推荐系统相关的背景知识就不多讨论了，有兴趣的同学可以看参考资料 [3]。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/hybrid-collaborative-filtering-model-with-aSDAE.png"></p>
<h2 id="More-Autoencoder"><a href="#More-Autoencoder" class="headerlink" title="More Autoencoder"></a>More Autoencoder</h2><p>随着对自动编码器的深入了解，我们有两个问题可以讨论：</p>
<ol>
<li>为什么要最小化重构误差？有没有其他做法？</li>
<li>怎么让自动编码器学习到的表征更具可解释性？</li>
</ol>
<p>从这两个问题引入，李宏毅老师在他的机器学习课程上又对自动编码器的一些最新进展进行了介绍和讨论。有兴趣了解的同学可以查看我的《李宏毅机器学习》课程笔记：<a href="http://kyonhuang.top/Hung-yi-Lee-ML-notes/#/More-Autoencoder">More Autoencoder - 《李宏毅机器学习》课程笔记</a>，在此就不再重复写作了。而在“自动编码器一览”系列的下一篇中，我们会来看看可能是近年来的顶会上出现最多的自动编码器的一种形式——变分自动编码器。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>[1] Richard Socher, Jeffrey Pennington, Eric H.Huang, Andrew Y.Ng, Christopher D.Manning. “Semi-Supervised Recursive Autoencoders for Predicting Sentiment Distributions”, EMNLP 2011</li>
<li>[2] Xin Dong, Lei Yu, Zhonghuo Wu, Yuxia Sun, Lingfeng Yuan, Fangxi Zhang. “A Hybrid Collaborative Filtering Model with Deep Structure for Recommender Systems”, AAAI 2017 </li>
<li>[3] 推荐系统中基于深度学习的混合协同过滤模型. <a href="https://zhuanlan.zhihu.com/p/25234865">https://zhuanlan.zhihu.com/p/25234865</a></li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>深度学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>自动编码器</tag>
        <tag>Autoencoder</tag>
        <tag>表征学习</tag>
        <tag>Representation Learning</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法一篇通——动态规划</title>
    <url>/blog/dynamic-programming/</url>
    <content><![CDATA[<p>上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。</p>
<p>另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标首先是为读研打好稳固基石，然后也要涉及多方面的知识。</p>
<p>回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。</p>
<span id="more"></span>

<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>动态规划（Dynamic programming）</strong>是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常用于求解<strong>最优化问题（Optimization problem）</strong>。动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构性质</strong>的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题，我们就称其为原问题的<strong>子问题</strong>。</p>
<p><strong>动态规划的核心</strong>是<strong>状态</strong>和<strong>状态转移方程</strong>：</p>
<ul>
<li><p><strong>状态</strong>：描述该问题的子问题的解，即根据子问题来定义状态。</p>
</li>
<li><p><strong>状态转移方程</strong>：状态和状态之间的关系式。大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态（<strong>无后效性</strong>）。</p>
</li>
</ul>
<p>能使用动态规划思想解决的问题都有最优子结构性质和重叠子问题：</p>
<ul>
<li><p><strong>最优子结构（Optimal substructure）</strong>性质：如果问题的最优解所包含的子问题的解也是最优的，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“<strong>全局最优解包含局部最优解</strong>”的思想。</p>
</li>
<li><p>重叠子问题：指在用<strong>递归</strong>算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的解题思路如下：</p>
<ol>
<li>将原问题分解为子问题；</li>
<li>确定状态：状态不是随便定义的，一般定义完就要找到状态转移方程；</li>
<li>确定一些初始状态（边界状态）的值；</li>
<li>确定状态转移方程。</li>
</ol>
<p>如果问题看起来是个动态规划问题，但是无法定义出状态，那么试着将问题规约到一个已知的 DP 问题。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>讲了这么多，让我们一起做几道题目来练练手！</p>
<h3 id="菜鸟级"><a href="#菜鸟级" class="headerlink" title="菜鸟级"></a>菜鸟级</h3><p>这里我选了 LeetCode 的第 70 题 Climbing Stairs。说来惭愧，我第一次做这个题的时候半天没做出来，还先跳过去了。</p>
<p>题目是这样的：假设你在爬梯子，需要 n 步爬到顶。每一次只能爬 1 或 2 格，爬到顶一共有多少种不同的方法？</p>
<p>一步步沿着前面提到的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：这里的子问题即“爬到 i 格共有多少种不同的方法（i &lt; n）”；</li>
<li>确定状态：我们通常用一个函数表达式来表示状态。这里我们可以用<code>d(i)</code>来表示“爬到 i 格共有的不同的方法数”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = 1</code>、<code>d(2) = 2</code>；</li>
<li>确定状态转移方程：当我们得知<code>d(i-2)</code>时，再往上爬一次 2 格即可到达 i 格；当我们得知<code>d(i-1)</code>时，再往上爬一次 1 格即可到达 i 格。因此有<code>d(i) = d(i - 1) + d(i - 2)</code>。没有重叠的解法，因为最后一步要么爬 1 格，要么爬 2 格，我们将这两种自然分开了。</li>
</ol>
<p>使用递归，我们写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Submit 就可以看到红红的 Time Limit Exceeded。计算时间超了，这是因为对于每一个 i，由于递归调用，我们反复求解相同的子问题，使得所作的工作量爆炸性增长。想要节省这些计算，我们可以采用拿空间换时间的方法，用一个大小为 n 的数组来记录子问题的计算结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        fill(i, arr);</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        arr[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        arr[n] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        arr[n] = arr[n-<span class="number">1</span>] + arr[n-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AC，Run Time 5ms。</p>
<p>也可以用递推法来解决，本质是一个 fibonacci。这里借 Discuss 里的解法一用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> one_step_before = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> two_steps_before = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> all_ways = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	all_ways = one_step_before + two_steps_before;</span><br><span class="line">    	two_steps_before = one_step_before;</span><br><span class="line">        one_step_before = all_ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all_ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><p>稍微加点难度，来试一下 LeetCode 的第 198 题 House Robber。</p>
<p>题目：你是一个超高校级的小偷，唯一能阻止你的是你同一夜不能偷相邻的两家，否则警报装置会响。给一个全是非负整数的数组来代表每家有的钱，求你在不惊动警报的基础上今晚的最大收获。</p>
<p>还是一步步沿着动态规划的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：假设数组长度为 n，则这里的子问题即“有 i 家可偷时最大收获（i &lt; n）”；</li>
<li>确定状态：用<code>g(i)</code>代表第 i 家有的钱，用<code>d(i)</code>来表示“有 i 家可偷时最大收获”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = g(1)</code>、<code>d(2) = max(g(1), g(2))</code>；</li>
<li>确定状态转移方程：可以想到，到第 i（i &gt; 2）间屋子时，可能之前偷了第 i-1 间，那这间就不能偷；如果没偷第 i-1 间，那这间可以偷。于是有<code>d(i) = max(d(i-2)+g(i), d(i-1))</code>。</li>
</ol>
<p>用数组来记录偷过第 i 间屋子时最大收获，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fill(d, nums, i);</span><br><span class="line">    <span class="keyword">return</span> d[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        d[i] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        d[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        d[i] = Math.max(d[i-<span class="number">2</span>]+nums[i], d[i-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Run Time 接近 0，非常理想。</p>
<p>也有非常巧妙的递推方案，空间复杂度 O(1)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevNo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prevYes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = prevNo;</span><br><span class="line">        prevNo = Math.max(prevNo, prevYes);</span><br><span class="line">        prevYes = n + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(prevNo, prevYes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="挑战者级"><a href="#挑战者级" class="headerlink" title="挑战者级"></a>挑战者级</h3><p>来试试 LeetCode 的第 646 题 Maximum Length of Pair Chain。这是一道难度为 medium 的题，建议先跳过这一小节，看完“扩展”中的“<a href="http://kyonhuang.top/dynamic-programming/#%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89">最长非降子序列（LIS）</a>”再回来，有助于解决和理解这道题。</p>
<p>题目：给定 n 对数，每一对中前一个数总小于后一个数。现在，我们定义当且仅当<code>b &lt; c</code>时<code>(c, d)</code>可以跟在<code>(a, b)</code>后，来形成一条链。给定一系列对，求出<em>用上述方法形成的链条的最大长度</em>。不需要用完所有的给定对，而且可以以任意顺序选取。</p>
<p>可以看到，这题和 LIS 问题比较相似，但又有一些不同。由于可以以任意顺序选取，而非 LIS 问题中选取最长非降子序列的顺序固定，因此需要对一系列数对进行一个从小到大的排序。</p>
<p>状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d(i) = max&#123;1, d(j)+1&#125;，其中 j &lt; i，pairs[j][1] &lt; pairs[i][0]</span><br></pre></td></tr></table></figure>

<p>想要求<code>d(i)</code>，就把 i 前面的各个链中，最后一个数对的最大值不大于<code>pairs[i][0]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个链中最后一个数对的最大值都大于<code>pairs[i][0]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(pairs, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> len = pairs.length;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>] &amp;&amp; arr[j] + <span class="number">1</span> &gt; arr[i])</span><br><span class="line">                arr[i] = arr[j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; l)</span><br><span class="line">            l = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(n^2)，不是最佳解法。由于根据数对的最大值排好了序，因此可以直接用下列方法来完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(pairs, (a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = pairs.length, i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; n) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">int</span> curEnd = pairs[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i+<span class="number">1</span> &lt; n &amp;&amp; pairs[i+<span class="number">1</span>][<span class="number">0</span>] &lt;= curEnd) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具体实现方法总结"><a href="#具体实现方法总结" class="headerlink" title="具体实现方法总结"></a>具体实现方法总结</h2><p>经过以上三个例题的锻炼，一般难度的动态规划问题应该都能解决了。总结一下，动态规划思想具体实现有以下两种方法：</p>
<ol>
<li><p>可以用<strong>带备忘的自顶向下法（top-down with memoization）</strong>的方法计算状态转移方程。此方法仍然按自然的递归形式编写过程，但是用一个数组或者散列表来存储每个子问题的解，当需要时先检查是否已经保存过此解并取用。</p>
</li>
<li><p>还可以采用<strong>递推法</strong>自底向上地计算状态转移方程。递推的关键是边界和计算顺序，将子问题按照规模从小到大进行求解，当求解某个子问题时，其所依赖的更小的子问题都已求解完毕。在多数情况下，递推法的时间复杂度是：状态总数 * 每个状态的决策个数 * 决策时间。如果不同状态的决策个数不同，需具体问题具体分析。注意递归和递推的区别：一个自顶向下，一个自底向上。</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="最长非降子序列（LIS）"><a href="#最长非降子序列（LIS）" class="headerlink" title="最长非降子序列（LIS）"></a>最长非降子序列（LIS）</h3><p>给定一个序列<code>A[1]、A[2]、...、A[n]</code>，求其最长非降子序列（LIS，longest increasing subsequence）的长度。这是讲动态规划时基本都会讲到的一个问题。</p>
<p>其最小子问题即求<code>A[1]、A[2]、...、A[i]</code>的最长非降子序列的长度，其中<code>i &lt; N</code>；而状态则定义有<code>d(i)</code>表示前 i 个数中以<code>A[i]</code>结尾的最长非降子序列。</p>
<p>当要考虑初始状态（边界状态）的值时，最好是以一个实际输入为例。假定要求的序列是：<code>5, 3, 4, 8, 6, 7</code>，则有：</p>
<ul>
<li>前 1 个数的 LIS 长度<code>d(1) = 1</code>；</li>
<li>前 2 个数的 LIS 长度<code>d(2) = 1</code>（序列：3；3 前面没有比 3 小的）；</li>
<li>前 3 个数的 LIS 长度<code>d(3) = 2</code>（序列：3，4；4 前面有个比它小的 3，所以<code>d(3)=d(2)+1</code>）；</li>
<li>前 4 个数的 LIS 长度<code>d(1) = 1</code>（序列：3，4，8；8 前面比它小的有 3 个数，所以<code>d(4) = max&#123;d(1),d(2),d(3)&#125;+1 = 3</code>）；</li>
</ul>
<p>由此得到状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d(i) = max&#123;1, d(j) + 1&#125;，其中 i &gt; j，A[i] &gt;= A[j]</span><br></pre></td></tr></table></figure>

<p>想要求<code>d(i)</code>，就把 i 前面的各个子序列中，最后一个数不大于<code>A[i]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个子序列中最后一个数都大于<code>A[i]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt;= A[i])</span><br><span class="line">                d[i] = Math.max(d[i], d[j] + <span class="number">1</span>);</span><br><span class="line">        len = Math.max(d[i], len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 O(n^2)，不是最优解法。可以看看<a href="https://www.felix021.com/blog/read.php?1587">最长递增子序列 O(NlogN)算法</a>，有点复杂，这里就不多谈了。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1 背包问题是最广为人知的动态规划问题之一，拥有很多变形。</p>
<p>有 n 种物品，每种只有一个。第 i 种物品的体积为 V[i]，价值为 W[i]。选一些物品装到一个容量为 C 的背包，使得背包内物品在总体积不超过 C 的前提下价值尽量大。1 &lt;= n &lt;= 100，1 &lt;= V[i] &lt;= C &lt;= 10000，1 &lt;= W[i] &lt;= 10^6。</p>
<p>将原问题分解为子问题后，状态还是比较好找的。我们可以用<code>d(i, j)</code>来表示前 i 个物品装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>对于第 i 个物品，可以装进或不装进背包。不装进背包，则背包中物品最大总价值为<code>d(i-1, j)</code>；而如果装进背包，对于前 i-1 个物品的空间就只有 j-V[i] 了。</p>
<p>由此得到状态转移方程：</p>
<p><code>d(i, j) = max&#123;d(i-1, j), d(i-1, j-V[i]) + W[i]&#125;</code></p>
<p>得到状态转移方程后，代码也不难写出了。这里就不贴了，有兴趣可以自己试试。</p>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>Dijkstra 算法也是以动态规划为基础的。你可以到我《算法》笔记的相关章节对 Dijkstra 算法进行进一步了解：<a href="https://github.com/bighuang624/Algorithms-notes/blob/master/%E7%AC%94%E8%AE%B0/4.4_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.md">Algorithms-notes/笔记/4.4 最短路径
</a>（Dijkstra 算法相关内容正在添加中）。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划有着很强的理论性和实践性，可以考验出算法能力，因此经常在各类算法竞赛、面试题中出现。想要完全掌握，光搞定这一篇博客的几个例题远远不够，只有多做经典题目，才能当再碰到动态规划相关题目的时候做到游刃有余。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a href="http://www.hawstein.com/posts/dp-novice-to-advanced.html">动态规划：从新手到专家</a></li>
<li><a href="http://blog.csdn.net/baidu_28312631/article/details/47418773">教你彻底学会动态规划——入门篇 - CSDN博客</a></li>
<li>《算法竞赛入门经典（第 2 版）》第 9 章</li>
</ul>
<h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><ul>
<li><a href="https://juejin.im/post/5a29d52cf265da43333e4da7">漫画：什么是动态规划？ - 掘金</a>：可以借助这个漫画来理解动态规划，并了解动态规划在某些背包问题的特例上计算速度的局限性。</li>
<li><a href="http://www.hawstein.com/posts/dp-knapsack.html">动态规划之背包问题（一）</a></li>
<li><a href="https://www.zhihu.com/question/23995189">什么是动态规划？动态规划的意义是什么？ - 知乎</a></li>
<li><a href="https://segmentfault.com/a/1190000012829866">javascript背包问题详解 - 个人文章 - SegmentFault</a></li>
</ul>
<h3 id="姊妹篇"><a href="#姊妹篇" class="headerlink" title="姊妹篇"></a>姊妹篇</h3><ul>
<li><a href="http://kyonhuang.top/Greedy-algorithm/">算法一篇通——贪心算法</a></li>
</ul>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>算法一篇通——贪心算法</title>
    <url>/blog/greedy-algorithm/</url>
    <content><![CDATA[<p>之前在写<a href="http://kyonhuang.top/dynamic-programming/">算法一篇通——动态规划</a>时，看到不少相关的资料都谈到了贪心算法。原本我对贪心算法的认知比较简单，但是越看越混，尤其是和动态规划的差异，少有文章能说的准确透彻。因此，这几天也对贪心算法加以了解学习。</p>
<p>给出 n 个物体，第 i 个物体重量为 wi，要求选择尽量多的物体，使得总重量不超过 C。对于这个问题，我们很容易想到，因为在对总重量有要求的情况下要选择尽量多的物体，因此挑轻的肯定比挑重的划算。这样，我们将所有物体按重量从小到大排序，依次选择每个物体，直到装不下为止。</p>
<p>这就一种典型的贪心算法，只顾眼前利益，做出局部最优的选择，寄希望于这样的选择能导致全局最优解。</p>
<span id="more"></span>

<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>贪心算法（Greedy Algorithm，又称贪婪算法）</strong>，指在对问题求解时，不从整体最优上加以考虑，而总是做出在当前看来是最好的选择。也就是说，所做出的是在某种意义上的<strong>局部最优解</strong>。</p>
<p>贪心算法<strong>不是对所有问题都能得到整体最优解</strong>，关键是贪心策略的选择，选择的贪心策略必须具备<strong>无后效性</strong>，即某个状态只与它前面出现的状态有关，而独立于后面的状态。</p>
<p>贪心算法的两个性质是<strong>贪心选择性质</strong>和<strong>最优子结构性质</strong>：</p>
<ul>
<li><p><strong>贪心选择性质</strong>：指所求的问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来得到。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。</p>
</li>
<li><p><strong>最优子结构（optimal substructure）性质</strong>：如果<strong>原问题的最优解包含的子问题的最优解</strong>，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“<strong>全局最优解包含局部最优解</strong>”的思想。</p>
</li>
</ul>
<h2 id="贪心算法与动态规划的区别"><a href="#贪心算法与动态规划的区别" class="headerlink" title="贪心算法与动态规划的区别"></a>贪心算法与动态规划的区别</h2><ol>
<li>贪心算法的每一次操作都<strong>对结果产生直接影响</strong>，而动态规划则不是。</li>
<li>贪心算法对每个子问题的解决方案都做出选择，<strong>不能回退</strong>；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li>
<li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li>
</ol>
<p>实际上，贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算。</p>
<p>尽管贪心算法和动态规划都有最优子结构性质，我认为这个性质在两种算法中有着不太一样的含义：贪心的局部最优能达成全局最优，而动态规划的全局最优值中不一定全是局部最优，只是求解全局最优时要以局部最优作为基础。或者，我们可以认为，贪心算法通常都是自顶向下进行设计的，而动态规划则自顶向上。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，<strong>选取应该满足局部优化的条件</strong>。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><img src="/images/brush-is-the-best.png"/>

<h3 id="菜鸟级"><a href="#菜鸟级" class="headerlink" title="菜鸟级"></a>菜鸟级</h3><p>这里我选了 LeetCode 的第 122 题 Best Time to Buy and Sell Stock II。题目是这样的：给定一个数组，第 i 个元素代表第 i 天石头的买卖价。找到一种赚取最大利润的方法，你可以进行任意次交易，但是不能同时处于两笔交易中（即必须先将手上的石头卖出去才能再买）。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>根据贪心选择的性质，只要能赚到钱，我们就卖掉手上的石头。那么，只要后一天的价格比前一天高，我们就做买入卖出这一笔买卖。于是有代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (prices[i+<span class="number">1</span>] &gt; prices[i]) </span><br><span class="line">            total += prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的思路是简单粗暴而有效的，但是可能需要结合多种情况考虑一下，为什么这样做是对的（我们设第 i 天的价格为 s[i]）：</p>
<ul>
<li>s[i] &lt; s[i+1] &lt; s[i+2]：这样的话，按照之前的解法，相当于省略掉中间那一笔卖出买入，只考虑第 i 天和第 i+2 天；</li>
<li>s[i] &gt; s[i+1] &lt; s[i+2]：这样的话，我们的算法会当作没有买入过第 i 天的石头。</li>
</ul>
<h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><h3 id="挑战者级"><a href="#挑战者级" class="headerlink" title="挑战者级"></a>挑战者级</h3><p>这里我选择的是 LeetCode 的第 135 题，是一道 hard 难度的题目。N 个小朋友排排坐，每个小朋友有一个分值。你需要给小朋友发糖，遵循以下规则：</p>
<ul>
<li>每个小朋友保底一块糖；</li>
<li>若比左右邻居得分高，则得到的糖更多。</li>
</ul>
<p>求最少发多少糖。</p>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><p>需要拿一个与输入数组同样大小的数组来存储每个孩子的糖果树。</p>
<p>先从 0 开始向右遍历一次：第 0 个孩子先拿一块；i &gt; 0 时，如果 ratings[i] &gt; ratings[i-1]，那么第 i 个孩子在第 i-1 个孩子所拥有的糖果数上多拿一块，否则拿保底的一块。这一次遍历将右边的 rating 比左边大的情况全部搞定。</p>
<p>再从 len-1 开始向左遍历一次：第 len-1 个孩子不变，如果 ratings[i] &lt; ratings[i-1]，那么，除非第 i-1 个孩子本身拥有的糖果数已经比多拿这一块后还要多，否则第 i－1 个孩子在第 i 个孩子所拥有的糖果数上多拿一块。这一次遍历将左边的 rating 比右边大的情况全部搞定，并且不会影响到上一次遍历所完成的工作。</p>
<p>因为每一次发糖都遵循贪心选择性质，最多多给一块，并且没有后效性，因此也是贪心算法的运用。</p>
<p>尽管时间复杂度和空间复杂度都不是最优的，但上述解法能够 AC，并且简洁易懂。当然，这个思路还是比较巧妙的，也很难短时间内想出来。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>和动态规划一样，贪心算法也扩展许多衍生的问题与算法。例如，深度学习中的梯度下降算法就是贪心的。更著名的一些如下。</p>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>我们可以用 01 编码串来代表一个字符，例如 a 为 0，c 为 00，f 为 1100。这样，可能因为其中一个字符的编码是另一个字符的前缀而导致歧义。满足<strong>任何一个编码都不是另一个的前缀的编码</strong>被称为<strong>前缀码（Prefix Code）</strong>。</p>
<p>这样，我们很容易想到，给定 n 个字符在文件中的出现频率 ci，求一套总长度（每个字符的频率与编码长度乘积的总和）尽量小的编码。根据一个已知结论：<strong>任何一个前缀编码都可以表示成每个非叶结点恰好有两个子结点的二叉树</strong>，我们可以通过构造一棵最优的编码树来解决这个问题。</p>
<p><strong>Huffman 算法</strong>：把每个字符看作一个单结点子树放在一个树集合中，每棵子树的权值等于对应字符的频率。每次取权值最小的两棵子树合并成一棵新树，并重新放到集合中。新树的权值等于两棵子树权值之和。</p>
<p>从以下结论可以体现 Huffman 算法是一种贪心算法：</p>
<ul>
<li>设 x 与 y 是频率最小的两个字符，则存在前缀码使得 x 和 y 具有相同码长，且仅有最后一位编码不同。这体现了贪心算法的<strong>贪心选择性质</strong>。</li>
<li>设 T 是加权字符集 C 的最优编码树，x 和 y 是树 T 中的两个叶子，且互为兄弟结点，z 是它们的父结点。若把 z 看作具有频率 f(z) = f(x) + f(y) 的字符，则树 T’ = T - {x, y} 是字符集 C’ = C - {x, y}U{z} 的一棵最优编码树。这体现了贪心算法的<strong>最优子结构性质</strong>。</li>
</ul>
<h3 id="Prim-算法-和-Kruskal-算法"><a href="#Prim-算法-和-Kruskal-算法" class="headerlink" title="Prim 算法 和 Kruskal 算法"></a>Prim 算法 和 Kruskal 算法</h3><p>Prim 算法 和 Kruskal 算法都是在加权无向图找到最小生成树的算法，它们也都是贪心算法。</p>
<p><strong>Prim 算法</strong>：每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条<strong>连接树中的顶点与不在树中的顶点且权重最小的边加入树中</strong>。</p>
<p><strong>Kruskal 算法</strong>：按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，<strong>加入的边不会与已经加入的边构成环</strong>，直到树中含有 V-1 条边为止。我们从一片由 V 棵单顶点的树构成的森林开始并不断将两颗树合并（用可以找到的最短边），直到只剩下一棵树，它就是最小生成树。</p>
<p>如果你想要更详细地了解这部分内容，可以查看我《算法》笔记的相关章节：<a href="https://github.com/bighuang624/Algorithms-notes/blob/master/%E7%AC%94%E8%AE%B0/4.3_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.md">Algorithms-notes/笔记/4.3 最小生成树
</a>。</p>
<h3 id="启发式算法"><a href="#启发式算法" class="headerlink" title="启发式算法"></a>启发式算法</h3><p>很多的<strong>启发式算法</strong>（也叫智能算法），例如遗传算法，模拟退火算法，本质上就是<strong>贪心算法和随机化算法结合</strong>。这样的算法结果虽然也是局部最优解，但是比单纯的贪心算法更佳靠近最优解。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>随着第二篇算法学习的总结笔记出炉，我发现除开大二上学期《算法与数据结构》课程提到的基础而有限的算法之外，还有很多算法处于我的认知边缘之外。我准备把对这些算法的学习全部汇总到一个系列，取名为“算法一篇通”，希望写作效果能够恰如其名。</p>
<p>贪心算法也不简单。之后我可能还会再做一些这个方面的题，届时再进行补充。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800?fr=aladdin">贪心算法_百度百科</a></li>
<li>《算法竞赛入门经典（第 2 版）》第 8 章</li>
<li>《算法导论》第 16 章</li>
</ul>
<h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><ul>
<li><a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html">大白话解析模拟退火算法 - 苍梧 - 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>记知识图谱前沿技术课程（武汉大学站）</title>
    <url>/blog/whu-KG-technology-course/</url>
    <content><![CDATA[<p>这周一（4月28日）参加了<a href="https://mp.weixin.qq.com/s?__biz=MzI0MTI1Nzk1MA==&mid=2651676132&idx=1&sn=3965c4718e97cf4962301229c4fd877f&chksm=f2f7a155c5802843c1ec73a120d6cbe506c819cf87f32b4f5fa68862dd6603a2edb66f10208b&mpshare=1&scene=23&srcid=04209Zn8T1cUyBEYullCcwnB#rd">知识图谱前沿技术课程暨学术研讨会（武汉大学站）</a>。本次研讨会邀请了很多著名学者和企业代表，结合知识图谱学界研究与业界应用的进展，系统地讲解知识图谱前沿技术及智能应用。</p>
<p>我之前对知识图谱了解甚少，但经过一整天的讲座学习，也接触到了知识图谱的理论知识和产业实际应用，感受到了其独特的魅力。在八场主题各异的讲座中，我认为复旦大学知识工场实验室的肖仰华教授所带来的《领域知识图谱落地实践中的问题与对策》既有对知识图谱技术的概述，也有足够的深度和思考空间。因此，我基于这场讲座的内容笔记，结合自己查找的其他资料做一个整理。</p>
<p>注：本文涉及的图片及资料均整理自肖仰华教授的讲座内容，版权归其所有。</p>
<span id="more"></span>

<h3 id="知识图谱的概念"><a href="#知识图谱的概念" class="headerlink" title="知识图谱的概念"></a>知识图谱的概念</h3><p>顾名思义，<strong>领域知识图谱（Domain-specific Knowledge Graph）</strong>即是特定领域的知识图谱。而<strong>知识图谱（Knowledge Graph）</strong>是以<strong>实体/概念</strong>为点、它们之间的<strong>语义关系</strong>为边的大规模<strong>语义网络</strong>。</p>
<p><img src="/images/KG/Knowledge-Graph.png"></p>
<p>传统的知识工程需要专家构建，代价高昂，规模有限；并且知识边界易于突破，难以适应大数据时代开放应用到规模化需求。而知识图谱富含<strong>实体、概念、属性、关系</strong>等信息，使得机器<strong>理解和解释</strong>成为可能。最重要的是，知识图谱可以满足大规模开放应用。</p>
<p>尽管肖教授表示“知识图谱引领知识工程复兴”，他也同时提出了<strong>NoKG（Not only KG）</strong>一词，以表示解决问题的知识表示不只是知识图谱，因为知识图谱不好处理过程知识、决策知识等。</p>
<h3 id="领域知识图谱（DKG）与-通用知识图谱（GKG）的关系与区别"><a href="#领域知识图谱（DKG）与-通用知识图谱（GKG）的关系与区别" class="headerlink" title="领域知识图谱（DKG）与 通用知识图谱（GKG）的关系与区别"></a>领域知识图谱（DKG）与 通用知识图谱（GKG）的关系与区别</h3><p>两者在知识表示、获取与应用等方面有着显著的差异：</p>
<p><img src="/images/KG/DKG-GKG.png"></p>
<p>一个问题是，行业应用中的知识需求难以封闭于预设的领域知识边界内。因此，在做领域知识图谱时不可避免的需要通用知识图谱的支撑，为其提供高质量的事实和基本的领域纲要；反过来，领域知识图谱又对通用知识图谱有补充和完善。</p>
<h3 id="知识表示方式"><a href="#知识表示方式" class="headerlink" title="知识表示方式"></a>知识表示方式</h3><p><strong>符号表示</strong>和<strong>分布式表示</strong>是两种重要的知识表示方式。符号化表示的特点是可解释、可推理、面向人；分布式表示则难解释、难推理、面向机器，这是因为它是用数值表示的（和自然语言处理中的词嵌入有些类似）。</p>
<p><img src="/images/KG/Knowledge-representation.png"></p>
<h3 id="为何需要领域知识图谱？"><a href="#为何需要领域知识图谱？" class="headerlink" title="为何需要领域知识图谱？"></a>为何需要领域知识图谱？</h3><ul>
<li>将零碎的数据整合为聚合的知识，助力挖掘数据价值</li>
<li>将领域知识赋予机器，解放人类脑力，实现知识工作自动化</li>
<li>领域知识的积累和沉淀是未来智能化的必经之路</li>
</ul>
<h3 id="DKG-中知识如何表示"><a href="#DKG-中知识如何表示" class="headerlink" title="DKG 中知识如何表示"></a>DKG 中知识如何表示</h3><ul>
<li><strong>三元组（SPO）表示</strong>：&lt;七里香，填词，方文山&gt;</li>
<li><strong>时空语义扩展</strong>：从时间角度和空间角度进行表示</li>
<li><strong>跨媒体表示</strong>：文本、图片、视频</li>
</ul>
<h3 id="领域知识图谱构建的基本流程"><a href="#领域知识图谱构建的基本流程" class="headerlink" title="领域知识图谱构建的基本流程"></a>领域知识图谱构建的基本流程</h3><p><img src="/images/KG/DKG-construction.png"></p>
<h3 id="领域知识图谱的评价指标"><a href="#领域知识图谱的评价指标" class="headerlink" title="领域知识图谱的评价指标"></a>领域知识图谱的评价指标</h3><p>质量（准）、规模（全）、实时（新）</p>
<h3 id="领域知识图谱的数据库选型"><a href="#领域知识图谱的数据库选型" class="headerlink" title="领域知识图谱的数据库选型"></a>领域知识图谱的数据库选型</h3><p>进行数据库选型时，一般要考虑操作复杂度（是否包含全局计算、多步遍历和复杂子图）和知识库规模（节点、关系、密度）。当规模极高、操作极复杂时，由于知识图谱先天适用于图表示，因此一般使用 Graph DB（图数据库）。其他情境下，也可以选用 NoSQL DB 或者 MySQL 等 Relational DB。</p>
<h3 id="领域知识图谱的查询方式"><a href="#领域知识图谱的查询方式" class="headerlink" title="领域知识图谱的查询方式"></a>领域知识图谱的查询方式</h3><p>进行 DKG 的查询时，一般有 SPARQL 和 SQL 语句两种选择。SQL 的优点是简单且普及性高，但是表达能力相对较弱；而 SPARQL 表达能力强、可推理，但是较为复杂、难以书写，并且执行复杂查询的代价高昂。</p>
<h3 id="领域知识图谱如何应用？"><a href="#领域知识图谱如何应用？" class="headerlink" title="领域知识图谱如何应用？"></a>领域知识图谱如何应用？</h3><ul>
<li>智慧搜索：精准理解搜索意图、复杂多元对象搜索、多粒度（篇章、段落、语句）搜索、跨媒体搜索；</li>
<li>智能推荐：精确感知任务与场景；</li>
<li>智能问答：更自然的对话式人机交互取代关键词搜索；</li>
<li>智能解释：提高事实、关系、过程、结果的可解释性；</li>
<li>决策分析：隐层关系发现、深层关系推理助力智能系统决策。</li>
</ul>
<h3 id="领域知识图谱落地有哪些最佳实践？"><a href="#领域知识图谱落地有哪些最佳实践？" class="headerlink" title="领域知识图谱落地有哪些最佳实践？"></a>领域知识图谱落地有哪些最佳实践？</h3><ul>
<li><strong>应用引领</strong>：不要盲目建立知识图谱，否则易成“烂尾楼”</li>
<li><strong>避难就简</strong>：结构化 -&gt; 半结构化 -&gt; 非结构化，用最简单的开始实现</li>
<li><strong>避免从零开始</strong>：以通用图谱中的领域图谱作为种子</li>
<li><strong>跨领域迁移</strong>：从临近领域迁移</li>
</ul>
<h3 id="领域知识图谱还存在哪些挑战？"><a href="#领域知识图谱还存在哪些挑战？" class="headerlink" title="领域知识图谱还存在哪些挑战？"></a>领域知识图谱还存在哪些挑战？</h3><ul>
<li><strong>如何增强知识图谱的语义表示能力？</strong>：知识图谱只能表达简单关联事件，对于时空语义、跨媒体语义支撑力度不够；</li>
<li><strong>如何实现稀疏样本下的图谱自动构建？</strong>：领域样本缺失现象严重，手工构建代价高昂；稀疏样本下的高质量自动化构建缺乏有效手段；</li>
<li><strong>如何深化基于领域知识图谱智能应用？</strong>：领域知识图谱在行业的深入应用中仍缺乏有效手段，特别是推荐、推理与解释。</li>
</ul>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>可以看到，本场讲座的内容真的非常详尽。在听完讲座后，我个人还是非常看好知识图谱的发展前景的。</p>
<p>如果想要进一步了解知识图谱，也可以看以下资料：</p>
<ul>
<li><a href="https://www.jiqizhixin.com/articles/2017-03-20">知识图谱研究进展 | 机器之心</a></li>
<li><a href="https://www.zhihu.com/question/52368821">知识图谱怎样入门？ - 知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>讲座心得记录</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>讲座</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>ANTLR v4 学习笔记（三）－特性拾遗</title>
    <url>/blog/ANTLR-learning-notes-3/</url>
    <content><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-2/">ANTLR v4 学习笔记（二）－实现变种计算器</a>，我们用 ANTLR 实现了一个变种计算器，从而对 ANTLR 语法、访问器（Visitor）机制、集成以及 ANLTR 的错误处理机制有了更深的理解。</p>
<p>上篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但没有覆盖整个 Chapter 4 的所有内容。因此这篇博文将介绍一下 Chapter 4 的剩余内容——监听器（Listener）机制、代码片段嵌入语法，以及词法分析的一些很棒的特性。</p>
<span id="more"></span>

<h2 id="监听器机制"><a href="#监听器机制" class="headerlink" title="监听器机制"></a>监听器机制</h2><p>监听器机制和访问器机制有着很多共通的特点，我们也需要通过监听语法分析树遍历器触发的“事件”来完成某些工作。它们之间最大的区别在于，监听器的方法会被 ANTLR 提供的遍历器对象自动调用，而在访问器的方法中，必须显式调用<code>visit</code>方法来访问子节点，否则对应的子树将不会被访问。</p>
<p>ANTLR 会自动生成一个接口 xxListener，它定义了 ANTLR 的运行库中的 ParseTreeWalker 类在遍历语法分析树时能够触发的全部方法。当然，和访问器机制一样，我们无需实现接口中的全部方法。ANTLR 自动生成一个名为 xxBaseListener 的类，我们可以继承这个类并只重写那些我们感兴趣的方法。</p>
<h2 id="代码片段嵌入语法"><a href="#代码片段嵌入语法" class="headerlink" title="代码片段嵌入语法"></a>代码片段嵌入语法</h2><p>监听器机制和访问器一样，能够使语法分析过程和应用程序本身保持低耦合，也让语法更具有可读性。但有时候，为了满足比较苛刻的需求，我们需要将代码片段（动作）嵌入到语法中，这些动作会被拷贝到 ANTLR 自动生成的递归下降语法分析器的代码中。</p>
<h3 id="将任意动作嵌入语法"><a href="#将任意动作嵌入语法" class="headerlink" title="将任意动作嵌入语法"></a>将任意动作嵌入语法</h3><p>拿下面这一份用于解析类表格文件的语法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grammar Rows;</span><br><span class="line"></span><br><span class="line"><span class="meta">@parser</span>::members &#123;  <span class="comment">// 在生成的 RowsParser 中添加一些成员</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RowsParser</span><span class="params">(TokenStream input, <span class="keyword">int</span> col)</span> </span>&#123;  <span class="comment">// 自定义的构造器</span></span><br><span class="line">      <span class="keyword">this</span>(input);</span><br><span class="line">      <span class="keyword">this</span>.col = col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file: (row NL)+ ;</span><br><span class="line"></span><br><span class="line">row</span><br><span class="line">locals [<span class="keyword">int</span> i=<span class="number">0</span>]</span><br><span class="line">    : (   STUFF</span><br><span class="line">          &#123;</span><br><span class="line">          $i++;</span><br><span class="line">          <span class="keyword">if</span> ($i == col) System.out.println($STUFF.text);</span><br><span class="line">          &#125;</span><br><span class="line">      )+</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">TAB   : <span class="string">&#x27;\t&#x27;</span> -&gt; skip ;    <span class="comment">// 匹配但是不将其传递给语法分析器</span></span><br><span class="line">NL    : <span class="string">&#x27;\r&#x27;</span>? <span class="string">&#x27;\n&#x27;</span> ;      <span class="comment">// 匹配并将其传递给语法分析器</span></span><br><span class="line">STUFF : ~[\t\r\n]+ ;      <span class="comment">// 匹配除 tab 符和换行符之外的任何字符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>@parser::members</code>表示在生成的 RowsParser 中添加一些成员，即大括号里的所有元素（包括）会原封不动的添加到 RowsParser 类中。我们通过加入的构造器来传入希望提取的列号。</p>
<p>row 规则的<code>(...)+</code>循环放置了一些动作，访问了之前使用 locals 子句定义的局部变量<code>$i</code>。同时 row 规则也使用了<code>$STUFF.text</code>来获得刚刚匹配的 STUFF 词法符号中包含的文本。关于动作的更多内容会在 Chapter 10 深入研究。</p>
<h3 id="用语义判定改变语法分析过程"><a href="#用语义判定改变语法分析过程" class="headerlink" title="用语义判定改变语法分析过程"></a>用语义判定改变语法分析过程</h3><p>用一个读取一列整数的语法作为例子。首先看一下需求：输入的其中的一部分整数指定了接下来的多少个整数分为一组。例如输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 8 43 3 1 4 6</span><br></pre></td></tr></table></figure>

<p>第一个数字 2 表示匹配接下来的两个数字 8 和 43，数字 3 表示匹配接下来的三个数字。</p>
<p>语法文件如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">grammar Data;</span><br><span class="line"></span><br><span class="line">file : group+ ;</span><br><span class="line"></span><br><span class="line">group: INT sequence[$INT.<span class="keyword">int</span>] ;</span><br><span class="line"></span><br><span class="line">sequence[<span class="keyword">int</span> n]</span><br><span class="line">locals [<span class="keyword">int</span> i = <span class="number">1</span>;]</span><br><span class="line">     : ( &#123;$i&lt;=$n&#125;? INT &#123;$i++;&#125; )*  <span class="comment">// 匹配 n 个整数</span></span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line">INT :   [<span class="number">0</span>-<span class="number">9</span>]+ ;     <span class="comment">// 匹配整数</span></span><br><span class="line">WS  :   [ \t\n\r]+ -&gt; skip ;   <span class="comment">// 丢弃所有的空白字符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Data 语法的关键在于<code>&#123;$i&lt;=$n&#125;?</code>，这段动作的值是布尔类型的，它被称为一个语义判定。在匹配到 n 个输入整数之前，它的值保持为 true，其中 n 是 sequence 语法中的参数。当语义判定的值为 false 时，对应的备选分支就从语法中“消失”了，因此，它也就从生成的语法分析器中“消失”了。在本例中，语义判定的值为 false 时，<code>(...)*</code>循环终止，从 sequence 规则返回。</p>
<h2 id="词法分析特性"><a href="#词法分析特性" class="headerlink" title="词法分析特性"></a>词法分析特性</h2><p>ANTLR 有三个与词法符号有关非常棒的特性。</p>
<h3 id="孤岛语法：处理同一文件中的不同格式"><a href="#孤岛语法：处理同一文件中的不同格式" class="headerlink" title="孤岛语法：处理同一文件中的不同格式"></a>孤岛语法：处理同一文件中的不同格式</h3><p>有很多常见的文件格式包含了多重语言，例如 Java 文件中有注释和 Java 代码，ejs 等模板引擎有模板语言表达式和文本。不同格式的语言需要按照不同的方式进行处理，这样的现象被称为<strong>“孤岛语法”</strong>。</p>
<p>ANTLR 提供了一个名为<strong>词法分析模式（lexical modes）</strong>的词法分析器特性，帮助我们方便地处理混合了不同格式数据的文件。它的基本思想是，当遇到特殊的“哨兵”字符序列时，执行不同模式的切换。</p>
<p>我们不妨以 XML 作为例子。一个 XML 解析器会将除标签和实体转义（例如<code>&amp;pound;</code>）之外的内容全部当作普通文本。当看到<code>&lt;</code>时，词法分析器会切换到 “INSIDE” 模式；当看到<code>&gt;</code>或者<code>/&gt;</code>时，它就切换回默认模式。</p>
<p>下面的语法展示了 XML 解析器的工作方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a lexer grammar called XMLLexer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lexer grammar XMLLexer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认模式：所有在标签之外的东西</span></span><br><span class="line">OPEN        : <span class="string">&#x27;&lt;&#x27;</span>                 -&gt; pushMode(INSIDE) ;</span><br><span class="line">COMMENT     : <span class="string">&#x27;&lt;!--&#x27;</span> .*? <span class="string">&#x27;--&gt;&#x27;</span>    -&gt; skip ;</span><br><span class="line">EntityRef   : <span class="string">&#x27;&amp;&#x27;</span> [a-z]+ <span class="string">&#x27;;&#x27;</span> ;</span><br><span class="line">TEXT        : ~(<span class="string">&#x27;&lt;&#x27;</span>|<span class="string">&#x27;&amp;&#x27;</span>)+ ;           <span class="comment">// 匹配任意除 &lt; 和 &amp; 之外的 16 位字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------    所有在标签之内的东西    ----------------------</span></span><br><span class="line">mode INSIDE;</span><br><span class="line">CLOSE       : <span class="string">&#x27;&gt;&#x27;</span>                 -&gt; popMode ;  <span class="comment">// 回到默认模式</span></span><br><span class="line">SLASH_CLOSE : <span class="string">&#x27;/&gt;&#x27;</span>                -&gt; popMode ;</span><br><span class="line">EQUALS      : <span class="string">&#x27;=&#x27;</span> ;</span><br><span class="line">STRING      : <span class="string">&#x27;&quot;&#x27;</span> .*? <span class="string">&#x27;&quot;&#x27;</span> ;</span><br><span class="line">SlashName   : <span class="string">&#x27;/&#x27;</span> Name ;</span><br><span class="line">Name        : ALPHA (ALPHA|DIGIT)* ;</span><br><span class="line">S           : [ \t\r\n]           -&gt; skip ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">ALPHA       : [a-zA-Z] ;</span><br><span class="line"></span><br><span class="line">fragment</span><br><span class="line">DIGIT       : [<span class="number">0</span>-<span class="number">9</span>] ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提供一份如下所示的样例输入文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tools</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tool</span> <span class="attr">name</span>=<span class="string">&quot;ANTLR&quot;</span>&gt;</span>A parser generator<span class="tag">&lt;/<span class="name">tool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tools</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试步骤与结果如下所示：</p>
<img src="/images/antlr/note3/XMLLexer.jpg" />

<p>值得一提的是，在上述启动测试组件的命令行中，使用的参数是 XML tokens，在正常情况下，这里应该是一个语法名加一个起始规则名。如果需要令测试组件只运行词法分析器而不运行语法分析器，我们可以指定参数为语法名加上一个特殊的规则名<code>tokens</code>。</p>
<h3 id="重写输入流"><a href="#重写输入流" class="headerlink" title="重写输入流"></a>重写输入流</h3><p>我们可以通过 TokenStreamRewriter 对象对输入流进行修改，然后再加以输出，从而实现对源代码插桩或重构。例如，我们可以通过以下代码实现一个监听器，来给每个类定义中加上一行序列化版本标示符（serialVersionUID）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.TokenStreamRewriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSerialIDListener</span> <span class="keyword">extends</span> <span class="title">JavaBaseListener</span> </span>&#123;</span><br><span class="line">    TokenStreamRewriter rewriter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InsertSerialIDListener</span><span class="params">(TokenStream tokens)</span> </span>&#123;</span><br><span class="line">        rewriter = <span class="keyword">new</span> TokenStreamRewriter(tokens);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterClassBody</span><span class="params">(JavaParser.ClassBodyContext ctx)</span> </span>&#123;</span><br><span class="line">        String field = <span class="string">&quot;\n\tpublic static final long serialVersionUID = 1L;&quot;</span>;</span><br><span class="line">        rewriter.insertAfter(ctx.start, field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们在 main 程序中初始化一个 InsertSerialIDListener，并当遍历结束时打印词法符号流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();  <span class="comment">// 新建一个标准的遍历器</span></span><br><span class="line">InsertSerialIDListener extractor = <span class="keyword">new</span> InsertSerialIDListener(tokens);</span><br><span class="line">walker.walk(extractor, tree);  <span class="comment">// 使用监听器初始化对语法分析树的遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出修改后的词法符号流</span></span><br><span class="line">System.out.println(extractor.rewriter.getText());</span><br></pre></td></tr></table></figure>

<p>注意，TokenStreamRewriter 实际上修改的是词法符号流的“视图”而非词法符号流本身。它认为所有对修改方法的调用都只是一个“指令”，然后将这些修改放入一个队列；在未来词法符号流被重新渲染为文本时，这些修改才会被执行。因此每次我们调用<code>getText()</code>的时候，rewriter 对象都会执行上述队列中的指令。</p>
<h3 id="将-Tokens-送入不同通道"><a href="#将-Tokens-送入不同通道" class="headerlink" title="将 Tokens 送入不同通道"></a>将 Tokens 送入不同通道</h3><p>语法分析器只处理一个通道，因此当我们想要忽略但保留某些 tokens 时（例如注释和空白字符），我们可以通过在语法文件书写特殊的指令，来将其送入其他通道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">COMMENT</span><br><span class="line">    :    <span class="string">&#x27;/*&#x27;</span> .*? <span class="string">&#x27;*/&#x27;</span>    -&gt; channel(HIDDEN)  <span class="comment">// 匹配 /* 和 */ 之间的任何东西</span></span><br><span class="line">    ;</span><br><span class="line">WS  :    [ \r\t\u000c\n]+ -&gt; channel(HIDDEN)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>

<p><code>-&gt;channel(HIDDEN)</code>和<code>-&gt;skip</code>类似，也是一个词法分析器指令。在这里，它设置了这些 tokens 的通道号。这样，这些 tokens 就会被语法分析器忽略。token 流中仍然保存着这些原始的 tokens 序列，但在向语法分析器提供数据时忽略了那些处于已关闭通道的 tokens。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第三篇笔记到这里就结束了。尽管这一篇笔记很短，但是涵盖了 ANTLR 实践中一些比较现实的问题的解决方式。在了解这三篇笔记所涉及的学习内容后，如果还有兴趣，就可以正式展开对使用 ANTLR 开发语言类应用程序的学习了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
</ul>
]]></content>
      <categories>
        <category>解释器构造</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
        <tag>ANTLR</tag>
        <tag>解释器</tag>
      </tags>
  </entry>
  <entry>
    <title>记 CIPS 青工委武汉大学系列讲座</title>
    <url>/blog/whu-CIPS-academic-salon/</url>
    <content><![CDATA[<p>趁着余兴未尽，来将今天早上参加的讲座记录一下。很幸运周四在教学楼下看到了这次活动的海报。本次系列讲座是 CIPS 青工委（中国中文信息学会青年工作委员会）在武汉大学的一次活动，主持人是武大的李晨亮老师，嘉宾包括清华的刘洋老师、刘知远老师、张敏老师，天津大学的张鹏老师和北大的严睿老师。五名老师在其所关注的细分领域各有建树，全是自然语言处理和信息检索领域的大牛。接下来以老师报告的顺序大概介绍一下各位老师的报告内容，和我对各位老师的感受。因为我忘记带拍照用的手机了，因此没有照片，而且笔记也不完整，部分理解可能有偏差，尽请见谅。</p>
<p>2018.04.03 更新：更新上周五中科院自动化所刘康老师的讲座笔记。</p>
<span id="more"></span>

<h2 id="刘洋《基于深度学习的机器翻译》"><a href="#刘洋《基于深度学习的机器翻译》" class="headerlink" title="刘洋《基于深度学习的机器翻译》"></a>刘洋《基于深度学习的机器翻译》</h2><p>首先是委员会主任刘洋老师的报告。PPT 与他主页上 <a href="http://nlp.csai.tsinghua.edu.cn/~ly/talks/cwmt2016_ly_v3_160826.pptx">Advances in Neural Machne Translation</a> 的内容有 70% 是一致的，可以据此了解一下。</p>
<p>刘洋老师主要介绍了机器翻译的发展，从规则机器翻译 -&gt; 统计机器翻译 -&gt; 神经机器翻译，人们关注的重点也从规则到特征，最后变到架构。他认为神经机器翻译的可研究方向还包括架构学习（让机器学习架构来得到表现更好的，而非人类手工调整）、先验知识融合、单词学习、高效算法、可解释性等等。</p>
<p>总体来说，刘洋老师的报告是五场报告中最容易理解的，他在其中加入了很多例子帮助理解，而非一味堆积 paper 成果。</p>
<p>有观众提出问题，认为目前的机器翻译还缺少和人的感觉相配的评价指标。例如，如果机器将人名翻译错误，相似度降低很少，但是用户的使用体验就很差。另外，机器翻译用于商业时达成度不够。刘洋老师也认同目前存在这问题。</p>
<p>刘洋老师真人比主页上的照片看起来帅一些，年轻一些。另外，坐在我前面一排的小朋友应该是刘洋老师的儿子，整个讲座过程中都非常安静，很难得，也显出刘洋老师家教有方。</p>
<h2 id="严睿《人工智能在人机对话系统中的技术现状与挑战》"><a href="#严睿《人工智能在人机对话系统中的技术现状与挑战》" class="headerlink" title="严睿《人工智能在人机对话系统中的技术现状与挑战》"></a>严睿《人工智能在人机对话系统中的技术现状与挑战》</h2><p>严睿老师主要介绍了人机对话的一些现状，包括：</p>
<ul>
<li><p>分类：</p>
<ul>
<li>按领域：开放领域 / 垂直领域：医疗、金融、法律…</li>
<li>按回复方式：检索式（目前业界主流） / 生成式（下一代潮流：深度学习加持） / 综合式</li>
<li>主动 / 被动</li>
<li>…</li>
</ul>
</li>
<li><p>算法：</p>
<ul>
<li>上下文信息</li>
<li>知识库信息（世界知识）</li>
<li>语意逻辑信息 </li>
</ul>
</li>
<li><p>挑战：</p>
<ul>
<li>源自人类认知直觉的剖析</li>
<li>相关性、趣味性、信息量、情感化</li>
</ul>
</li>
</ul>
<p>另外，介绍了较多的 paper 的工作。</p>
<p>严睿老师语速比较快，给我的感觉是思路很活跃。另外，讲完后不久他就离场了，不知道是不是去看樱花去了，哈哈。</p>
<h2 id="张敏《用户满意的异质可解释的推荐：THUIR工作进展》"><a href="#张敏《用户满意的异质可解释的推荐：THUIR工作进展》" class="headerlink" title="张敏《用户满意的异质可解释的推荐：THUIR工作进展》"></a>张敏《用户满意的异质可解释的推荐：THUIR工作进展》</h2><p>张敏老师主要介绍了自己所在的 THUIR 研究组对于推荐系统的一些工作，包括：</p>
<ol>
<li>可解释推荐。</li>
<li>时间对推荐的影响（也算是可解释性）：ARIMA 时间序列模型。</li>
<li>社会关系对推荐的影响（抑制的信息）：不认识不代表负类，而是在之后会认识的概率上在进行标识。并且也使用了迁移学习。</li>
<li>用户满意度：多样性 vs 满意度。</li>
<li>用户理解：群体推荐的公平性和满意度。</li>
</ol>
<p>张敏老师的工作应该是五场报告中我最感兴趣的。活动后我斗胆去询问她是否还有学硕或者直博的名额，可惜她的名额已经满了（抢手到可怕），让我给她发邮件看研究组里另外两位老师是否还有名额。（更新：张老师课题组名额全满了）</p>
<h2 id="张鹏《量子力学启发的信息检索和自然语言处理》"><a href="#张鹏《量子力学启发的信息检索和自然语言处理》" class="headerlink" title="张鹏《量子力学启发的信息检索和自然语言处理》"></a>张鹏《量子力学启发的信息检索和自然语言处理》</h2><p>张鹏老师研究的问题比较新颖，将深度学习和量子计算结合起来。他所在的 TJU’s Quantum IR/NLP group 应该在这方面做了不少工作，但是我们可能就对这个方向不是很了解了。讲着讲着薛定谔的猫也出来了，有点懵…唯一一个报告完后没有学生提问的。老师人还是很和蔼的。</p>
<h2 id="刘知远《知识表示学习及其应用》"><a href="#刘知远《知识表示学习及其应用》" class="headerlink" title="刘知远《知识表示学习及其应用》"></a>刘知远《知识表示学习及其应用》</h2><p>最后是知乎网红刘知远老师。PPT 和他主页上的<a href="http://thunlp.org/~lzy/talks/nrl2017.pdf">社会计算与表示学习</a> 前一半内容基本相同，后一半是介绍自己的近期工作。</p>
<p>刘老师首先介绍了知识图谱实体与关系。知识图谱的典型表示方案是基于符号表示的三元组（RDF），但是无法有效计算实体间的语义关系，解决方案是将知识映射到低维向量空间。</p>
<p>之后，介绍了 TransE：将关系表示为从 head 到 tail 的翻译操作，和融合文本和知识进行关系抽取等。具体内容可以看 PPT，个人水平有限，难以总结。</p>
<p>老师目前主要关注大规模知识图谱的应用，包括关系抽取、实体对齐（不同领域的知识图谱的结合）、实体分类等。介绍了开源平台：<a href="http://openke.thunlp.org/">http://openke.thunlp.org/</a>。顺便一提，刘老师凌晨两点发了一条微博，表示整理了自己的一些工作，开源了相关代码，赞！</p>
<p>未来工作方向：</p>
<ul>
<li>利用表示学习技术将知识图谱用于相关领域（信息检索、推荐系统）</li>
<li>利用表示学习技术改进知识获取能力（富语境信息抽取、开放关系抽取、开放事件抽取）</li>
</ul>
<p>刘知远老师在知乎上对于学术科研写了不少回答，对我很有帮助。个人关注了他的微博和知乎。不过现场感觉刘老师比知乎上给人的感觉要更有威慑力一些…</p>
<h2 id="刘康《基于弱标注的大规模知识抽取》"><a href="#刘康《基于弱标注的大规模知识抽取》" class="headerlink" title="刘康《基于弱标注的大规模知识抽取》"></a>刘康《基于弱标注的大规模知识抽取》</h2><p>在第一次讲座后一周，中科院自动化所的刘康老师也来到武大，对知识抽取的现状以及研究组在这方面的工作进行了介绍。以下是一个比较抽象的笔记：</p>
<p>非结构化文本 =&gt; 知识</p>
<p>知识图谱类型：</p>
<ol>
<li>实体 - 实体(三元组) 头实体-关系-尾实体</li>
<li>事件为中心：可能有一个事件和多个实体</li>
</ol>
<p>构建知识图谱：</p>
<ul>
<li>关系抽取 / 事件抽取：动词作为触发词    挑战：开放的关系<ol>
<li>在一句话中确定两个实体的关系（和分类任务相似）</li>
<li>不给定具体上下文，要求一对实体的关系（方法：在文本中回标）</li>
</ol>
</li>
</ul>
<p>特征表示：</p>
<ul>
<li>用 DL（CNN）</li>
<li>刘老师的工作：<ul>
<li>Position Embeddings：记录实体的相对位置 </li>
<li>Dynamic Multi-Pooling and Piece-wise MaxPooling：每一段做一个最大池化</li>
</ul>
</li>
</ul>
<p>自动标注大量训练数据：</p>
<ul>
<li>回标：将已找到的实体三元组在文本中回找，所有对应的语句都可以当作正样本 =&gt; 问题：关系可能不一样</li>
<li>以上策略不能用于以事件为中心的知识：找不到事件所具体对应的字符串</li>
<li>动词作为触发词，找其他实体 =&gt; 问题：在一句话中不会有全部的实体 =&gt; 找关键的 arguments（实体） =&gt; 如何找 key arguments？TF-IDF、相似度…</li>
</ul>
<p>训练策略：如何减少噪声的影响？</p>
<ul>
<li>Multi-Instance Learning</li>
<li>Attention </li>
<li>transE：三元组中，实体为点，关系为向量</li>
</ul>
<p>最新的工作：强化学习</p>
<p>落地：从金融、法律公告中抽取结构化的知识</p>
<ul>
<li>文本分类（分析具体是哪种类型的事件 -&gt; Event Identification -&gt; 没记下来…</li>
</ul>
<p>老师展示了一个根据以上想法已经成型的 Web 应用。</p>
<h2 id="总体感受"><a href="#总体感受" class="headerlink" title="总体感受"></a>总体感受</h2><p>各位老师都介绍了各自研究的领域、面临的问题以及目前的一些工作，让我能够在走上学术之路前能够充分了解自然语言处理和信息检索的一些研究方向，对我有很大的启发。</p>
<p>现场的人数还是比较多的，临时换了一个更大的教室。刘知远老师报告时统计了一下在场的本科生，包括我在内的大约 10 人。让我没有想到的是，在场很多的研究生确实对不同老师的方向各有见解，提出了比较有深度的问题。武大啥时候冒出这么多自然语言处理方向的研究生啊，以前完全不知道，原来计院卧虎藏龙。</p>
<p>也不知道该怎么结束这篇博文了。给大家欣赏一下我下午摄影实习照的樱花好了。</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/sakura/1.jpg" />

<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/sakura/2.jpg" />

<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/sakura/3.jpg" />
]]></content>
      <categories>
        <category>讲座心得记录</category>
      </categories>
      <tags>
        <tag>自然语言处理</tag>
        <tag>讲座</tag>
        <tag>CIPS 青工委</tag>
      </tags>
  </entry>
  <entry>
    <title>记杨强老师关于联邦学习的讲座</title>
    <url>/blog/whu-federated-learning-talk/</url>
    <content><![CDATA[<p>5 月 6 日刚从杭州回到武大准备毕业答辩，得知赫赫有名的杨强老师第二天将来武大，介绍他带领的微众银行人工智能团队在联邦学习上的一些工作和思考。我们实验室的研究方向包括迁移学习的应用，而杨强老师是迁移学习领域的领头人，因此一定是要前往聆听的。老师的讲座内容没有很多算法模型上的硬核知识，但也非常有宏观上的启发性。下面，我基于讲座的内容笔记及个人思考做一个整理。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/whu-yangqiang.jpg"></p>
<span id="more"></span>

<h2 id="杨强《人工智能，数据孤岛和联邦学习》"><a href="#杨强《人工智能，数据孤岛和联邦学习》" class="headerlink" title="杨强《人工智能，数据孤岛和联邦学习》"></a>杨强《人工智能，数据孤岛和联邦学习》</h2><p>目前的 AI 系统在包括有偏性、和人类的合作、可解释性、可靠性、可信性、公平性等方面存在很多问题，其中一些问题的根因是数据的缺失和数据量的不足。杨强老师指出，目前的时代是“数据孤岛时代”，以法律、金融、医疗为首的各行业各公司都只拥有小数据。数据共享是一个容易被想到的解决方案，但其存在难度高、不合规、利益相关等问题，使得不但同一行业不同公司之间难以展开合作，甚至连同一公司各部门之间都存在“数据墙”。</p>
<p>为了解决数据量不足的固有问题，杨强老师在过去的近十年内致力研究大数据迁移到小数据，即<strong>迁移学习（Transfer Learning）</strong>。因此，杨强老师首先简单回顾了迁移学习，其中有这些结论值得注意：1）迁移学习有助于实现鲁棒性（同样的输入对应同样的输出）和边缘计算（模型的计算放在终端进行）。2）迁移学习的本质是找到不同领域数据的不变量。3）在进行模型迁移时，低层特征更通用和可迁移，高层特征更特定和不可迁移。4）当两个领域相距很远时，可以进行传递性迁移学习（[Distant Domain Transfer Learning, AAAI 17], [Transitive Transfer Learning, KDD 15]）。</p>
<p>在从学校转投工业界，发现上述工业界亟待解决的问题后，杨强老师提出了<strong>联邦学习（Federated Learning）</strong>的概念，致力于将拥有细碎数据的各控制方可以参与联合建立 AI 模型，并协作使用模型来进行决策。在这个过程中，各方数据不出本地，因此互相之间看不到彼此的真实数据，不会违反保护个人数据隐私的相关法案，并且能够保证数据的安全和各方的利益。同时，我们力求模型的效果不会受到损失（LOSSLESS）。</p>
<p>联邦学习的一个典型流程是<code>终端本地训练 -&gt; 秘钥加密梯度 -&gt; 上传云端 -&gt; 更新模型</code>。例如，将手机终端存储的特征维度相同的用户数据在本地训练，然后将梯度等信息加密后，上传到唯一的中心，在云端中心用所有终端的信息更新模型后，手机终端再下载更新的模型。这个流程的缺点是过程比较漫长。</p>
<p>除了如上述流程所示的安全模型建立，联邦学习还试图解决很多为了保护用户隐私而导致的问题，例如隐私保护下的样本 ID 匹配，如何能够在各家银行互相不泄露用户信息的前提下，找到同时在多家银行借贷而没有偿还能力的人。</p>
<p>联邦学习的研究子方向包括但不限于：</p>
<ul>
<li><p>系统效率</p>
<ul>
<li>模型压缩（Compression）</li>
<li>算法优化（Optimization algorithms）</li>
<li>参与方选取（Client selection）</li>
<li>边缘计算（Resource constraint, IoT, Edge computing）</li>
</ul>
</li>
<li><p>模型效果</p>
<ul>
<li>数据分布不均匀（Data distribution and selection）</li>
<li>个性化（Personalization）</li>
</ul>
</li>
<li><p>数据安全 </p>
</li>
</ul>
<p>可以看到，作为一个工业界实际需求催生的研究方向，联邦学习所涉及的领域实际上不只有机器学习，还包括密码学、网络安全等。例如，联邦学习联盟的激励机制需要用到博弈论，来讨论各方如何合理分配通过联邦学习共同收获的利益。目前，IEEE 正在建立纵向联邦学习标准，相信也有很多不限于人工智能领域的专家会参与到这个过程中。更多有关联邦学习的内容可以访问 <a href="https://www.fedai.org/">https://www.fedai.org</a>。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/federated-learning-ecological-construction.jpg"></p>
<p>以上是我对杨强老师讲座内容的总结。在提问环节，杨强老师对于科研起步者如何入门的问题做了简单解答。他认为，在研究开始时，应该找一个足够窄的领域中的一个足够清晰的问题，在走完一个完整的科研周期后<strong>成功</strong>发表自己的第一篇论文。他把这个过程比喻为找一个足够弱的敌人，打一场完整的胜仗；之后，就应该开始寻找当研究生毕业时什么领域会热门，而不是盲目投身现在大热的领域。找到未来的热门领域可能很难，需要多和别人交流和分析。在未来热门但现在可能是一片荒地的领域开荒也很难，杨强老师认为需要将在该领域的研究过程划分阶段，在每个小阶段取得成功后，将其变为故事能讲给同行学者、业界专家和普通人群。另外老师提出，能在人工智能行业取得成功的人需要懂人工智能、有商业头脑、有管理能力。</p>
]]></content>
      <categories>
        <category>讲座心得记录</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>讲座</tag>
        <tag>迁移学习</tag>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>IJCAI2020 教训总结</title>
    <url>/blog/my-summary-of-IJCAI20/</url>
    <content><![CDATA[<p>很久没有写博客了，恰逢 IJCAI2020 前两天公布了录取结果。去年的我还在时间序列分析上捣鼓着我的毕业设计，今年的我在小样本学习上谋求一个落脚点，变的是年纪、是阅历、是心态，不变的是来自 IJCAI 的 reject。相比于去年，也许是因为 IJCAI 的审稿质量有了显著提升（也许也归功于他们在 desk reject 时大手一挥斩掉了将近一半的论文），也许是因为我自己在方法、实验设计和论文写作方面的进步使得评审能够更好地理解论文，总之这次的论文得以收获更加一针见血的点评，对我改进这份工作以及思考未来前进的方向有着不小的帮助。因此，我也想简单地总结一下评审们给出的意见，也是和博客的读者朋友们讨论一下（虽然可能这种讨论是单向的）身为科研菜鸟如何能够完善每一份工作。考虑到这篇论文还要修改后再投，这里把一些论文内容的相关信息模糊，只宏观地分析一下存在的问题。</p>
<p>这次的四名评审给我的论文的评分是 1 个 accept，1 个 weak accept，2 个 reject。给 accept 的那一位评审简单地写了两行夸赞之词，并表示对于如何改进这份工作没有任何建议。在感谢这位评审的认同后，从另外三位评审的评语（为了方便，后文中称为 review）以及 SPC（在这四位评审之上决定是否录用的人）的评语（后文中称为 meta-review）中，我感觉体现了以下问题：</p>
<ul>
<li><p>文献调研不够充分。在做相关工作的文献调研时，我漏掉了一些论文，使得我在论文中错误地评估了这份工作对领域的贡献。这也是 SPC 给出的两条拒稿的主要理由之一。这给我的教训是在做文献调研的工作时，第一是不能仅用关键字的方式去搜查相关工作（当然这是主要方法之一），还应该顺着那些最相关的工作的引用和被引链条上下溯源，来找到那些在题目和摘要中不易看出但实际非常相关的工作；第二是要及时地去“扫荡”正好处于你实验和写作过程中发布的论文，尤其是被认为是正式发表的会议论文。这次我就吃了亏，有一篇论文在我投稿前不久刚刚发表，逃过了我的搜查。之后要及时快速阅读新出的会议论文，并做好归类工作；第三是要培养自己在看论文时的专注力，以及能够在短时间内评估论文贡献、和手头工作是否密切相关、以及对自己是否有进一步阅读价值的能力。另外，在平时不着急赶论文时，也要多读论文多思考，从广度和深度两个角度加深自己对领域的理解，这样在写论文的相关工作时才能更有的放矢。</p>
</li>
<li><p>故事讲得不够好。尽管人工智能领域仍然发展迅速，每周都会有开创性的工作面世，但绝大多数会议收录的工作都建立在已有工作的基础上，做了一定程度的改进。而信息的传播是有噪音的，这意味着不是所有人都能够正确地理解你的工作以及评估你的创新与贡献。论文是研究工作最主要的载体，想要让自己的改进在所有评审的眼里都能够达到会议要求的标准线，就需要在论文中对工作的每个细节有更加清晰、连贯的表述。这次有几位评审都对模型中的同一个细节提出了疑问，这是因为我在表述时没能够考虑到这里虽然是引用了已有的模型，但仍可能会有理解上的门槛。另外，也有评审对我的方法的实验设置有一些质疑，认为其不公平、没有实际应用价值。这样负面且充满误解的评审意见其实是能够在写作的过程中通过更详细的举例等说明来消除的。因此，在之后的写作过程中，一是要把自己的视角放的更低来审视自己的表述，二是要邀请实验室的一些同学来严格地审阅自己写好的论文，请他们从自己的角度积极地提出意见。</p>
</li>
<li><p>选择合适的会议，或者根据不同的会议来调整自己的表述。投稿经验丰富的研究者在自己心中对于经常打交道的会议期刊应该都有这方面的经验了，但我是第一次看到有评审在评审意见中提出 IJCAI 不应该过多接收纯计算机视觉的论文，因此综合考虑决定给出 reject。尽管我不认为我是做纯计算机视觉的，但我后来发现我在投稿时因为没找到最合适的 topic，因此 primary subject area 选的是 computer vision 下的子 topic 了…为自己的工作选择最合适的会议，既是增加一份被接收的希望，也让更多同领域的研究者有机会看到自己的工作，增加自己被引用和声名大振的概率。</p>
</li>
</ul>
<p>如果每一份工作都是一面镜子，清晰地反映着你的不足，那这次 IJCAI 的经历无疑是最好的清洁剂，让这面镜子更加明亮。尽管一年来我收获了很多，但是以成果论的话，进步的速度还远远不够。除开重新投递这份工作，目前我手头还有其他的工作也将要投交。希望自己能够吸取教训，在把握宏观前进方向的同时也做好每一个细节，来更快地到达目的地。</p>
]]></content>
      <categories>
        <category>翻滚吧博士生</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Let&#39;s start Python!</title>
    <url>/blog/lets-start-Python/</url>
    <content><![CDATA[<p>年轻的决定总是美好而不负责任的。如果曾有人发誓要成为前端工程师，那他已经把过去的影子留在了古老的不再回来的夏日。现在的我是一名光荣的 Python 初学者！</p>
<p>今天有幸和朱卫平老师聊了一下。朱老师人很 nice，本身我也对智能爬虫的研究很感兴趣。既然要写爬虫，Python 这方面的生态环境还是要比 Node 强大不少。当然我也希望不丢掉之前的 JS 和 Node 基础，要时常写点东西或者看看书保持状态。</p>
<p>顺便谈一下，朱老师让我学 Python 2.7，大概是有一些历史遗留问题。但是我在知乎上查了一下，还是决定先看廖雪峰 3.x 版本的 Python 教程。我觉得知乎里一个回答给的建议不错，摘抄一下：</p>
<ul>
<li>学习 Python 前，先了解在 Python 3 里面已经弃用的 Python 2 语法，对这些部分简单带过不要花太多时间；</li>
<li>使用 Python 2，不要使用 Python 2.7 以前的版本；</li>
<li>使用 Python 3，不要使用 Python 3.4 以前的版本；</li>
<li>多了解 Python 2 的<code>__future__</code>库；</li>
<li>对同一份代码，不要为 Python 2 和 Python 3 分别维护分支，努力在一套代码中兼容 Python 2 和 Python 3。</li>
</ul>
<p>根据以上建议，我在 Anaconda 配置了 2.7.13 和 3.6.0 的两种版本。当然这份回答里最重要的还有一句话：</p>
<p><strong>stop talking, just do it！</strong></p>
<p>这一篇大概就讲这么些废话。人生苦短，我用 Python，常听到这句话，现在我就来体验啦！</p>
]]></content>
      <categories>
        <category>翻滚吧大学生</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>写在博士生开始前</title>
    <url>/blog/before-being-a-PhD-candidate/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/know-nothing-without-writing-papers.jpg"></p>
<p>这周末就是博士生开学典礼了，对自己的近况进行一个简单的介绍与总结。</p>
<h2 id="近况"><a href="#近况" class="headerlink" title="近况"></a>近况</h2><p>这一学年的显式收获是一篇 CIKM 2019 的 short paper。在经过 IJCAI 以一个大概 borderline 的分数被拒、拆出一部分当作本科毕设后，这份工作终于可以准备收尾了。同时，我也要去寻找一个能够支撑我整个博士生研究的新方向了。</p>
<p>为什么不再做当前的时间序列分析方向了？简单来说，单纯的时间序列所包含的信息量较少，简单而更具有可解释性的一系列传统方法已经有很好的表现。在这种情况下，使用深度学习来进行预测或者分类不一定能够表现更好，同时还会有解释性差、计算量大等问题。另外一点是，时间序列分析目前确实不是学术界研究热点，它可能更适合有大量可用数据的工业界研究人员进行挖掘来真正创造经济效益，而不适合作为一个只能用着开源数据集、还需要在一个研究领域耕耘至少五年的博士生的选题。</p>
<p>能中论文，当然会陷入短暂的兴奋中。但是收到邮件没过半天，我又回到沮丧的常态中。首先邮件中的评审意见里对这篇论文列举了很多问题，大多数都是我早已心知肚明的：没有在更多更大的公共数据集上进行实验、没有用实验证明我们的方法到底适用于有什么特点的数据、没有展现参数的设置如何影响模型的总体表现，等等。总而言之，没有对论文中提出的每个结论设计缜密的实验来证明。</p>
<p>更为深层的原因是，在这个月里，我渐渐发现这一年我好像并没有什么什么实质的进步。我仍然效率低下、没有做好时间管理、经常废弃既定的学习计划，作息紊乱、无法集中注意力、迷失在杂乱的信息流中，得过且过、不求甚解。看似阅读了很多论文，了解了一个领域，研究出一种方法，发表了一篇会议。实际上每次随便找了两篇论文浅浅看过就开始拿别人的东西堆叠想模型，对整个领域/方向/任务没有将顶会论文全部搜查一遍，对共性问题没有深入思考，甚至连 evaluation metrics 该采用哪些为什么都没有总结和思考过。最终的结果就是，成长速度奇慢。</p>
<h2 id="博一的主要目标"><a href="#博一的主要目标" class="headerlink" title="博一的主要目标"></a>博一的主要目标</h2><ol>
<li>最主要的目标当然是把所有课程顺利修完。</li>
<li>对未来的研究方向进行考察。考虑因素包括（在五年后）有较好的发展前景、对外部条件要求不高、出成果不是非常困难、符合自己兴趣。考察过程中要全面地了解领域现有任务、问题、方法、领军学者/机构。</li>
<li>夯实理论基础。每次选定书/课学习就坚持下来，控制在一个月内学习完成。回想一下，本科阶段最大的提升之一就在于坚持修完了吴恩达深度学习课程。</li>
<li>通过论文复现练习和数据竞赛来提高编程、调参等水平。数据竞赛方面的最终目标在 Kaggle 能在一场比赛中持续参加并获得银牌以上。</li>
<li>能够及时将感兴趣的论文/blog 消化到能和别人随口讲清楚的程度。每周尽量读一篇和当前研究方向不太相关的、近期顶会的 best paper 或者引起广泛讨论的 paper，来理解并吸收其他领域的思路。</li>
<li>发表一篇自己较为满意、对领域有贡献的论文。</li>
</ol>
<p>最后，我在考虑把博客翻修一下。</p>
<!--## 给自己的十五问

需要定期对自己进行反思：

1. 最近看了些什么（论文、blog 等）？这些东西是否能给别人随口讲明白，是否能归纳成类（有一条思维的线连着）？看的深不深，能不能说自己对这方面是专家？
2. 与之前相比，所需的能力有没有提高？增长大不大，提高快不快？
3. 对领域了解是否更深入？对已有工作的调研是否全面完善？
4. 读论文在保证质量的同时有没有更快速？有没有将笔记完整记录？要对每一个细节都提出质疑：为什么要加这个模块/步骤/算法？去掉行不行？它起到的作用是不是就是作者说的作用，什么实验证明了这一点？同时读代码
5. 对算法、模型、解决方案、实验的设计是否更完善？每个细节的设置都能说明原因？对于要验证的结论是否都有对应的实验？
6. 数学水平是否提高，能够严格解释算法中的细节在数学上的原因？
7. 代码写的是否更高效？对同一任务是否有一套较为完善的 pipeline 可以复用？是否保证最终的代码都完善导到可开源级别？每天花 1-2 小时阅读论文，然后花一天时间编写代码来进行实验
8. 对数据是否更有感觉（有一套方案对数据进行判断，分析数据存在的可以解决的问题【即别的算法没有关注到的可创新点】和 bias）？ 
9. 论文写的是否更顺畅，更独立，大改次数更少，可读性更高？排版和配图更好看？
10. 口头报告是否做的更好？能用全英文？更吸引人？blog 同理，语言是否顺畅，条理是否清晰，是否有自己的思考、最新的内容？
11. 是否将自己对外展示地更好？包括个人主页、blog、github、知乎等。提高自己和整个组的影响力
12. 是否提高了自己的协作水平，和他人能够在同一项目中按照长处合理分配任务，及时交流？
13. 自己的交际能力是否提升？能否主动和学术会议上认识的朋友、研究课题的国内外相关学者交流？
14. 是否健康饮食作息，锻炼身体，提高了自己的身体素质和精神专注力？是否提升了其他爱好的水平？
15. 是否能够对抗 peer pressure 和 self pressure、焦虑？是否保持积极的态度、饱满的精神？-->]]></content>
      <categories>
        <category>翻滚吧博士生</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>未来展望</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>越过山丘——写在大四开始时</title>
    <url>/blog/over-the-hills/</url>
    <content><![CDATA[<p>在保研尘埃落地、回学校参加院队热身赛结果弄伤膝盖、从十一假期养到现在，终于提笔开始写这一篇博客。现在已经是十月中旬，开学都已经一个半月了，但对我来说，大四似乎才刚刚开始。且简单地和大家分享一下我保研的结果和做出决定的一些想法，也给自己即将面临的新挑战打个气。</p>
<span id="more"></span>

<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>先谈一下我最终的选择吧：浙江大学和西湖大学的跨学科联合培养博士生项目，计算机科学与技术专业。也就是说，我明年这个时候就是一名博士生了。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/over-the-hills/postgraduate-recommendation-result.jpg"></p>
<p>简单地说一下我的保研经历。在夏令营周期中，我比较遗憾没拿到任何让我满意的 offer。而在九月本校保研资格公示后，我又因为复旦的报名系统已关闭而错过这所我心心念念的学校（结果我选择联培学校时最终也没选择复旦，哈哈）。因此，留给我可供选择的学校和导师都不太多了。</p>
<p>其实我最终拿到了很不错的综合排名，因此很多同学和学长学姐都鼓励我申请清北。但我最终没有在九月再申请清北，原因包括当然包括学校层面的难度较大，但更深层的原因有二，一是我知道清北的好导师竞争激烈程度到清北本科生都需要先在其实验室长时间工作才有机会，而导师是我在做选择中最看重的因素；二是我在暑假去北京时，感受到很明显的与这座城市的隔离感，且气候对我也不太友好，待的很不舒服。鉴于以上原因，考虑到专心准备比较有把握的学校的考核，我做出了上述的抉择，而且我现在仍觉得这是正确的做法。</p>
<p>在九月我最终申请了三所学校的计算机专业：浙大硕士、上海交大硕士和西湖大学联培博士（目前西湖大学只有博士生项目），严格意义上三所学校的 offer 我都拿到了。浙大是 9 月 27 日晚上给我发的邮件，但由于 9 月 28 日志愿填报系统开放，所有学校都要求当天走完所有填报流程，而我之前联系的浙大老师没有再回复我，因此我在浙大本校没有联系好的导师；上海交大一开始通知我没过，但 9 月 30 日又来电说有少量硕士名额，此时我早已被西湖大学录取，只可惜之前和上海交大 SpeechLab 的俞老师已经有比较深入的沟通，而且 SpeechLab 的研究方向和研究理念我都非常喜欢，最终遗憾错失这个机会。</p>
<p>攻读直博是半年前的我可能没法想象到的选择，因为我其实一直是想着先读硕士，之后看情况是能够去国内外更好的地方继续深造或者想直接就业，因此申请各校时基本都填报的是硕士。那么，为什么是西湖大学的博士生？我想，原因肯定包括 27 日下午就确定录取以及未来的导师、西湖较好的住宿和待遇、对杭州本身的喜爱，但是起决定性作用的还是以下几点：</p>
<ul>
<li><strong>西湖有非常优秀的老师和同龄人</strong>：老师自然不必说，基本都是从全世界各个高校引入的才俊。而我在西湖遇到的同届同学以及学长学姐也都非常优秀。这轮招生都是招收保研本科生，而工学院录取的同学中，有一半以上已经发表过高质量的论文，其余的同学（除开我）也都有专利等成果。在 27 日的晚上，我们很多同学在宿舍的走廊非常自然而愉快地聊了一场大天，来自天南地北不同学校、工学化学生物等不同专业的同学相互自我介绍、聊理想聊规划聊各色各样，这种氛围真的非常吸引人。说实话，作为一个可以说没有科研基础的学生，与这些同学共处有一定的压力。但是我相信在这样的环境才能更好地成长，也能更开心地学习与工作。</li>
<li><strong>作为西湖的建设者有更大的挑战</strong>：在知道我最终决定去西湖大学就读时，我父亲在电话非常严肃地说你等一等，随即询问几名同在高校工作的朋友来确定西湖是否“靠谱”。我理解西湖大学作为一所民办大学、一个刚起步的改革探索者，目前才有两届学生入学，在大众眼里和清北复交浙等传统名校会有一定的差距。但我觉得能够见证与参与这所研究型机构的初创期是一个非常难得的事情。这样的环境中的老师和同学们会更有个性和活力，大家都会成为学校的建设者。因此，我十分愿意和西湖大学一起迎接挑战。</li>
<li><strong>我的导师具备科研实力和学生培养能力</strong>：其实我最终确定的导师不是我一开始的目标导师。我一直是希望能够在 NLP 方向开始研究，因此一开始联系的是在此领域名声在外的张老师，但是本轮张老师唯一的名额给了一名暑假在他那实习并且出了一篇顶会 paper 的优秀同学。工学院的王老师第一次与我见面是在武大的招生宣讲会上，当时他叮嘱我一定要按时申请。而在西湖面试结束后，他非常诚恳地和我聊，希望我能够去他那里。我们的沟通都非常顺畅，我认为王老师有足够的耐心让我从零起步开始科研、给我足够的条件和重视、并且能够支持我在大方向下自由探索。因此，我愿意放弃（至少是目前阶段）我最喜欢的 NLP 方向，以及背负一定直博带来的风险。我相信这是值得的。</li>
</ul>
<p>综上所述，我最终决定在西湖大学开始我的下一个阶段。感谢在保研过程中非常多的老师、同学、学长学姐给了我很多建议和帮助。希望我能够不忘初心，终有所得。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/over-the-hills/WIAS.jpg"></p>
<h2 id="大四计划"><a href="#大四计划" class="headerlink" title="大四计划"></a>大四计划</h2><p>我目前计划是下周前往西湖高等研究院，开始在实验室里实习。还有一周的时间，这一周我计划是加强机器学习基础、调整自己的作息，以及处理完学校的一些事务。</p>
<p>而在大四这一年，我目前有这样的一些计划：</p>
<ol>
<li>打好专业基础和研究基础，包括数学、机器学习的知识和论文阅读笔记等等；</li>
<li>适应实验室的生活，积极参与研究项目；</li>
<li>提前准备毕业论文，以寻找未来的研究方向；</li>
<li>学习英语，可以考虑屠一个雅思/托福/GRE；</li>
<li>养成并坚持早睡早起的作息习惯，适当注意保养脸和头发:)；</li>
<li>认真打一次 Kaggle 的正式比赛，争取能够到前 10%，从而对 Python 代码编写、开源框架的使用、数据科学项目的思路以及优化的技巧都有一个极大的锻炼；</li>
<li>啃完 3-4 本技术书籍，并在 Github 上拥有一个 100+ star 的技术性项目；</li>
<li>看几本以前想看但是没抽时间看的书，例如《娱乐至死》、《乌合之众》、《我的职业是小说家》、《仿生人会梦见电子羊吗？》等。电影也可以选择性看看，最好能认真写几篇点评:)；</li>
<li>去武大里没去过的地方看看，计划一场毕业旅行；</li>
<li>向学长学姐了解博士生的生活，询问他们的规划，构建自己的蓝图。</li>
</ol>
<p>其实之前写在博客上的好多计划最后也就执行了大概一半，希望这一次能够努力实现吧。</p>
<!--## 博士生阶段规划

暂时写不出来了。嘻嘻，主要还是争取很多高质量的 paper，开会 social、交流、合作，增加出国和实习经历吧。

[](https://www.zhihu.com/question/274824864/answer/504505852)-->
]]></content>
      <categories>
        <category>翻滚吧大学生</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>未来展望</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>花旗杯-新的终点，新的起点</title>
    <url>/blog/new-end-new-start/</url>
    <content><![CDATA[<p>在从成都回武汉的火车上开始写这一篇博客。</p>
<p>历时共七个月的花旗杯终于结束了。作为创队元老，我从头到尾参与了这个项目，从每个组员的奇思妙想中挖掘出我们现在的选题，在一次次的争论中始终坚持它就是最好的选择。我也投入了大量的时间和精力，写完了整个网站前端开发的每一行代码，并参与了部分的算法研究工作。整个项目也数次从被放弃的边缘拉回来，成员也有一定的变动，可以说历经波折。</p>
<p>到达成都后，临行前请人算了一卦的浦先生幸运地抽到答辩的最后一位，这让我们可以观摩其他队伍的答辩、对评委的关注点进行揣摩，并有较为充足的准备时间。之后，前往成都的核心队员开始昼夜不分地修改项目计划书、PPT、展示讲稿等各种材料，直到上台答辩的最后一秒。这个过程中，另外四名成员应该比我要更为辛苦，在答辩前一夜，负责算法的曹队和冯大佬更是直到凌晨三点还在讨论评委可能提出的问题（他们也确实命中了绝大部分问题，功居甚伟），而王同学也果断承担起本来属于队长的项目展示的重任。在这样的准备强度下，尽管也有遗憾，我对我们组的答辩表现可以打到 100 分，也为我们的付出感到骄傲。</p>
<p>最终，我们的“探方网——网络文学 IP 价值评估及预测系统”获得了第十三届“花旗杯”金融创新应用大赛的三等奖。可惜的是，我们是最后一个宣布的三等奖，也就是说离二等奖仅有一步之遥。但能在全国二十强中最终名列第四，也是大赛诸多评委老师对我们项目极大肯定。</p>
<p>从比较现实的角度来看，这次参赛经历带给我个人大学期间第一个有分量、对保研有加分的奖项，以及一点和劳动量好像不太对等的奖金。当然，我还有一些对我而言更为重要的东西与看到这篇博文的每一位分享。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/huaqi-prize.jpg" alt="huaqi-prize"></p>
<span id="more"></span>

<h2 id="参加比赛的经历"><a href="#参加比赛的经历" class="headerlink" title="参加比赛的经历"></a>参加比赛的经历</h2><p>在成都备战的深夜里，几名核心大佬都表示“再也不参加花旗杯这样的非技术类比赛了”。“非技术类”确实对花旗杯是一个不太正当的评价，但准备花旗的开发周期之长、团队管理之累、准备工作之繁琐，对我们这些软件工程专业的 nerd 来说，是醉心于技术的阻碍。我们花了相当比例的精力在项目的包装上，而在实际技术层面可能没有达到我们想要的高度。</p>
<p>但我还是很享受这个过程，因为比起纯粹的技术人员，我感觉可能我会更多地接触，也更为喜欢这样的项目包装、推广过程。我认为没有任何一个成功的项目能够单纯成长在技术的温室中，项目的包装是项目真正成为<strong>产品</strong>所不得不经历的工作。通过这样的工作，让技术人的智慧成果被更多人了解、使用和赏识，我认为这是十分有意义的。何况，在花旗的答辩场上，金玉其外、败絮其中的项目都被资深的评委老师们毫不留情地迅速戳破。</p>
<p>整个过程确实很累很苦，尤其是最末期，网站的前端基本上一天加好几个功能，我也很骄傲我坚持了下来。在走出答辩场地后，我们五个人在楼下花旗杯决赛的展牌前合影。在空间 po 出照片时，我配的字是“我感觉毕了业”。因为我在那一刻的感觉大概和《中国有嘻哈》欧阳靖在结束最后一次的表演时一样，如释重负，而又如获新生。</p>
<p>看看自己的码云，整个前端项目都是我的 commit，哈哈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-472d42ef0cb3ff5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="huaqi-commit.jpg"></p>
<p>这次花旗杯的参赛经历对我来说是一次十分难忘的经历，在前端技术层面上有机会接触到很多新东西和新问题，提升很大。鉴于国软院有通知渠道并推荐参加的有含金量的比赛确实不多，我十分推荐学弟学妹们参加花旗杯。当然，下一届的学弟学妹如若进入决赛，大概要去东北挨冻了。另外，我也很欢迎有学弟学妹在明年联系我，作为项目方向、团队管理、答辩展示的一个咨询人员。</p>
<h2 id="团队开发的经验"><a href="#团队开发的经验" class="headerlink" title="团队开发的经验"></a>团队开发的经验</h2><p><img src="/images/huaqi-team.png" alt="huaqi-team"></p>
<p>这次花旗杯应该就是我本科中第一次，也是最后一次相对来说的大型团队开发项目了。数十人的团队开发在大学里是十分难得的经验，我也学到了很多，尤其是那些我们没有做的很好的环节，例如分工、沟通、日程规划等。以下是几条建议：</p>
<ul>
<li>队长应该<strong>主动</strong>和各部分负责人沟通，确定进度。</li>
<li>工作分配和修改必须要明确到人，并且利用好在线可查看可修改的备忘文件，例如石墨文档等。</li>
<li>日程规划应在与各负责人协调的情况下，预留一定的缓冲时间。</li>
</ul>
<p>作为最初始的成员，我看着团队成员不断增加，也看到有些成员因为各种原因自己选择退出了这个项目。对于中途退出的成员，我们虽然没有给他们前期的努力以回报，但理解他们并心存感激；但我也看到有极少部分成员对这个项目缺少投入。不论是因为确实身兼数职、分身乏术，还是企图偷懒、不劳而获，我都认为这是缺乏责任心的表现。我理解在接近七个月的项目开发中，感到怠惰、信心不足是正常的表现，我自己也有过这样的心理。但是在整个项目中，如果你所做的努力远远少于其他人，最终却分享同样的荣誉，这不但拖累了项目的进度，对整个项目组的士气更有着极其不良的影响。因此，选择团队成员也是修行的一种，而及时止损也是选择的一种。</p>
<p>对我自己来说，由于我个人的交际不是很广，没有太多的参与这次项目成员的挑选过程。通过这次经历，我也认识到广交朋友的益处，会努力在保证交友质量的前提去结识更多人。另外，在以后的项目开发中，我希望在个人技术水平达标的前提下，我能够承担起组长的重任，让整个团队有更好的开发积极性和管理秩序，同时挑战自我，获得进步。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在这七个月里，我也对自己的性格缺陷进行了审视。我不太好意思向大家列举这些性格缺陷，但它们使我在包括花旗项目在内的学习过程中，甚至是在大学生涯的为人处事、个人发展等各方面遇到了不少挫折。我对未来我在性格方面的改善和转变有一些期许。我也不是很喜欢我现在的生活方式，希望能让它变得更加多彩。</p>
<p>我走到了花旗杯的终点。但对我来说，还有很多的起点。我希望在未来的日子里，我能够更加坚定、更加拼搏、更加成熟、更加不甘平庸。这很难，我希望我能够做到。</p>
]]></content>
      <categories>
        <category>翻滚吧大学生</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>花旗杯</tag>
      </tags>
  </entry>
  <entry>
    <title>虎山行</title>
    <url>/blog/escorts-over-tiger-hill/</url>
    <content><![CDATA[<p><strong>更新</strong>：10 月 26 日我跟朱老师进行了一次时间较长的近期学习成果展示，并且对于接下来的学习方向聊了一会。结合花旗杯进入决赛的事情，将此文做一次更新。</p>
<hr>
<p>这段时间博客更得不勤，因为实在太忙。解释器构造、系统级程序设计、Spark、公选课作业、算法、英语、大创…每天睁开眼睛就想起这么多学习任务，让人不免感觉身在虎山，危机四伏，战战兢兢。</p>
<p>只有在这种强度的学习压力下，才会发现自己的很多问题，其中最致命的就是自己的学习效率太低了，很难集中注意力去解决手头即时的任务。快速学习和解决问题的能力是程序员必备之一，我在这方面可以说不及格。再就是还有惰性心理，浮躁，不能保持健康的作息，以至于高效学习的时间不足。</p>
<p>同时，每天忙碌的同时也会胡思乱想：我真的适合读研吗？自己学习前端知识的时候还是比较开心的，和现在学习 Spark 的态度可能还是有一些差别，并且也在要不要向机器学习方向深入学习而犹豫。读研以后，不是说完全不可能，但是基本上以后就不会从事前端领域的工作了。确定喜欢的领域和确定喜欢的人一样，难以割舍的感觉似有若无。但是对我来说，父母和老师都给了很大的期望，自己也没有做好找工作的准备，争取保研是箭在弦上，不得不发。我能做的，只有将弦拉的更满，箭一发便是千钧之力，穿越更高的云霄。</p>
<p>现在确实有些迷茫，每天过的感觉不到自己有实打实的进步。希望狮子座的天性能够帮助我顺利度过这段大学最忙碌也最缥缈的时期。</p>
<h2 id="定期任务"><a href="#定期任务" class="headerlink" title="定期任务"></a>定期任务</h2><h3 id="每天"><a href="#每天" class="headerlink" title="每天"></a>每天</h3><ul>
<li>一道 LeetCode</li>
<li>六级单词</li>
</ul>
<h3 id="每周"><a href="#每周" class="headerlink" title="每周"></a>每周</h3><ul>
<li>《算法》一节</li>
<li>Coursera 华盛顿大学《机器学习基础：案例研究》课程一节（尽早刷完这个）[已完成]</li>
<li>六级练习题若干（有时间可以做一整套题）</li>
<li>一篇会议论文阅读（abstract 和 introduction）［按照标准认真读，做一些简短的笔记］</li>
<li>12 月后<a href="http://wdxtub.com/2016/04/16/thin-csapp-0/">读薄 CSAPP 系列</a>每周两篇</li>
</ul>
<h2 id="学期计划"><a href="#学期计划" class="headerlink" title="学期计划"></a>学期计划</h2><p>给这个最重要的学期列一个总体的学期计划。</p>
<h3 id="课业"><a href="#课业" class="headerlink" title="课业"></a>课业</h3><p><strong>三门必修课</strong>，解释器构造实验以及系统级程序设计的理论和实验课，<strong>必须满绩</strong>。</p>
<h3 id="花旗"><a href="#花旗" class="headerlink" title="花旗"></a>花旗</h3><p>一个月的时间，逼自己尽全力去争取最好的结果。</p>
<h3 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h3><p>积极完成朱老师布置的任务，并且和他交流。也要关心组里其他同学的工作。</p>
<p>朱老师建议我先学习机器学习的应用。根据这个建议，我把对吴恩达的《机器学习》课程的学习计划暂时改为华盛顿大学《机器学习基础：案例研究》课程的学习。这门课更偏重实际应用，也可以避免我绕到数学内容里。</p>
<h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>阅读朱老师推荐的会议，积累感觉找方向。多和朱老师交流心得。</p>
<p>每周抽时间细看一篇，也算是练习英语阅读。重点读 abstract 和 introduction。可以参考 <a href="https://zhuanlan.zhihu.com/p/29568504">[Paper Reading] Efficient Estimation of Word Representations in Vector Space</a> 的格式来做笔记。为了督促自己，可以考虑申请一个新的知乎专栏或者在 PaperWeekly 做笔记。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>每天一道 LeetCode 加上自己控制页数的《算法》阅读。下学期可以做九度 OJ 和北大 OJ 练手。</p>
<h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>不要放弃六级，老师们都很看重英语能力。每天还是要抽时间背背单词，有时间练习一下听力、翻译、阅读、作文等。<strong>题目重在整理，而非数量。</strong></p>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><p>有时间自己做一些开源小项目。没时间就算了，还是以自己参与度较高的科研项目为重。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>暂时考虑按照以下路径，这个学习肯定搞不定，但是要自己把握进度：</p>
<ol>
<li>学完 Coursera 华盛顿大学《机器学习基础：案例研究》课程并完成所有作业</li>
<li>通过《利用Python进行数据分析》的阅读学习，掌握 sklearn、numpy、pandas、matplotlib 的使用</li>
<li>吴恩达《机器学习》课程：绕不开的必修课</li>
<li>建立大局观的书籍：中文：周志华老师的西瓜书《机器学习》和李航老师的《统计学习方法》；英文：《Patten Recognition and Machine Learning》，《Elements of Statistical Learning》</li>
<li>kaggle、阿里巴巴天池实战</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>组队参加美赛。抽时间了解一下赛事信息和要求。有时间点一些技能点。</li>
<li>可以考虑申请软件著作权（当然要有比较好的项目）。</li>
<li>坚持把日记给记好。</li>
</ul>
<p>忙乱时方显修为，管理好自己的时间，专心于自己的事业。自己能走多远，很大程度上取决于这个学期。</p>
<blockquote>
<p>那就继续人间游 虽说不太平<br>明知山有虎 偏向虎山行</p>
<p>—  GAI / 艾福杰尼 / Kungfu-Pen 《虎山行》</p>
</blockquote>
]]></content>
      <categories>
        <category>翻滚吧大学生</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(一)</title>
    <url>/blog/es6-1-notes/</url>
    <content><![CDATA[<p>《ECMAScript 6 入门》是一本 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。作者阮一峰大佬慷慨地选择将全书开源：<a href="http://es6.ruanyifeng.com/#README">ECMAScript 6 入门</a>。将知识点简便地总结一下，以供后续使用时参考或复习。</p>
<p>此博文包括：let 和 const 命令、变量的解构赋值、字符串的扩展、正则的扩展、数值的扩展、数组的扩展。</p>
  <span id="more"></span>

<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><p>1.<code>let</code>：<code>let</code>声明的变量仅在块级作用域内有效。不存在变量提升；存在暂时性死区，只能在声明的位置后面获取和使用；相同作用域内不可重复声明。</p>
<p>2.块级作用域：外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。</p>
<p>3.根据ES 6附录B的规定，在浏览器的ES 6环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。应避免在块级作用域内声明函数，或用函数表达式代替函数声明语句。</p>
<p>4.do 表达式：在块级作用域之前加上<code>do</code>，使其变为表达式（可以返回值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量x得到整个块级作用域的返回值</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = f();</span><br><span class="line">    t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.<code>const</code>：声明一个只读常量。一旦声明，就必须立即初始化。和<code>let</code>一样，只在声明所在的块级作用域内有效；声明的常量不提升；存在暂时性死区；不可重复声明。</p>
<p><code>const</code>保证变量指向的内存地址不可改动。因此将对象声明为常量时，不可变的只是地址，对象本身可变，可以为其添加新属性。</p>
<p>如果真想将对象冻结，应用<code>Object.freeze()</code>方法（对象本身和 其属性都应冻结）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            constantize(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6.顶层对象的属性：<code>let</code>、<code>const</code>、<code>class</code>声明的全局变量不属于顶层对象的属性。</p>
<p>补充资料：<a href="https://blog.fundebug.com/2017/05/04/why-you-should-not-use-var/">ES6之”let”能替代”var”吗?</a></p>
<h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><p>1.解构：按照一定模式，从数组和对象中提取值，对变量进行赋值。解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br><span class="line">foo <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>2.不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<p>3.解构赋值允许指定默认值。ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值不会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果默认值是一个表达式，那么这个表达式是惰性求值的（用到时才会求值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x能取到值，所以函数f根本不会执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>4.要将一个已经声明的变量用于解构赋值时，将大括号写在行首会导致JavaScript引擎将其解释为代码块，从而发生语法错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;  <span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h3><p>5.对象的解构：属性没有次序，变量取值由名称决定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo&#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo  <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar  <span class="comment">// &quot;bbb&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果变量名与属性名不一致，须写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz&#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span>&#125;;</span><br><span class="line">baz  <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f  <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l  <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p>6.解构也可用于嵌套结构的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">p</span>: [</span><br><span class="line">        <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;]&#125; = obj;</span><br><span class="line">x  <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y  <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="comment">// 这时p是模式，不是变量，因此不会被赋值。</span></span><br><span class="line">p  <span class="comment">// error: p is undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的结构赋值"><a href="#字符串的结构赋值" class="headerlink" title="字符串的结构赋值"></a>字符串的结构赋值</h3><p>7.此时字符串被转化成一个类似数组的对象，且具有<code>length</code>属性（可以针对此属性解构赋值）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a  <span class="comment">// &quot;h&quot;</span></span><br><span class="line">e  <span class="comment">// &quot;o&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="数值、布尔值的结构赋值"><a href="#数值、布尔值的结构赋值" class="headerlink" title="数值、布尔值的结构赋值"></a>数值、布尔值的结构赋值</h3><p>8.解构赋值的规则：只要等号右边的值不是对象或数组，就先将其转为对象。<code>undefined</code>和<code>null</code>无法转为对象，所以对它们解构赋值都会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数的结构赋值"><a href="#函数参数的结构赋值" class="headerlink" title="函数参数的结构赋值"></a>函数参数的结构赋值</h3><p>9.为函数<code>move</code>的参数指定默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;);  <span class="comment">// [0, 0]</span></span><br><span class="line">move();  <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<p>为变量<code>x</code>和<code>y</code>指定默认值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;x: <span class="number">0</span>, y:<span class="number">0</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;);  <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;);  <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;);  <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move();  <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>10.ES6规定，只要可能导致解构歧义，就不得使用圆括号。由于这条规则不易辨别，因此建议尽量不要在模式中放置圆括号。</p>
<p>11.以下三种解构赋值不得使用圆括号。</p>
<ul>
<li>变量声明语句中，不能带有圆括号。</li>
<li>函数参数中，模式不能带有圆括号。</li>
<li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li>
</ul>
<p>12.可以使用圆括号的情况：赋值语句的非模式部分，可以使用圆括号。</p>
<p><strong>用途</strong></p>
<ul>
<li>交换变量的值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<ul>
<li>从函数中返回多个值：将返回的数组或对象中的值取出</li>
<li>函数参数的定义：方便地将无序的参数与变量名对应</li>
<li>提取JSON数据：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">424</span>, <span class="number">5920</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 24, &quot;OK&quot;, [424, 5920]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数的默认值</li>
<li>遍历Map结构：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输入模块的指定方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>1.字符的Unicode表示法：将码点放入大括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span>  <span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span>  <span class="comment">// &quot;ABC&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.新增一些方法：</p>
<ul>
<li><code>codePointAt()</code>：能够正确处理4个字节储存的字符，返回一个字符的码点。是测试一个字符由两个字节还是由四个字节组成的最简单方法。</li>
<li><code>String.fromCodePoint()</code>：用于从码点返回对应字符，可识别Unicode编号大于0xFFFF的码点（32位的UTF-16字符）。</li>
<li><code>at()</code>（提案）：返回字符串给定位置的字符，可识别Unicode编号大于0xFFFF的码点。</li>
<li><code>repeat(n)</code>：返回一个新字符串，表示将原字符串重复n次。</li>
<li><code>normalize()</code>：将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</li>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
<li><code>padStart()</code>：如果某个字符串不够指定长度，会在头部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串（默认为空格）。</li>
<li><code>padEnd()</code>：同上，用于尾部补全。</li>
</ul>
<p>3.模版字符串：常用于定义多行字符串，或者在字符串中嵌入变量。用反引号（`）标识。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript &#x27;\n&#x27; is a line-feed.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Kyon&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br></pre></td></tr></table></figure>

<p>模板字符串中嵌入变量，要将变量名卸载<code>$&#123;&#125;</code>中。大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，也可以调用函数。</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串（例如对象调用<code>toString</code>方法）。</p>
<p>4.标签模板（功能）：函数调用的一种特殊形式。模板字符串作为参数紧跟在一个函数名后，该函数被调用以处理该模板字符串。常用于转义特殊字符和多语言转换（国际化处理）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log<span class="string">`Kyon`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Kyon&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>模板字符有变量时，先把模板字符串处理成多个参数。处理得到的第一个参数是一个数组，包含那些没有变量替换的部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27; world&#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性，保存转义后的原字符串。</p>
<p>5.<code>String.raw()</code>：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串；如果原字符串的斜杠已经转义，则不会做任何处理。常用于处理模板字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">3</span>+<span class="number">4</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// &quot;Hi\\n7!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// &#x27;Hi\\u000A!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>也可作为正常函数使用，第一个参数应是具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应是一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">&#x27;test&#x27;</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// &#x27;t0e1s2t&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>6.模板字符串的限制（提案）：放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。</p>
<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><p>1.<code>u</code>修饰符：Unicode 模式，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。对于码点大于<code>\uFFFF</code>的 Unicode 字符，点字符(<code>.</code>，除了换行符外的任意单个字符)、Unicode 字符表示法（使用大括号表示 Unicode 字符）、量词、预定义模式（<code>\S</code>，匹配所有不是空格的字符）必须加上<code>u</code>修饰符才能识别。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>2.<code>y</code>修饰符：“粘连”修饰符，全局匹配，但须确保匹配必须从剩余的第一个位置开始。一个应用是从字符串提取 token（词元），<code>y</code>修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>3.ES 6 的正则对象新增了<code>sticky</code>属性和<code>flags</code>属性，分别表示是否设置了<code>y</code>修饰符以及返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky  <span class="comment">// true</span></span><br><span class="line">r.flags  <span class="comment">// &#x27;y&#x27;</span></span><br></pre></td></tr></table></figure>

<p>4.有一些提案。因为我暂时对正则不太熟悉，所以略过。</p>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><p>1.二进制、八进制表示法：分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。用<code>Number()</code>方法将其转化为十进制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0b111&#x27;</span>)  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>2.新增 Number 对象上的一些方法：</p>
<ul>
<li><code>Number.isFinite()</code>：用于检查一个数值是否为有限的。</li>
<li><code>Number.isNaN()</code>：用于检查一个值是否为<code>NaN</code>。</li>
</ul>
<p>与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<ul>
<li>将全局方法<code>parseInt()</code>和<code>parseFloat()</code>移植到 Number 对象上，行为完全保持不变，目的是逐步减少全局性方法，使得语言逐步模块化。</li>
<li><code>Number.isInteger()</code>：用于判断一个值是否为整数。在 JavaScript 内部，整数和浮点数是同样的储存方法，这个方法都会返回 true。</li>
</ul>
<p>3.<code>Number.EPSILON</code>：极小的常量，表示一个可以接受的误差范围。浮点数计算误差小于<code>Number.EPSILON</code>时可以认为得到正确结果。</p>
<p>4.<code>Number.isSafeInteger()</code>：JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围的值无法精确表示。<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量用来表示这个范围的上下限。<code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<p>5.Math 对象的扩展：所有新增方法都是静态方法，只能在 Math 对象上调用。</p>
<ul>
<li><code>Math.trunc()</code>：用于去除一个数的小数部分，返回整数部分。对于非数值内部使用<code>Number</code>方法将其先转为数值；对于空值和无法截取整数的值，返回 NaN。</li>
<li><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。它会返回五种值：参数为正数，返回+1；负数返回-1；0返回0；-0返回-0；其他值返回NaN。</li>
<li><code>Math.cbrt</code>：用于计算一个数的立方根。</li>
</ul>
<p>此外，还有一些对数方法和三角函数方法。</p>
<p>6.指数运算符（<code>**</code>）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>  <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span>  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">a **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a * a;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><p>1.<code>Array.from()</code>：将类数组对象（本质特征是有<code>length</code>属性）和可遍历对象（部署了 Iterator 接口的数据结构，包括 ES 6新增的 Set 和 Map）转化为真正的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组；如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from()</code>的第三个参数，用来绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<p>2.<code>Array.of()</code>：返回参数值组成的数组（没有参数则返回空数组）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>)  <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)  <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<p>3.数组实例的<code>copyWithin()</code>：在当前数组内部，将指定位置的成员复制到其他位置（覆盖原有成员），然后返回当前数组。</p>
<p>接受三个参数（都为数值，否则自动转换）：</p>
<ul>
<li>target（必需）：从该位置开始替换数据；</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>4.数组实例的<code>find()</code>和<code>findIndex()</code>：</p>
<p><code>find()</code>用于找出第一个符合条件的数组成员。其参数为一个回调函数（可以接收三个参数：当前的值，当前的位置和原数组），所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员，否则返回<code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p><code>findIndex()</code>类似，返回第一个符合条件的数组成员的位置，否则返回<code>-1</code>。</p>
<p>5.数组实例的<code>fill()</code>：用给定值填充一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组中原有的元素将被覆盖</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)  <span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以接受两个参数，用于指定填充的起始位置和结束位置</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)  <span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>6.数组实例的<code>keys()</code>、<code>values()</code>和<code>entries()</code>：用于遍历数组。都返回一个遍历器对象，可以用<code>for..of</code>循环进行遍历；区别为分别对键名、键值、键值对遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>7.数组实例的<code>includes()</code>（属于ES 7 但 Babel 转码器已经支持）：返回一个布尔值，表示某个数组是否包含给定的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);  <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span> ,<span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>8.数组的空位：和<code>undefined</code>不同，数组的空位没有任何值。ES 5 对空位的处理规则很不一致（大多数情况会忽略）；而 ES 6 明确将空位转为<code>undefined</code>。尽管如此，建议避免出现空位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScipt</tag>
        <tag>ES 6</tag>
        <tag>《ECMAScript 6 入门》</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>《ECMAScript 6 入门》读书笔记(二)</title>
    <url>/blog/es6-2-notes/</url>
    <content><![CDATA[<p>说实话，ES 6 新特性真的不少。感觉全部记下来都很难，更别谈消化了。继续啃《<a href="http://es6.ruanyifeng.com/#README">ECMAScript 6 入门</a>》。希望能早日啃完，想去看 Vue.js 了…</p>
<p>此博文包括：函数的扩展、对象的扩展、Symbol、Set 和 Map 数据结构。</p>
  <span id="more"></span>

<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>1.ES 6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>)  <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;Kyon&#x27;</span>)  <span class="comment">// Hello Kyon</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与解构赋值默认值结合使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;)  <span class="comment">// 1, 5</span></span><br><span class="line">foo()  <span class="comment">// TypeeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1() <span class="comment">// [0, 0]</span></span><br><span class="line">m2() <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x有值，y无值的情况</span></span><br><span class="line">m1(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;) <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x和y都无值的情况</span></span><br><span class="line">m1(&#123;&#125;) <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;) <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明；使用参数默认值时，函数不能有同名参数。</p>
<p>定义了默认值的参数通常应该为函数的尾参数。</p>
<p>2.函数的<code>length</code>属性：将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，后面的参数也不会被计入。</p>
<p>3.作用域：一旦<strong>设置了参数的默认值</strong>，函数进行声明初始化时，参数会形成一个单独的作用域。等到初始化结束，作用域消失。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数foo内部声明的内部变量与参数不是同一个作用域</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>()&#123; x = <span class="number">2</span>; &#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// 3</span></span><br><span class="line">x  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>()&#123; x = <span class="number">2</span>; &#125;</span>)</span>&#123;</span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// 2</span></span><br><span class="line">x  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>4.函数参数默认值的应用：可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeprovided = throwIfMissing()</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// throwIfMissing函数名之后有一对圆括号</span></span><br><span class="line"><span class="comment">// 表明参数的默认值不是在定义时执行，而是在运行时执行</span></span><br><span class="line"><span class="comment">// 即如果参数已经赋值，默认值中的函数就不会运行</span></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure>

<p>可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<p>5.rest 参数：形式为”…变量名”，用于获取函数的多余参数。rest 参数中的变量代表一个数组。rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>

<p>函数的<code>length</code>属性，不包括 rest 参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,...b</span>)</span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数的默认值-1"><a href="#函数参数的默认值-1" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>6.扩展运算符：<code>...</code>，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">35</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 39</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不再需要 apply 方法将数组转为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>)</span>&#123;&#125;</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>

<p>7.扩展运算符的应用：</p>
<ul>
<li>合并数组：提供了新写法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line">arr1.concat(arr2, arr3);  <span class="comment">// ES 5</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]  <span class="comment">// ES 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与解构赋值结合：用于生成数组（只能放在参数最后一位）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数的返回值：为函数提供一种返回多个值的方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从数据库取出一行数据，通过扩展运算符，直接传入构造函数Date</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dateFields = readDateFields(database);</span><br><span class="line"><span class="keyword">var</span> d = newDate(...dateFields);</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串：扩展运算符还可以将字符串转为真正的数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;y\uDE80\uD83Dx&#x27;</span></span><br><span class="line"></span><br><span class="line">[...str].reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;y\uD83D\uDE80x&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现了 Iterator 接口的对象：可以通过扩展运算符转为真正的数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

<ul>
<li>Map 和 Set 结构，Generator 函数：扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符。Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map结构</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 函数</span></span><br><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>8.函数内部严格模式：ES 5 时函数内部可以设定为严格模式；ES 6 规定只要函数参数使用了<strong>默认值、解构赋值或者扩展运算符</strong>，则函数内部不能显式设定为严格模式，否则报错。</p>
<p>原因：只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。</p>
<p>两种规避方法：全局性严格模式，将函数包在一个无参数的立即执行函数里。</p>
<p>9.name 属性：返回该函数的函数名。</p>
<p>如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的 name 属性都返回这个具名函数原本的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 5、ES 6</span></span><br><span class="line">bar.name <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code>构造函数返回的函数实例，name 属性的值为 <code>anonymous</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code>返回的函数，name属性值会加上<code>bound</code>前缀。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>10.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数与变量解构结合使用</span></span><br><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.first + <span class="string">&#x27; &#x27;</span> + person.last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化回调函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>11.箭头函数使用注意点：</p>
<ul>
<li>函数体内的<code>this</code>对象就是<strong>定义时所在对象</strong>，而不是使用时所在对象。</li>
<li>不可当作构造函数（即不可使用<code>new</code>命令），否则抛出错误。</li>
<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
<p><code>this</code>指向的固定化，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。也正因如此，箭头函数不能用作构造函数，也不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>
<p>除了<code>this</code>，<code>arguments</code>、<code>super</code>、<code>new.target</code>在箭头函数中也是不存在的，指向外层函数的对应变量。</p>
<p>12.嵌套的箭头函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES 5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span>(<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue)+<span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>);  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>13.函数绑定运算符：<code>::</code>，左边为对象，右边为函数。该运算符自动将左边的对象作为上下文环境（即 this 对象），绑定到右边的函数上。用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> method = obj::obj.foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> method = ::obj.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> log = ::<span class="built_in">console</span>.log;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br></pre></td></tr></table></figure>

<p>由于双冒号运算符返回的还是原对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; find, html &#125; = jake;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div.myClass&quot;</span>)</span><br><span class="line">::find(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">::html(<span class="string">&quot;hahaha&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>该语法为已被 Babel 转码器支持的一个 ES 7 提案。</p>
<p>14.尾调用：某个函数的最后一步是调用另一个函数。</p>
<p>To be continued…</p>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h2><p>1.属性的简洁表示法：ES 6 允许直接写入变量和函数，作为对象的属性和方法。这时，属性名为变量名，属性值为变量值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line">baz  <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">m</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.属性名表达式：ES 6 允许字面量定义对象时，把表达式放在方括号内。表达式也可用于定义方法名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式用于定义方法名</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello()  <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>但<strong>属性名</strong>表达式与简洁表达式不能同时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123; [foo]: <span class="string">&#x27;abc&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>（即不要这么用）。</p>
<p>3.方法的 name 属性：返回函数名。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<p>4.<code>Object.is()</code>：比较两个值是否严格相等，与严格比较运算符（<code>===</code>）的行为基本一致（不同之处为<code>+0</code>不等于<code>-0</code>，以及<code>NaN</code>等于自身）。</p>
<p>5.<code>Object.assign()</code>：用于对象的合并，将源对象的所有可枚举属性复制到目标对象。第一个参数是目标对象，其他参数是源对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target  <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果多个对象有同名属性，后面的属性会覆盖前面的。</p>
<p>如果只有一个参数将直接返回（参数不是对象会先转成对象）。无法转成对象的源对象将被跳过。<code>undefined</code>和<code>null</code>无法转成对象，所以不能作为目标对象（否则报错）。其他相关注意事项见文档。</p>
<p>实行浅拷贝，即源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。对于嵌套对象，一旦遇到同名属性会被替换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);  <span class="comment">// &#123;a: &#123; b: &#x27;hello&#x27; &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>有很多用处，其中包括为对象添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params">arg1, arg2</span>)</span>&#123; ... &#125;,</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span>(<span class="params"></span>)</span>&#123; ... &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; ... &#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="属性的可枚举性与遍历"><a href="#属性的可枚举性与遍历" class="headerlink" title="属性的可枚举性与遍历"></a>属性的可枚举性与遍历</h3><p>6.<code>Object.getOwnPropertyDescriptor</code>：对象的每个属性都有一个描述对象，用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获得该属性的描述对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   value: 123,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>ES 7 引入<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   foo: &#123;</span></span><br><span class="line"><span class="comment">//     value: 123,</span></span><br><span class="line"><span class="comment">//     writable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   bar: &#123;</span></span><br><span class="line"><span class="comment">//     get: [Function: bar],</span></span><br><span class="line"><span class="comment">//     set: undefined,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>7.属性的可枚举性：描述对象的<code>enumerable</code>属性，成为“可枚举性”。ES 5 有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性：</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和<strong>继承的</strong>可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
</ul>
<p>ES 6 新增<code>Object.assign()</code>，会忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p>
<p><strong>当只关心对象自身的属性时，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</strong></p>
<p>8.<code>Object.keys()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键名</strong>。ES 2017 引入配套的<code>Object.values</code>和<code>Object.entries</code>作为遍历一个对象的补充手段。</p>
<p><code>Object.values()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值</strong>（不含 Symbol 属性）。参数为字符串时返回各个字符组成的一个数组，参数为数值或布尔值时返回空数组（与包装对象有关）。</p>
<p><code>Object.entries()</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性的<strong>键值对数组</strong>（不含 Symbol 属性）。</p>
<p>9.属性的遍历：ES 6 共有5种遍历对象的方法。</p>
<ol>
<li><code>for...in</code>：循环遍历对象<strong>自身的</strong>和<strong>继承的</strong>可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.keys(obj)</code>：返回一个数组，包括对象自身的（<strong>不含继承的</strong>）所有可枚举属性（不含 Symbol 属性）。</li>
<li><code>Object.getOwnPropertyNames(obj)</code>：返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但<strong>包括不可枚举属性</strong>）。</li>
<li><code>Object.getOwnPropertySymbols(obj)</code>：返回一个数组，包含对象自身的<strong>所有 Symbol 属性</strong>。</li>
<li><code>Reflect.ownKeys(obj)</code>：返回一个数组，包含对象自身的所有属性（无论是否可枚举或者属性名是 Symbol 还是字符串）。</li>
</ol>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则（之前一些遍历的方法也遵循此规则）。</p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<h3 id="proto-属性及相关方法"><a href="#proto-属性及相关方法" class="headerlink" title="__proto__属性及相关方法"></a><code>__proto__</code>属性及相关方法</h3><p>10.<code>__proto__</code>属性：用于读取或设置当前对象的<code>prototype</code>对象。内部属性，不是正式对外 API。建议使用<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototype()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，则该属性的值就是对象的原型。</p>
<p>11.<code>Object.setPrototypeOf()</code>：作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是对象，会自动转为对象（由于返回的还是第一个参数，故无效果）；是<code>undefined</code>或<code>null</code>则报错（无法转为对象）。</p>
<p>12.<code>Object.getPrototypeOf()</code>：用于读取一个对象的原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>

<p>如果参数不是对象，会被自动转为对象；是<code>undefined</code>或<code>null</code>则报错。</p>
<p>13.对象的扩展运算符：ES 2017 将<code>...</code>引入对象。主要用途有：</p>
<ul>
<li>解构赋值：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x, y, ...z&#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x  <span class="comment">// 1</span></span><br><span class="line">y  <span class="comment">// 2</span></span><br><span class="line">z  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>注意解构赋值的拷贝是浅拷贝，且不会拷贝继承自原型对象的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展某个函数的参数，引入其他操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用x和y参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>扩展运算符：取出参数对象的所有可遍历属性，拷贝到当前对象之中。等同于<code>Object.assign</code>方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n  <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="built_in">Object</span>.assign(&#123;&#125;, z);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于合并两个对象</span></span><br><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>

<p>如果用户自定义的属性放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。因此可用于修改现有对象部分的部分属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;New Name&#x27;</span>  <span class="comment">// Override the name property</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</span><br></pre></td></tr></table></figure>

<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<p>14.Null 传导运算符：<code>?.</code>，用于判断对象及其内部属性是否存在。仅为提案，详见文档。</p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>1.概述：ES 6 引入的新的原始数据类型，表示独一无二的值。至此，JS 共有七种数据类型：</p>
<ul>
<li>Undefined</li>
<li>Null</li>
<li>布尔值（Boolean）</li>
<li>字符串（String）</li>
<li>数值（Number）</li>
<li>对象（Object）</li>
<li>Symbol</li>
</ul>
<p>Symbol 值通过<code>Symbol</code>函数生成。即对象的属性名有两种类型：原来就有的字符串，和新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就是独一无二的，不会与其他属性名产生冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成的 Symbol 是一个原始类型的值，不是对象。因此<code>Symbol</code>函数前不能使用<code>new</code>命令（否则报错），Symbol 值也不能添加属性。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。但相同参数的<code>Symbol</code>函数的返回值是<strong>不相等</strong>的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1  <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2  <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString()  <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.toString()  <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后生成一个 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;kyon&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym  <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure>

<p>Symbol 值不能与其他类型的值进行运算（会报错），但可以显式转为字符串和布尔值。</p>
<p>2.作为属性名的Symbol：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello&#x27;</span>! &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]  <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol]  <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>]  <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>Symbol 值作为属性名时，该属性是<strong>公开属性</strong>而非私有属性。</p>
<p>3.魔术字符串：在代码中多次出现、与代码形成强耦合的某一个具体的字符串或数值。应尽量消除而改用含义清晰的变量代替。</p>
<p><code>Symbol</code>可用于消除魔术字符串。</p>
<p>4.属性名的遍历：Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。这个特性可被用于为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<p><code>Reflect.ownKeys(obj)</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;my_key&#x27;</span>)]: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">enum</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">nonEnum</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>

<p>5.<code>Symbol.for()</code>、<code>Symbol.keyFor()</code>：接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2;  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>.for(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.keyFor</code>方法返回一个<strong>已登记</strong>的 Symbol 类型值的<code>key</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1);  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>6.Singleton 模式：指调用一个类，任何时候返回的都是同一个实例。</p>
<p>Node 中，模块文件可以看作一个类。可以使用 Symbol，通过把实例放到顶层对象<code>global</code>来实现 Singleton 模式。</p>
<h3 id="内置的-Symbol-值-暂且略过"><a href="#内置的-Symbol-值-暂且略过" class="headerlink" title="内置的 Symbol 值(暂且略过)"></a>内置的 Symbol 值(暂且略过)</h3><p>7.<code>Symbol.hasInstance</code>属性：指向一个内部方法。</p>
<p>8.<code>Symbol.isConcatSpreadable</code>属性：</p>
<p>9.<code>Symbol.species</code></p>
<p>10.<code>Symbol.match</code></p>
<p>11.<code>Symbol.replace</code></p>
<p>12.<code>Symbol.search</code></p>
<p>13.<code>Symbol.split</code></p>
<p>14.<code>Symbol.iterator</code></p>
<p>15.<code>Symbol.toPrimitive</code></p>
<p>16.<code>Symbol.toStringTag</code></p>
<p>17.<code>Symbol.unscopables</code></p>
<h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>1.基本用法：Set 结构不会添加重复的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> s)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>

<p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。因此有一种去除数组重复成员的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure>

<p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value equality”，类似精确相等运算符（<code>===</code>），主要的区别是<code>NaN</code>等于自身（<code>===</code>认为<code>NaN</code>不等于自身）。另外，两个对象总是不相等的。</p>
<p>2.Set 实例的属性和方法：</p>
<p>实例属性：</p>
<ul>
<li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>操作方法：</p>
<ul>
<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个表示删除是否成功的布尔值。</li>
<li><code>has(value)</code>：返回一个布尔值。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>遍历方法（Set 结构中，键名和键值是同一个值）：</p>
<ul>
<li><code>keys()</code>：返回键名的遍历器</li>
<li><code>values()</code>：返回键值的遍历器</li>
<li><code>entries()</code>：返回键值对的遍历器</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p><code>Array.from</code>方法可以将 Set 结构转为数组。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>3.含义：与 Set 类似，但成员只能是对象，且都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>ES 6 规定，WeakSet 不可遍历。</p>
<p>4.语法：有<code>add</code>、<code>delete</code>、<code>has</code>方法；没有<code>size</code>属性。</p>
<p>5.用处：是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>6.含义和基本用法：为了解决 Object 的只能用字符串当作键名的问题，ES 6 提供了 Map 数据结构。各种类型的值（包括对象）都可以当作键。</p>
<p>有<code>set(key, value)</code>、<code>get(key)</code>、<code>has(key)</code>、<code>delete(key)</code>、<code>clear()</code>方法。</p>
<p>作为构造函数，Map 可以接受一个数组作为参数，该数组的成员是一个个<strong>表示键值对的数组</strong>。</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值；如果读取一个未知的键，则返回<code>undefined</code>。</p>
<p>7.与其他数据结构的互相转换：</p>
<ul>
<li>Map 转为数组：使用扩展运算符（<code>...</code>）。</li>
<li>数组转为 Map：使用 Map 构造函数。</li>
<li>Map 转为对象：如果所有 Map 的键都是字符串，可以转为对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap)&#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;yes&#x27;</span>, <span class="literal">true</span>).set(<span class="string">&#x27;no&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap);</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对象转为 Map：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj))&#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Map 转为 JSON：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一：Map 的键名都是字符串</span></span><br><span class="line"><span class="comment">// 可以转换为对象 JSON</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况二：Map 的键名有非字符串</span></span><br><span class="line"><span class="comment">// 可以转换为数组 JSON</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJSON</span>(<span class="params">map</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JSON 转为 Map：逆操作。</li>
</ul>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>8.含义：与 Map 类似，用于生成键值对。但只接受对象作为键名（<code>null</code>除外），且键名所指向的对象不计入垃圾回收机制。</p>
<p>专用场合：它的键所对应的对象可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p>
<p>9.语法：没有遍历操作，无法清空。只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<p>10.用处：DOM 节点作为键名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个例子</span></span><br><span class="line"><span class="keyword">let</span> myElement = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;logo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(myElement, &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">myElement.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(myElement);</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险</span></span><br></pre></td></tr></table></figure>

<p>注册监听事件的<code>listener</code>对象，就很适合用 WeakMap 实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listener = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">listener.set(element1, handler1);</span><br><span class="line">listener.set(element2, handler2);</span><br><span class="line"></span><br><span class="line">element1.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener.get(element1), <span class="literal">false</span>);</span><br><span class="line">element2.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener.get(element2), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦DOM对象消失，跟它绑定的监听函数也会自动消失</span></span><br></pre></td></tr></table></figure>

<p>WeakMap 的另一个用处是部署私有属性。</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>暂时跳过。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>暂时跳过。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScipt</tag>
        <tag>ES 6</tag>
        <tag>《ECMAScript 6 入门》</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS 入门笔记</title>
    <url>/blog/start-to-learn-NodeJS/</url>
    <content><![CDATA[<p>上学期曾在 NodeJS 的门槛前匆匆一瞥而不得入，暑假终于有大块的时间一次入门。这篇笔记以 <a href="http://nqdeng.github.io/7-days-nodejs/">七天学会NodeJS</a> 为主干，辅以廖雪峰 JavaScript 教程中相关内容以及其他渠道的一些知识整理而成。内容主要是脑图，一部分细碎知识点和代码以文字呈现。</p>
<p>在学习 NodeJS 过程中，感觉对软件工程基础课程的融会贯通有了更深的理解。作为 JavaScript 的服务器端环境，NodeJS 操作文件、操作进程等功能和上学期的 Unix 课程有着较高的相通性。可惜我 Unix 没有好好听过。网络操作的内容则和 HTTP 以及 Socket 协议的知识紧密联系，这些大概在大三下学期的计算机网络课程中。到时要督促自己按时到勤认真听课了。</p>
<p>虽然总觉得大学授课的水平参差不齐，课程内容可能重要性也分三六九等，但是回头才发现全面的知识体系对今后学习的帮助，不管哪方面知识都是可以迁移的。说实话 whu iss 的专业课安排还是比较科学的（不过学长说计算机网络有点晚，应该放到大三上学期）。希望自己珍惜在学校的最后一年多的时间，不管是学业还是别的方面，不要留太多遗憾。</p>
<p>更新记录：</p>
<ul>
<li>17.08.30 根据《深入浅出 Node.js》的笔记，对”NodeJS 应用领域及特点”部分进行文字补充。</li>
<li>17.09.02 根据《深入浅出 Node.js》的笔记，对”模块”部分进行文字补充。</li>
</ul>
<span id="more"></span>

<h2 id="NodeJS-应用领域及特点"><a href="#NodeJS-应用领域及特点" class="headerlink" title="NodeJS 应用领域及特点"></a>NodeJS 应用领域及特点</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-81b14861f2bc2943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Node.js+概念一览.png"></p>
<p>设计高性能 Web 服务器的要点：<strong>事件驱动、非阻塞 I/O</strong>。</p>
<p>Node 从 Ryan Dahl 一开始设想的 Web 服务器，发展成一个<strong>强制不共享任何资源的单线程、单进程系统</strong>，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施的<strong>网络应用平台</strong>。</p>
<h3 id="Node-与浏览器的异同"><a href="#Node-与浏览器的异同" class="headerlink" title="Node 与浏览器的异同"></a>Node 与浏览器的异同</h3><p>Chrome 浏览器除了 V8 作为 JavaScript 引擎外，还有一个 WebKit 布局引擎。</p>
<p>Node 的结构和 Chrome 十分相似，都是<strong>基于事件驱动的异步架构</strong>。浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O。</p>
<h3 id="Node-的特点"><a href="#Node-的特点" class="headerlink" title="Node 的特点"></a>Node 的特点</h3><h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><h4 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h4><p>事件的编程方式具有<strong>轻量级</strong>、<strong>松耦合</strong>、<strong>只关注事务点</strong>等优势，但是在多个异步任务的场景下，各事件之间各自独立，如何协作是一个问题。</p>
<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>保持了 JS 在浏览器中单线程的特点。在 Node 中，JS 与其余线程无法共享状态。</p>
<p>好处：</p>
<ol>
<li>不用在意状态同步问题；</li>
<li>没有死锁；</li>
<li>没有线程上下文交换带来的性能开销；</li>
</ol>
<p>弱点：</p>
<ol>
<li>无法利用多核 CPU；</li>
<li>错误会引起整个应用退出，应用的健壮性值得考验；</li>
<li>大量计算占用 COU 导致无法继续调用异步 I/O。</li>
</ol>
<p>浏览器端，Web Workers 能够创建工作线程进行计算。为了不阻塞主线程，工作线程采用<strong>消息传递</strong>的方式来传递运行结果，使得工作线程不能访问主线程的 UI。</p>
<p>Node 采用同样的思路解决单线程中大计算量的问题：<strong>child_process</strong>。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息传递结果。</p>
<p>子进程的出现，意味着 Node 可以从容应对单线程在健壮性和无法利用多核 CPU 方面的问题。</p>
<h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>操作系统与 Node 上层模块之间构建了一层平台层架构，即<strong>libuv</strong>。</p>
<h3 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h3><h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4><p>Node 面向网络且擅长并行 I/O，能够有效组织更多的硬件资源。</p>
<p>I/O 密集的优势在于<strong>Node 利用事件循环的处理能力</strong>（而非为每一个服务启动一个线程），资源占用极少。</p>
<h4 id="不擅长-CPU-密集型业务？"><a href="#不擅长-CPU-密集型业务？" class="headerlink" title="不擅长 CPU 密集型业务？"></a>不擅长 CPU 密集型业务？</h4><p>由于 JavaScript 单线程的原因，如果有长时间运行的计算（比如大循环），将导致 CPU 时间片不能释放，使得后续 I/O 无法发起。<strong>适当调整和分解大型运算任务</strong>能使运算适时释放，不阻塞 I/O 调用的发起。</p>
<h4 id="与遗留系统和平共处"><a href="#与遗留系统和平共处" class="headerlink" title="与遗留系统和平共处"></a>与遗留系统和平共处</h4><p>可以将稳定的旧有系统作为后端接口与中间件，而让 Node 将该数据源作为数据接口，发挥异步并行的优势。</p>
<h4 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h4><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a1f50c7c0c750605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="模块.png"></p>
<h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ol>
<li>大大提高代码的可维护性；</li>
<li>可以随时引用；</li>
<li>避免函数名和变量名冲突；</li>
</ol>
<h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><p>CommonJS 主要是在 <strong>Node 服务器端</strong>的规范。意义在于将类聚的方法与变量限定在私有的作用域中，使得用户完全不必考虑变量污染。</p>
<p>CommonJS 对模块的定义主要分为模块引用、模块定义、模块标识三个部分：</p>
<h4 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h4><p>一个模块要引用其他模块暴露的变量，用<code>var foo = require(&#39;module_name&#39;)</code>就拿到了引用模块的变量。</p>
<h4 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h4><p>上下文提供了 <strong>exports 对象</strong>用于导出当前模块的方法或者变量，并且它是唯一的出口。</p>
<p>在模块中，还存在一个 <strong>module 对象</strong>，代表<strong>模块自身</strong>，而 exports 是 module 的<strong>属性</strong>。</p>
<p>一个模块要对外暴露变量（函数也是变量），可以用<code>module.exports = variable;</code>。</p>
<h4 id="模块标识"><a href="#模块标识" class="headerlink" title="模块标识"></a>模块标识</h4><p>即传递给<code>require()</code>方法的参数。</p>
<h3 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h3><p>在 Node 中引入模块，需要经历如下三个步骤：</p>
<ol>
<li>路径分析</li>
<li>文件定位</li>
<li>编译执行</li>
</ol>
<p>在 Node 中，模块分为 Node 提供的<strong>核心模块</strong>和用户编写的<strong>文件模块</strong>。</p>
<p><strong>核心模块</strong>部分在 Node 源代码的编译过程中，编译进了<strong>二进制执行文件</strong>。在 Node 进程启动时，部分核心模块就直接加载进内存中。因此可以省略文件定位和编译执行两个步骤，且在路径分析中优先判断，<strong>加载速度最快</strong>。</p>
<p><strong>文件模块</strong>在<strong>运动时动态加载</strong>，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。</p>
<h4 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h4><p><strong>模块加载会有缓存</strong>，且其根据<strong>绝对路径识别</strong>。因此同样的模块名放在不同的路径之中多次 require 不会重新加载。</p>
<p>Node 对引入过的模块都会以<strong>编译和执行后的对象</strong>的形式进行缓存。核心模块和文件模块都采用缓存优先进行二次加载，核心模块的缓存检查先于文件模块。</p>
<h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><p><strong>模块路径</strong>是 Node 在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。</p>
<p>其生成规则为从当前文件目录下的 node_modules 目录开始，沿路径向上逐级递归，直到根目录下的 node_modules 目录。</p>
<p>Node 在当前目录下查找 package.json，通过<code>JSON.parse()</code>解析出包描述对象，从中取出<code>main</code>属性制定的文件名进行定位。</p>
<h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><ul>
<li>.js 文件。通过 fs 模块同步读取文件后编译执行。</li>
<li>.node 文件。这是用 C/C++ 编写的扩展文件，通过<code>dlopen()</code>方法加载最后编译生成的文件。</li>
<li>.json 文件。通过 fs 模块同步读取文件后，用<code>JSON.parse()</code>解析返回结果。</li>
<li>其余扩展名。它们都被当作 .js 文件载入。</li>
</ul>
<p>每一个编译成功的模块都会将其<strong>文件路径作为索引</strong>缓存在 <strong>Module._cache 对象</strong>上，以提高二次引入的性能。</p>
<p><strong>如果要达成 require 引入一个类的效果，请赋值给 module.exports 对象。</strong></p>
<h3 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h3><p>浏览器端的 JavaScript 需要经历从同一个服务器端分发到多个客户端执行，瓶颈在于<strong>带宽</strong>；而服务器端 JavaScript 则是相同的代码需要多次执行，瓶颈在于 <strong>CPU 和内存等资源</strong>。</p>
<p>CommonJS 是<strong>同步加载</strong>的，在服务器端模块文件一般存放在本地，再加上有缓存，加载速度很快。而在浏览器端就可能导致“假死”，因此浏览器端采用另一种异步加载方式 - AMD（Asynchronous Module Definition，异步模块定义）规范。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">exports</span> = &#123;&#125;</span><br><span class="line">  <span class="built_in">exports</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello from module: &#x27;</span> + <span class="built_in">module</span>.id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">exports</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到 AMD 的模块定义与 Node 模块相似，不同之处在于 <strong>AMD 模块需要用</strong><code>define</code><strong>来明确定义一个模块</strong>，而在 Node 实现中是隐式包装的；以及内容需要通过<strong>返回</strong>的方式实现导出。</p>
<p>想要进一步了解，可参考 <a href="www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html">Javascript模块化编程（二）：AMD规范 - 阮一峰的网络日志</a>。</p>
<h3 id="深入了解模块原理"><a href="#深入了解模块原理" class="headerlink" title="深入了解模块原理"></a>深入了解模块原理</h3><p>Node.js 的“模块”功能利用了 JavaScript 函数式编程的特性，通过<strong>闭包</strong>实现。</p>
<h2 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-829fee6dc736dbd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码的组织和部署.png"></p>
<h3 id="包描述文件中的部分属性"><a href="#包描述文件中的部分属性" class="headerlink" title="包描述文件中的部分属性"></a>包描述文件中的部分属性</h3><ul>
<li>maintainers。包维护者列表，npm 通过该属性进行权限认证。</li>
<li>bin。将包作为命令行工具使用，需配置好 bin 字段，通过<code>npm install package_name -g</code>命令将脚本添加到执行路径中。之后可以在命令行中直接执行。例如：<code>&quot;bin&quot;: &#123; &quot;express&quot;: &quot;./bin/express&quot; &#125;</code></li>
</ul>
<h3 id="全局模式安装"><a href="#全局模式安装" class="headerlink" title="全局模式安装"></a>全局模式安装</h3><p><code>-g</code>将一个包安装为全局可用的可执行命令。通过全局模式安装的所有模块包都被安装进了一个统一的目录下，这个目录可以通过如下方式推算出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.resolve(process.execPath, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;lib&#x27;</span>, <span class="string">&#x27;node_modules&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-a0e8821626a2e3cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本模块.png"></p>
<p>Node.js 内置的常用模块是为了实现基本的服务器功能，底层代码是用 C/C++ 在 Node.js 运行环境中实现。</p>
<h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>Node.js 环境中唯一的全局变量。</p>
<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><p>代表当前 Node.js 进程。</p>
<h3 id="判断-JavaScript-执行环境"><a href="#判断-JavaScript-执行环境" class="headerlink" title="判断 JavaScript 执行环境"></a>判断 JavaScript 执行环境</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(<span class="built_in">window</span>) === <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;node.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;browser&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-f46374c76abbbe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件操作.png"></p>
<h3 id="不同系统下路径的标准化"><a href="#不同系统下路径的标准化" class="headerlink" title="不同系统下路径的标准化"></a>不同系统下路径的标准化</h3><p>标准化之后的路径里的斜杠在 Windows 系统下是<code>\</code>，而在 Linux 系统下是<code>/</code>。如果想保证任何系统下都使用<code>/</code>作为路径分隔符的话，需要用<code>.replace(/\\/g, &#39;/&#39;)</code>再替换一下标准路径。</p>
<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步遍历获取某一文件夹下的所有文件，用 callback 处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback</span>)</span>&#123;</span><br><span class="line">  fs.readdirSync(dir).forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = path.join(dir, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fs.statSync(pathname).isDirectory())&#123;</span><br><span class="line">      travel(pathname, callback)；</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      callback(pathname);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travel</span>(<span class="params">dir, callback, finish</span>)</span>&#123;</span><br><span class="line">  fs.readdir(dir, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(i &lt; files.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> pathname = path.join(dir, files[i]);</span><br><span class="line"></span><br><span class="line">        fs.stat(pathname, <span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">            travel(pathname, callback, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              next(i + <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback(pathname, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              next(i + <span class="number">1</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finish &amp;&amp; finish();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)(<span class="number">0</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-439f836f1c5033bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络操作.png"></p>
<h3 id="监听端口的权限问题"><a href="#监听端口的权限问题" class="headerlink" title="监听端口的权限问题"></a>监听端口的权限问题</h3><p>在 Linux 系统下，监听 1024 以下端口需要 root 权限。因此，如果想监听 80 或 443 端口的话，需要使用 sudo 命令启动程序。</p>
<h3 id="URL-的完整组成"><a href="#URL-的完整组成" class="headerlink" title="URL 的完整组成"></a>URL 的完整组成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                           href</span><br><span class="line"> -----------------------------------------------------------------</span><br><span class="line">                            host              path</span><br><span class="line">                      --------------- ----------------------------</span><br><span class="line"> http: // user:pass @ host.com : 8080 /p/a/t/h ?query=string #hash</span><br><span class="line"> -----    ---------   --------   ---- -------- ------------- -----</span><br><span class="line">protocol     auth     hostname   port pathname     search     hash</span><br><span class="line">                                                ------------</span><br><span class="line">                                                   query</span><br></pre></td></tr></table></figure>

<h3 id="网络操作常见问题"><a href="#网络操作常见问题" class="headerlink" title="网络操作常见问题"></a>网络操作常见问题</h3><ul>
<li><p>问： 为什么通过<code>headers</code>对象访问到的 HTTP 请求头或响应头字段不是驼峰的？</p>
<p>  答： 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实中不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers[&#39;content-length&#39;]</code>。</p>
</li>
<li><p>问： 为什么<code>http</code>模块创建的 HTTP 服务器返回的响应是<code>chunked</code>传输方式的？</p>
<p>  答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用<code>.end</code>方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后 NodeJS 就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>
</li>
<li><p>问： 为什么使用<code>http</code>模块发起 HTTP 客户端请求时，有时候会发生<code>socket hang up</code>错误？</p>
<p>  答： 发起客户端 HTTP 请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许5个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过<code>https.globalAgent.maxSockets</code>属性来处理。</p>
</li>
</ul>
<h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-d48f8689170c4f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程管理.png"></p>
<h3 id="降权"><a href="#降权" class="headerlink" title="降权"></a>降权</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 降权</span></span><br><span class="line">http.createServer(callback).listen(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> env = process.env,</span><br><span class="line">      uid = <span class="built_in">parseInt</span>(env[<span class="string">&#x27;SUDO_UID&#x27;</span>] || process.getuid(), <span class="number">10</span>);</span><br><span class="line">      gid = <span class="built_in">parseInt</span>(env[<span class="string">&#x27;SUDO_GID&#x27;</span>] || process.getgid(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  process.setgid(gid);</span><br><span class="line">  process.setuid(uid);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li><p>如果是通过<code>sudo</code>获取 root 权限的，运行程序的用户的 UID 和 GID 保存在环境变量<code>SUDO_UID</code>和<code>SUDO_GID</code>里边。如果是通过<code>chmod +s</code>方式获取 root 权限的，运行程序的用户的 UID 和 GID 可直接通过<code>process.getuid</code>和<code>process.getgid</code>方法获取。</p>
</li>
<li><p><code>process.setuid</code>和<code>process.setgid</code>方法只接受<code>number</code>类型的参数。</p>
</li>
<li><p>降权时必须先降 GID 再降 UID，否则顺序反过来的话就没权限更改程序的 GID 了。</p>
</li>
</ol>
<h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><p>如果父子进程都是 NodeJS 进程，就可以通过 IPC（进程间通讯）双向传递数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* parent.js */</span></span><br><span class="line"><span class="comment">// 在 options.stdio 字段中通过 ipc 开启一条 IPC 通道</span></span><br><span class="line"><span class="keyword">var</span> child = child_process.spawn(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;child.js&#x27;</span>], &#123;</span><br><span class="line">  <span class="attr">stdio</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;ipc&#x27;</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">child.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给子进程发送消息</span></span><br><span class="line">child.send(&#123; <span class="attr">hello</span>: <span class="string">&#x27;hello&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* child.js */</span></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  msg.hello = msg.hello.toUpperCase();</span><br><span class="line">  process.send(msg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>数据在传递过程中，会先在发送端使用<code>JSON.stringify</code>方法序列化，再在接收端使用<code>JSON.parse</code>方法反序列化。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 守护子进程</span></span><br><span class="line"><span class="comment">/* daemon.js */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">mainModule</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> worker = child_process.spawn(<span class="string">&#x27;node&#x27;</span>, [mainModule]);</span><br><span class="line"></span><br><span class="line">  worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(code !== <span class="number">0</span>)&#123;</span><br><span class="line">      spawn(mainModule);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn(<span class="string">&#x27;worker.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-57c2d4c89e36c4d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步编程.png"></p>
<h3 id="domain-捕获异常"><a href="#domain-捕获异常" class="headerlink" title="domain 捕获异常"></a>domain 捕获异常</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params">request, callback</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// Do something</span></span><br><span class="line">  asyncA(request, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">    asyncB(request, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do something</span></span><br><span class="line">      asyncC(request, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        callback(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d = domain.create();</span><br><span class="line"></span><br><span class="line">  d.on(<span class="string">&#x27;error&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    response.writeHead(<span class="number">500</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  d.run(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">async</span>(request, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      response.writeHead(<span class="number">200</span>);</span><br><span class="line">      response.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>使用<code>uncaughtException</code>或<code>domain</code>捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用<code>try</code>语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上述问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>NodeJS 的学习其实主要分为三块：</p>
<ol>
<li>JavaScript 语言本身。要学会借助 <a href="https://www.ecma-international.org/publications/standards/Standard.htm">ECMAScript 规范</a> 加深自己的理解。</li>
<li>NodeJS 的 API。要熟悉官方 API 文档，主要是熟悉 NodeJS 提供的功能以及知道该查询文档的哪块地方。不推荐死记硬背，因为新版本会更改和弃用部分 API。</li>
<li>生态圈中的各种三方库。要学习检索、过滤、去其糟粕取其精华，利用但不迷信。</li>
</ol>
<p>而在 NodeJS 开发时，首先要有一个全局的设计，再再实现的过程中对之间忽略掉的细节进行设计上的改进，为二次迭代做准备。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>除开文章开头提到的资料，结语部分参考了 <a href="https://mp.weixin.qq.com/s?__biz=MzIyMjYyMzg3MA==&amp;mid=2247484289&amp;idx=1&amp;sn=9e7f6c0c5e6707c8b3d0a73b36bc00c1&amp;chksm=e82be290df5c6b86e2be66f2eea6ee88be1449c3b40d8ebf40932798f95e651fbaf49ca698d0&amp;mpshare=1&amp;scene=1&amp;srcid=0727qbaSu9gx8oduOdFPTUoU#">当我们学习 Node.js 时，我们在学习什么？</a>。</p>
<h3 id="下一步学习"><a href="#下一步学习" class="headerlink" title="下一步学习"></a>下一步学习</h3><ol>
<li><a href="https://github.com/alsotang/node-lessons">《Node.js 包教不包会》 by alsotang</a></li>
<li>《深入浅出Node.js》</li>
<li>自己撸个爬虫</li>
</ol>
]]></content>
      <categories>
        <category>NodeJS 学习笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>JavaScipt</tag>
        <tag>NodeJS</tag>
        <tag>脑图</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】ICLR 2021 论文选读</title>
    <url>/blog/ICLR2021-notes/</url>
    <content><![CDATA[<p>这篇博文简单记录一下我快速阅读 ICLR 2021 其中一些<strong>我感兴趣</strong>的论文时的笔记和感想等。由于论文数量比较多，因此可能后续还会更新。接收列表见 <a href="https://www.paperdigest.org/2021/01/iclr-2021-highlights/">Paper Digest: ICLR 2021 Highlights</a>。</p>
<p>我比较关注的 topic 包括 transfer learning 下的 few-shot learning、domain adaptation、domain generalization 等，以及包括 VQA、visual grounding 在内的一些多模态学习的任务。我用 “#topic” 来标明这篇论文所属的 topic，这样既不用生硬地将属于多个 topic 的论文强行归类到单一 topic 下，也方便各位读者在页面内用 CTRL+F 来搜索自己感兴趣的 topic。</p>
<span id="more"></span>

<h2 id="Few-shot-Learning"><a href="#Few-shot-Learning" class="headerlink" title="Few-shot Learning"></a>Few-shot Learning</h2><ul>
<li><a href="https://openreview.net/forum?id=oZIvHV04XgC">Wandering Within A World: Online Contextualized Few-shot Learning</a><br>#continual learning  #lifelong learning</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-online-contextualized-few-shot-learning.png"></p>
<p>本文提出了一种新的学习范式 online contextualized few-shot learning，要求模型考虑上下文切换来进行在线的小样本学习。同时，本文提出 contextual prototypical memory（CPM）模型，通过集成 RNN 来编码上下文信息，并且有一个独立的原型存储（prototype memory）来记住已经学过的类别，在所有原型半径外的样本会被预测为新类。该模型在本文构建的三个数据集上能够比扩展后的经典 FSL 算法表现更好。</p>
<ul>
<li><a href="https://openreview.net/forum?id=JWOiYxMG92s">Free Lunch for Few-shot Learning: Distribution Calibration</a><br>#data augmentation</li>
</ul>
<p>对于每个 support sample，寻找 base classes 中原型与其最相似的 k 个类别，用这些类的均值和协方差来同该 support sample 一起得到新的均值和协方差作为分布的参数，从而通过从该分布中采样来进行特征级别的数据增强。</p>
<ul>
<li><a href="https://openreview.net/forum?id=04cII6MumYV">A Universal Representation Transformer Layer for Few-Shot Image Classification</a><br>#cross-domain  #self-attention  #metric-based</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-universal-representation-transformer.png"></p>
<p>本文提出了多头的泛用表征转换层（multi-head universal representation transformer layer），在 Meta-Dataset 上表现良好。在单头 URT 层中，对于每个域有一个预训练好的特征提取器，模型对各类原型进行自注意力计算。query 是每个类 $c$ 的原型经线性层的产物 $q_c$，key 是每个域 $i$ 的特征提取器得到的每个类 $c$ 的原型经线性层的产物 $k_{i, c}$。计算得到的权重求平均得到每个域的权重，和对应特征提取器的特征得到调整后的表征。多头 URT 层将单头 URT 层得到的表征拼接，以用于原型分类等。</p>
<ul>
<li><a href="https://openreview.net/forum?id=eJIJF3-LoZO">Concept Learners for Few-Shot Learning</a><br>#compositionality  #auxiliary semantic  #metric-based</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-concept-learners-for-FSL.png"></p>
<p>本文使用了额外的辅助模态，以向量的形式来表现图像中包含的概念。每个概念有一个对应的特征提取器（即卷积骨干网络，实验中分为参数共享和不共享两种），概念向量与样本进行点积后过该特征提取器来得到概念特定的特征，最后进行原型分类的距离就是查询样本的概念特定特征和支持样本的概念特定原型间的欧氏距离对于所有概念的总和。这些概念也可以通过已有的 landmark discovery 方法来无监督式地得到。</p>
<p>提供了特征提取器共享参数的实验结果可以部分消除对参数量大幅增加的质疑，但是在提供有监督概念时只和只用视觉信息的 baselines 比较，我认为是不公平的。</p>
<ul>
<li><a href="https://openreview.net/forum?id=xzqLpqRzxLq">IEPT: Instance-Level and Episode-Level Pretext Tasks for Few-Shot Learning</a><br>#self-supervised</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-instance-level-and-episode-level-pretext-tasks.png"></p>
<p>引入旋转预测的自监督任务后，该方法对于每个旋转角度将 episode 内所有支持和查询样本进行对应旋转来得到一个扩展任务。总 loss 由四部分组成：(1) 预测每个旋转后的样本的旋转角度的 loss；(2) 在每个旋转角度对应的扩展任务中，查询样本分类的 loss；(3) 跨所有扩展任务中，同一查询样本对应的预测概率分布的一致性 loss，具体做法是将该样本的各扩展任务中的预测概率分布与所有扩展任务的预测概率分布均值求 KL 散度；(4) 将同一样本在不同旋转角度后得到的特征视为同一序列中的不同 token，进行自注意力计算后拼接来用于分类得到 loss。</p>
<ul>
<li><a href="https://openreview.net/forum?id=vujTf_I8Kmc">Constellation Nets for Few-Shot Learning</a><br>#metric-based  #self-attention  #compositionality  #clustering</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-ConstellationNet.png"></p>
<p>本文将特征图上每个位置的局部特征 $u \in R^C$ 进行软聚类，将所有局部特征到所有聚类中心的距离组织为一张距离图 $D \in R^{B \times H \times W \times K}$，之后再将 $D$ 和一个位置编码 $P \in R^{B \times H \times W \times K}$ 相加来作为 query 和 key、$D$ 作为 value 进行多头自注意力运算。上述运算结果和特征图拼接后过 1x1 卷积，从而在骨干网络的每个卷积层后无缝接入 constellation 模型，以结合隐式和显式的 part-based representations。</p>
<ul>
<li><a href="https://openreview.net/forum?id=9z_dNsC4B5t">MetaNorm: Learning to Normalize Few-Shot Batches Across Domains</a><br>#meta-learning  #normalization</li>
</ul>
<p>本文认为当 batch size 较小或者 distribution shift 较大（训练集的统计数据不适用于测试集）时，batch 的统计数据是不可靠的。因此本文提出一种基于原学习的 batch normaliztion 方法，旨在利用一个神经网络来根据输入的样本生成统计数据来最小化不同 domain 或者 support 和 query 间的 KL 散度。该方法在小样本分类、domain generalization 以及提出的 few-shot domain generalization（meta-train 和 meta-test 每个 episode 中类别不同，每个 episode 内部 support 和 query 的 domain 不同）等任务上普遍优于现有的 normalization 方法。</p>
<h2 id="Meta-Learning"><a href="#Meta-Learning" class="headerlink" title="Meta Learning"></a>Meta Learning</h2><ul>
<li><a href="https://openreview.net/forum?id=XOjv2HxIF6i">Unsupervised Meta-Learning through Latent-Space Interpolation in Generative Models</a><br>#unsupervised learning  #generative adversarial networks </li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-latent-space-interpolation-unsupervised-meta-learning.png"></p>
<p>现有的无监督元学习方法主要依靠包含聚类、数据增强、随机采样等方法来生成合成任务，这些方法的缺点是根据领域的不同，它们需要较大的调整。本文提出使用现成的、预训练好的生成模型，通过在隐式空间在进行插值来生成合成任务。该方法的优点在于基本不需要根据特定领域进行调整，仅有的一些超参数调整也具有可理解性。</p>
<h2 id="Zero-shot-Learning"><a href="#Zero-shot-Learning" class="headerlink" title="Zero-shot Learning"></a>Zero-shot Learning</h2><ul>
<li><a href="https://openreview.net/forum?id=TgSVWXw22FQ">Improving Zero-Shot Voice Style Transfer via Disentangled Representation Learning</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-zero-shot-voice-style-transfer.png"></p>
<p>本文针对在不重新训练模型的情况下迁移到训练期间不可见的发声者风格的任务，认为现有的基于预训练分割编码器或者 AdaIN 的方法都无法较好地分离风格和内容编码。因此，本文最小化风格和内容编码间基于样本的互信息上界，并且最大化两个新的多组互信息下界来增强编码的表示能力。</p>
<h2 id="DA-DG"><a href="#DA-DG" class="headerlink" title="DA / DG"></a>DA / DG</h2><ul>
<li><a href="https://openreview.net/forum?id=b9PoimzZFJ">Systematic generalisation with group invariant predictions</a><br>#systematic generalisation  #invariance penalty  #semantic anomaly detection  #domain generalization</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-systematic-generalisation-with-group-invariant-predictions.png"></p>
<p>本文提出，数据集通常存在和目标变量相关的简单特征（但不健壮）以及更加复杂但是健壮的特征。在三个合成的数据集 coloured-MNIST、COCO-on-colours 和 COCO-on-places 上的实验结果表明，用一个 soft-partition predicting network 来将数据集划分为 majority and minority groups，并且对不同 group 同类样本的特征施加不变性惩罚（例如 KL 散度）有助于模型关注这些更加健壮的特征。</p>
<p>Spotlight。本文对不同类型的 shift 的划分还是挺有意思的，感觉和一些在视觉上做因果学习的工作在思路上有共通之处。方法上比较简单，可能这就是大巧不工吧。然后我比较关心的问题包括能否在真实数据集上使用这个方法，效果如何？Reviewer 3 也提出了相同的问题，举例问能否在 ImageNet 上找到一个合适的划分。作者的回答是像 ImageNet 这种数据来源丰富、相对杂乱的数据集可能难度比较大，而像医学图像这种数据来源相对单一的就要好一些。</p>
<ul>
<li><a href="https://openreview.net/forum?id=lQdXeXDoWtI">In Search of Lost Domain Generalization</a><br>#domain generalization  #benchmark</li>
</ul>
<p>本文为 DG 实现了一个名为 DomainBed 的 testbed，包含 7 个数据集、14 种算法和 3 种模型选择策略。结论是 ERM 仍然是一个非常有竞争力的 baseline。</p>
<p>在我看来这篇论文的一大贡献是讨论了不同模型选择策略带来的影响，包括 training-domain validation（将训练数据划分为 train 和 val set）、leave-one-domain-out validation（给定多个训练域，每次将一个域作为 val，将平均准确率作为指标选择出超参后再在所有训练域上重新训练模型）、test-domain validation（允许用非常有限的测试数据来挑选模型。注意这通常不是一个合理的方法）。另一大贡献自然就是这个还挺大的实验规模，以及给后续工作留下一个还不错的 testbed。</p>
<ul>
<li><a href="https://openreview.net/forum?id=6xHJ37MVxxp">Domain Generalization with MixStyle</a><br>#domain generalization</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-MixStyle.png"></p>
<p>本文受 instance normalization（IN）和 adaptive instance normalization（AdaIN）启发，提出在将样本进行分 domain 打乱或者随机打乱后，用一个随机的权重来混合两个样本的特征统计信息，从而模拟新风格来约束 CNN 的训练。该方法在分类、检索和 RL 上都取得了效果。</p>
<ul>
<li><a href="https://openreview.net/forum?id=BVSM0x3EDK6">Robust and Generalizable Visual Representation Learning via Random Convolutions</a><br>#domain generalization  #data augmentation</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-randconv.png"></p>
<p>本文旨在从单源域数据学习和局部纹理和颜色无关的健壮视觉表征，因此提出一种数据增强技术 RandConv，用随机得卷积来生成有随机纹理但是保留全局形状的图像来提升泛化性。</p>
<h2 id="VQA"><a href="#VQA" class="headerlink" title="VQA"></a>VQA</h2><ul>
<li><a href="https://openreview.net/forum?id=Pd_oMxH8IlF">Iterated learning for emergent systematicity in VQA</a><br>#visual question-answering  #modular networks  #iterated learning  #compositional generalization</li>
</ul>
<p>神经模块网络（neural module networks, NMN）通常需要一个程序生成器（program generator）来生成符号化的程序将模块组织成计算图。然而，生成的程序很难组合式泛化。本文提出用迭式学习（iterated learning, IL）的方式，将 NMN 的程序看作来自“布局语言”的样本。在本文提出的 SHAPES-SyGet 数据集以及 CLEVR、CLOSURE 上，本方法可以用 1/10 甚至更少的程序标注与 SOTA 相媲美。 </p>
<p>Oral。评审的意见主要集中在实验选用的数据集比较 toyish。之后作者补做了在 GQA 数据集上的实验， Vector-NMN+IL 用 4000 个程序标注能够和 Vector-NMN 用 943000 个程序标注的效果持平。</p>
<!-- 【接下来可以把算法部分2页看一下】
[paper](https://openreview.net/pdf?id=Pd_oMxH8IlF) -->


<h2 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h2><ul>
<li><a href="https://openreview.net/forum?id=Y87Ri-GNHYu">Ask Your Humans: Using Human Instructions to Improve Generalization in Reinforcement Learning</a><br>#reinforcement learning  #natural language  #imitation learning</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-ask-your-humans.png"></p>
<p>本文引入了一个提供自然语言指令和动作轨迹作为人类演示，一个类似 Minecraft 的 5x5 gridworld 数据集，包括 35 个任务的 6000 条指令。提出的新模型 (1) 在给定状态和目标时，学习为要执行的高级子任务生成自然语言描述；(2) 学习语言控制的低级策略来实际执行这些步骤。模型首先通过模仿学习进行预训练，之后用 RL 的 PPO 算法和稀疏 reward 进行微调（微调过程不使用 ground-truth 语言指令）。实验证明该模型能够在 zero-shot 设置下泛化到不可见任务中生成的自然语言指令，并且提供了可解释的行为。</p>
<ul>
<li><a href="https://openreview.net/forum?id=9SS69KwomAM">Solving Compositional Reinforcement Learning Problems via Task Reduction</a><br>#reinforcement learning  #imitation learning</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-self-imitation-via-reduction.png"></p>
<p>本文提出一种新的学习范式 Self-Imitation via Reduction (SIR) 来解决有稀疏 reward 的组合性持续控制问题。该范式首先将较难的任务简化为解决方案已知的简单任务（称为任务缩减），然后在获得的解决方案的轨迹上执行模仿学习，从而加速训练，同时无需显式确定低级技能或选项就可向学到的策略引入组合性的偏执归纳。上面的示意图是一个任务缩减的具体例子。另外，SIR 可以将学到地任务作为新的缩减目标，从而循环式地学习任意复杂的策略。SIR 通过共同学习一个 goal-conditioned policy 和一个 universal value function 来实现，因此任务缩减可以通过对价值函数的状态搜索和不同目标的策略执行来完成。</p>
<p>作为一个 RL 门外汉，我觉得 intution 还是挺有意思的，不过由于我没细看，我比较好奇这种任务缩减如果没有解决方案已知的简单任务的话怎么办呢？实验是是否需要假设较难的任务都存在解决方案已知的简单任务？（我看 program chair 的最终意见也有差不多的观点，即本文关注的是如何将问题分解为子问题，而在设计任务空间时确实包含了一定先验知识，即并不是学来的。）</p>
<ul>
<li><a href="https://openreview.net/forum?id=vcopnwZ7bC">Learning Task Decomposition with Ordered Memory Policy Network</a><br>#reinforcement learning  #hierarchical imitation learning</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-ordered-memory-policy-network.png"></p>
<p>本文提出 Ordered Memory Policy Network (OMPN) ，能够通过从演示中学习来探索子任务的层级结构，从而在监督和弱监督设置下利用非结构化的演示实现任务分解来复用学过的技能。该方法将子任务视为有限状态机（finite state machine），它们被表示为通过自顶向下和自底向上循环更新的内存库。</p>
<p>看 Chap 2.2 开头，还是需要在 detection 阶段让用户给定子任务数量以及动作空间，以生成 task boundaries。</p>
<h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><ul>
<li><a href="https://openreview.net/forum?id=PS3IMnScugk">Learning to Recombine and Resample Data For Compositional Generalization</a><br>#compositional generalization  #data augmentation  #natural language processing  #few-shot morphology learning</li>
</ul>
<p>本文关注小样本时态学习问题，旨在从单词形式预测包括第三人称、单数、现在时等各种语言特征。以前的工作集中于例如符号语法建模数据或应用基于规则的数据扩增等方法，这些方法很难在没有显式规则的归纳偏置下进行泛化。本文提出一种新的基于原型的神经序列模型，通过显式重组训练示例片段来重构其他输入-输出对，并对模型的输出进行重采样来选择稀有现象的高质量合成样本，从而进行样本扩增。</p>
<h2 id="Continual-Learning"><a href="#Continual-Learning" class="headerlink" title="Continual Learning"></a>Continual Learning</h2><ul>
<li><a href="https://openreview.net/forum?id=ADWd4TJO13G">Lifelong Learning of Compositional Structures</a><br>#lifelong learning  #continual learning  #modular networks</li>
</ul>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICLR21-lifelong-compositional-learning.png"></p>
<p>本文将组合学习和终身学习结合，提出一个框架来分阶段地学习如何最佳地组合已有组件来理解新任务，以及如何调整现有组件（以及选择增加新组件）来适应新问题。3x3=9 种组合被用于说明该框架，其中知识保留机制包括简单微调、经验回放（experience replay）、弹性权重整合（elastic weight consolidation）；组合性结构包括线性模型的线性组合、软性层排序（soft layer ordering）、门网络的一个软版本（a soft version of gating networks）。八个数据集上的实验结果表明将终身学习过程划分为两个阶段能够减少灾难性遗忘。</p>
<h2 id="generative-models"><a href="#generative-models" class="headerlink" title="generative models"></a>generative models</h2><ul>
<li><a href="https://openreview.net/forum?id=sjuuTm4vj0">Using latent space regression to analyze and leverage compositionality in GANs</a><br>#image synthesis  #generative adversarial networks  #image editing</li>
</ul>
<p>本文使用一个回归器（regressor）来根据属性预测给定图像的隐式编码，从而分析和修改预训练 GAN 的隐式空间。另外编码器的输入可以加上一个 binary mask 来学习在图像不完整的情况进行重构。该方法在图像组合、属性修改、图像补齐和多模态编辑上等应用上都有良好的表现。</p>
<p>我比较感兴趣的是该方法声称能够在图像组合时处理全局不一致和像素缺失的问题；另外研究预训练 GAN 对生成图像的局部进行混合和匹配的能力，而非直接提出新的 GAN 模型的思路也挺有意思（NLP 里很多工作已经是完全建立在预训练模型上进行研究了，当然我不太清楚这种思路是不是也在 GAN 这里成为主流了）。我对引用中 <a href="https://openreview.net/forum?id=SJxDDpEKvH">Besserve et al., 2018</a> 有一点兴趣，不过不一定有时间去读。</p>
<ul>
<li><a href="https://openreview.net/forum?id=qbH974jKUVy">The role of Disentanglement in Generalisation</a><br>#disentanglement  #compositionality  #variational autoencoders</li>
</ul>
<p>本文旨在研究神经网络是否能够利用解纠缠表征来支持组合性泛化和外推。研究建立在两个图像数据集（dSprites 和 3DShape）上，模型包含有不同解纠缠压力的 β-VAEs 和 FactorVAEs，以及去掉编码器的解码器（直接输入解纠缠隐编码）。本文的结论是学习非纠缠表征确实提高了可解释性和样本效率，但这些模型只支持最简单的组合泛化，并且解纠缠的程度对于泛化的程度没有影响。</p>
<!-- 【还没仔细看评审意见】 -->


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>ICLR 2021</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统复习笔记</title>
    <url>/blog/operating-system-notes/</url>
    <content><![CDATA[<h2 id="操作系统引论"><a href="#操作系统引论" class="headerlink" title="操作系统引论"></a>操作系统引论</h2><h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>定义一：是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。</p>
<p><strong>定义二</strong>：是一组控制和管理计算机硬件和软件资源、合理地对各类作业进行调度以及方便用户使用的程序的集合。</p>
<h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ol>
<li>作为用户与计算机硬件系统之间的接口；</li>
<li>作为计算机系统资源的管理者；</li>
<li>实现对计算机资源的抽象。</li>
</ol>
<h3 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h3><h4 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发*"></a>1. 并发*</h4><p>两个或多个事件在同一时间<strong>间隔</strong>内发生。</p>
<h4 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h4><p>系统中的资源可供多个并发执行的进程共同使用。</p>
<p>两种共享方式：</p>
<ul>
<li><strong>互斥共享</strong>：共享的资源称为临界资源，同一时间只允许一个进程访问。需要用同步机制来实现对临界资源的访问；</li>
<li>同时访问：微观上交替进行。</li>
</ul>
<h4 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h4><p>把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时分复用技术（如分时系统）、空分复用技术（如虚拟内存）。</p>
<h4 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h4><p>多个作业的执行顺序和每个作业的执行时间是不确定的。</p>
<h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><ol>
<li><strong>处理器管理</strong>：处理器的运行和分配，以进程为基本单位，因此也被看作进程管理。包括进程控制、进程同步、进程通信、进程调度；</li>
<li><strong>存储器管理</strong>：内存分配、内存保护（不相互干扰）、地址映射（逻辑 -&gt; 物理）、内存扩充（虚拟存储技术）；</li>
<li><strong>设备管理</strong>：包括缓存管理（I/O 设备和 CPU 之间）、设备分配、设备处理；</li>
<li><strong>文件管理</strong>：包括文件存储空间的管理、目录管理、文件读写管理和保护；</li>
<li><strong>提供用户接口</strong>：程序接口（如 API）和用户接口（如 GUI）。</li>
</ol>
<span id="more"></span>

<h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul>
<li>每次由作业调度算法，从外存的后备队列中选择若干作业调入内存，共享 CPU 和各种资源。程序 A 因 I/O 操作暂停执行时，调度另一道程序 B 运行。</li>
<li>根本目的：提高 CPU 的利用率，充分发挥系统部件的并行性。</li>
<li>优点：资源利用率高；系统吞吐量大。</li>
<li>缺点：平均周转时间长；无用户交互能力。</li>
</ul>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="顺序执行与并发执行"><a href="#顺序执行与并发执行" class="headerlink" title="顺序执行与并发执行"></a>顺序执行与并发执行</h3><p>程序<strong>顺序</strong>执行时的特征：</p>
<ol>
<li><strong>顺序性</strong>：严格按照程序所规定的次序执行；</li>
<li><strong>封闭性</strong>：程序在封闭环境下运行，系统中所有资源的状态只有本程序才能改变；</li>
<li><strong>可再现性</strong>：只要初始条件相同，无论怎样执行，其结果都相同。</li>
</ol>
<p>程序<strong>并发</strong>执行时的特征：</p>
<ol>
<li><strong>间断性</strong></li>
<li><strong>非封闭性</strong></li>
<li><strong>不可再现性</strong></li>
</ol>
<h3 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul>
<li><p><strong>进程</strong>是<strong>资源分配</strong>的基本单位。进程控制块（Process Control Block，PCB）描述进程的基本信息和运行状态。所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
</li>
<li><p><strong>线程</strong>是<strong>独立调度</strong>的基本单位。一个进程中可以有多个线程，它们共享进程的资源和内存地址空间。</p>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>拥有资源：进程是资源分配的基本单位，但是<strong>线程不拥有资源</strong>，线程可以访问隶属进程的资源。</p>
</li>
<li><p>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换；从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p>
</li>
<li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
</li>
<li><p>通信方面：进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p>
</li>
</ul>
<h3 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h3><p>进程的三种基本状态：</p>
<ol>
<li><strong>就绪</strong>状态：已分配除 CPU 外的所有必要资源</li>
<li><strong>执行</strong>状态：获得 CPU，程序正在执行</li>
<li><strong>阻塞</strong>状态：发生某事件（I/O 请求、申请缓冲空间等）暂时无法继续执行</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/18595460/40005754-5d106890-57cb-11e8-841d-2c7c9d4b4b4c.png" alt="process-state-i"></p>
<h4 id="引入挂起操作"><a href="#引入挂起操作" class="headerlink" title="引入挂起操作"></a>引入挂起操作</h4><p><strong>挂起</strong>：当该操作用于某个进程时，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作对应的操作是激活操作。</p>
<p>引入原因：</p>
<ol>
<li>终端用户的需要；</li>
<li>父进程请求；</li>
<li>负荷调节的需要；</li>
<li>操作系统的需要。</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/18595460/40005753-5cc9261a-57cb-11e8-8057-f2f19ccbdfee.png" alt="process-state-ii"></p>
<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p><strong>进程同步机制的主要任务</strong>：对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能有效共享资源和相互合作，从而使程序执行具有可再现性。</p>
<p><strong>两种形式的制约关系</strong>：间接相互制约关系（通过共享系统资源）、直接相互制约关系（源于相互合作）</p>
<p><strong>临界资源</strong>：一段时间内仅允许一个进程使用的资源。</p>
<p><strong>临界区</strong>：进程中访问临界资源的那段代码。</p>
<p><strong>同步机制规则</strong>：空闲让进、忙则等待、有限等待、让权等待。</p>
<p><strong>经典的进程同步问题</strong>：生产者-消费者问题、读者-写者问题、哲学家进餐问题（暂略，详见课本 p60）</p>
<h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>信号量（Semaphore）是一个整型变量，可以对其执行<strong>P、V 原语操作</strong>：</p>
<ul>
<li>P：如果信号量大于 0，执行 -1 操作；如果信号量等于 0，进程阻塞，等待信号量大于 0；</li>
<li>V：对信号量执行 +1 操作，唤醒阻塞的进程让其完成 P 操作。</li>
</ul>
<p>原语操作意指不可分割，通常做法是执行这些操作时屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或 1，那么即是<strong>互斥量（Mutex）</strong>。0 表示临界区已经加锁，1 表示临界区解锁。</p>
<p><strong>发展过程</strong>：整型信号量 -&gt; 记录型信号量 -&gt; AND 型信号量 -&gt; 信号量集</p>
<ul>
<li>整型信号量：P 申请，V 释放；</li>
<li>记录型信号量：增加一个等待队列；</li>
<li>AND 型信号量：AND 同步机制将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后一起释放（要么全部分配，要么一个都不分配）；</li>
<li>信号量集：对 AND 型信号量集进行扩充，允许一次申请多个资源，而且在分配之前，测试某资源的数量是否大于临界值。</li>
</ul>
<p><strong>信号量的应用</strong>：</p>
<ol>
<li>实现进程互斥；</li>
<li>实现前趋关系。</li>
</ol>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><h4 id="进程同步与进程通信的区别"><a href="#进程同步与进程通信的区别" class="headerlink" title="进程同步与进程通信的区别"></a>进程同步与进程通信的区别</h4><ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间信息交换。</li>
</ul>
<p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<p>信号量也属于进程通信的一种方式，但是属于低级进程通信，因为它传输的信息非常小。</p>
<h4 id="进程通信方式"><a href="#进程通信方式" class="headerlink" title="进程通信方式"></a>进程通信方式</h4><p>高级通信机制可归为以下四大类：</p>
<h5 id="1-共享存储器系统"><a href="#1-共享存储器系统" class="headerlink" title="1. 共享存储器系统"></a>1. 共享存储器系统</h5><p>又可分为以下两种类型：</p>
<ol>
<li>基于共享数据结构的通信方式：仅适用于传递相对少量的数据，通信效率低下，属于低级通信；</li>
<li>基于共享存储区的通信方式：高级通信。</li>
</ol>
<h5 id="2-管道通信系统"><a href="#2-管道通信系统" class="headerlink" title="2. 管道通信系统"></a>2. 管道通信系统</h5><p><strong>管道（pipe）</strong>：用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。写进程以<strong>字符流</strong>形式将大量数据送入管道，而读进程从管道中接收数据。管道机制必须提供互斥、同步和确定对方是否存在的协调能力。</p>
<h5 id="3-消息传递系统"><a href="#3-消息传递系统" class="headerlink" title="3. 消息传递系统"></a>3. 消息传递系统</h5><p>在该机制中，以格式化的消息为单位，将通信的数据封装到消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递。</p>
<p>优点：隐藏通信细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率。</p>
<p>该机制是多处理机系统、分布式系统和计算机网络领域最主要的通信工具。根据实现方式不同，可进一步分为直接通信方式（直接将消息发送给目标进程）和间接通信方式（通过共享中间实体[称为邮箱]）。</p>
<h5 id="4-客户机-服务器系统"><a href="#4-客户机-服务器系统" class="headerlink" title="4. 客户机-服务器系统"></a>4. 客户机-服务器系统</h5><p>网络环境的各种应用领域中的主流通信实现机制，主要实现方法分为：</p>
<ol>
<li><strong>套接字（Socket）</strong>：一个通信标识类型的数据结构，是进程通信和网络通信的基本构件；</li>
<li><strong>远程过程调用（RPC）</strong>：一个通信协议，允许运行于本地系统上的进程调用远程系统上的进程，而对程序员表现为常规的过程调用，无需额外为此编程。</li>
</ol>
<h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><h3 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h3><p>又称<strong>高级调度</strong>。主要功能是根据某种算法，从外存上后备队列中选择多个<strong>作业</strong>调入内存，为其<strong>创建进程</strong>、<strong>分配必要的资源</strong>，并插入<strong>就绪队列</strong>。</p>
<p>主要用于多道批处理系统中，分时系统和实时系统无作业调度。</p>
<p><strong>作业</strong>：用户提交给系统的一项相对独立的工作。操作员把其通过响应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。<strong>作业控制块</strong>是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。</p>
<p>作业调度算法：</p>
<h4 id="1-先来先服务（FCFS）"><a href="#1-先来先服务（FCFS）" class="headerlink" title="1. 先来先服务（FCFS）"></a>1. 先来先服务（FCFS）</h4><p>调度最先进入就绪队列的作业。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<h4 id="2-短作业优先（SJF）"><a href="#2-短作业优先（SJF）" class="headerlink" title="2. 短作业优先（SJF）"></a>2. 短作业优先（SJF）</h4><p>调度估计运行时间最短的作业。</p>
<p>长作业可能处于一直等待短作业执行完毕的状态（饥饿）。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
<h4 id="3-优先级调度算法（PSA）"><a href="#3-优先级调度算法（PSA）" class="headerlink" title="3. 优先级调度算法（PSA）"></a>3. 优先级调度算法（PSA）</h4><p>基于作业的紧迫程度，由外部赋予相应的优先级。</p>
<h4 id="4-高响应比优先调度算法（HRRN）"><a href="#4-高响应比优先调度算法（HRRN）" class="headerlink" title="4. 高响应比优先调度算法（HRRN）"></a>4. 高响应比优先调度算法（HRRN）</h4><p>引入动态优先级：优先级随等待时间延长而增加。</p>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>又称<strong>低级调度</strong>。主要功能是在保存处理机的现场信息后，根据某种算法，决定<strong>就绪队列</strong>获得处理机的<strong>进程</strong>，使其进入运行状态。</p>
<p>多道批处理系统、分时系统和实时系统都配置进程调度。</p>
<h4 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h4><h5 id="1-非抢占方式"><a href="#1-非抢占方式" class="headerlink" title="1) 非抢占方式"></a>1) 非抢占方式</h5><p>一旦把处理机分配给某进程，则直至该进程完成或被阻塞时，才把处理机另外分配。</p>
<h5 id="2-抢占方式"><a href="#2-抢占方式" class="headerlink" title="2) 抢占方式"></a>2) 抢占方式</h5><p>允许调度程序根据某种原则，去暂停某个正在执行的进程，并将其处理机重新分配。</p>
<p>抢占必须遵循的原则：</p>
<ol>
<li>优先权原则</li>
<li>短进程优先原则</li>
<li>时间片原则</li>
</ol>
<p>进程调度算法：</p>
<h4 id="1-轮转调度（RR）"><a href="#1-轮转调度（RR）" class="headerlink" title="1. 轮转调度（RR）"></a>1. 轮转调度（RR）</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时分配一个 CPU 时间片给队首进程。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p>轮转调度算法中，效率和时间片大小有很大关系。时间片小意味着频繁执行进程调度和进程上下文的切换，增加系统开销；时间片长则退化为 FCFS 算法，无法满足短作业和交互式用户的需求。</p>
<h4 id="2-优先级调度"><a href="#2-优先级调度" class="headerlink" title="2. 优先级调度"></a>2. 优先级调度</h4><p>把处理机分配给就绪队列中优先级最高的进程。又可以分为非抢占式和抢占式两种。</p>
<h4 id="3-多队列调度"><a href="#3-多队列调度" class="headerlink" title="3. 多队列调度"></a>3. 多队列调度</h4><p>将进程就绪队列拆分为多个，不同的就绪队列采用不同的调度算法，也可以设置不同的优先级。</p>
<h4 id="4-多级反馈队列（multileved-feedback-queue）"><a href="#4-多级反馈队列（multileved-feedback-queue）" class="headerlink" title="4. 多级反馈队列（multileved feedback queue）"></a>4. 多级反馈队列（multileved feedback queue）</h4><p><img src="https://user-images.githubusercontent.com/18595460/40105062-7ef33bb8-5924-11e8-8ae2-8454f82717b2.png" alt="multileved-feedback-queue"></p>
<ol>
<li>设置多个就绪队列。优先级逐个降低，时间片长度依次翻倍（1，2，4，…）；</li>
<li>每个队列采用 FCFS 算法。若在该队列中一个时间片中未完成，则转入下一队列的末尾等待调度。在最后一个队列则按 RR 运行；</li>
<li>按队列优先级调度。仅当优先级更高的所有队列均空时，才会调度下一个队列中的进程运行。</li>
</ol>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p>又称<strong>中级调度</strong>。主要功能是将暂时不能运行的进程调至外存等待（<strong>此时进程状态为挂起</strong>），当其具备运行条件且内存有空闲时再调入（并将状态修改为就绪）。</p>
<p>引入的主要目的是，提高内存利用率和系统吞吐量。</p>
<h3 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h3><p><strong>定义</strong>：两个或多个进程由于<strong>资源竞争</strong>而造成的僵局。若无外力作用，这些进程将永远无法向前推进。</p>
<p><strong>产生死锁的原因</strong>：</p>
<ol>
<li>竞争不可抢占性资源引起死锁；</li>
<li>竞争可消耗资源引起死锁；</li>
<li>进程推进顺序不当引起死锁：申请和释放资源的顺序不当。</li>
</ol>
<p><strong>产生死锁的必要条件（任一不成立则死锁不发生）</strong>：</p>
<ol>
<li>互斥条件：进程间必须互斥使用某些资源；</li>
<li>请求和保持条件：进程已经占有至少一个资源，但又提出了新的资源请求；</li>
<li>不可抢占条件：进程已获得的资源在未使用完前不得被抢占；</li>
<li>循环等待条件：在发生死锁时，必然存在一个进程-资源的循环链。</li>
</ol>
<p><strong>处理死锁的基本方法</strong>：</p>
<ol>
<li>预防死锁：通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个；</li>
<li>避免死锁：在资源动态分配时，用某种方法防止系统进入不安全状态，从而避免死锁；</li>
<li>检测和解除死锁：允许系统产生死锁，但能及时检测并通过某些措施解除。</li>
</ol>
<p>从上到下对死锁的防范程度依次减弱，但资源利用率和并发程度提高。</p>
<p>顺便一提，大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p><strong>安全序列</strong>：指系统能够按照某种进程顺序，为每个进程分配其所需资源，直至满足每个进程对资源的<strong>最大需求</strong>，使每个进程都可顺利地完成。如果系统能够找到这样一个安全序列，则称其处于<strong>安全状态</strong>；反之则处于不安全状态。</p>
<p>最有代表性的避免死锁算法是 Dijkstra 的<strong>银行家算法</strong>（暂略，详见课本 p111）。</p>
<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><h3 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h3><p>用户程序要在系统中运行需要经过以下几个步骤：</p>
<ol>
<li>编译：由编译程序（Compiler）对用户源程序进行编译，形成若干个目标模块（Object Module）；</li>
<li>链接：由链接程序（Linker）将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块（Load Module）；</li>
<li>装入：由装入程序（Loader）将装入模块装入内存。</li>
</ol>
<p>其中，程序<strong>装入</strong>方式有以下三种：</p>
<ol>
<li>绝对装入方式：目标模块采用绝对地址。即逻辑地址和实际内存地址完全相同，装入时不需对地址进行变换；</li>
<li>可重定位装入方式（静态重定位）：在装入时，由重定位装入程序一次性完成；</li>
<li>动态运行时装入方式：重定位推迟到程序真正执行时进行。即装入内存后的所有地址都仍是相对地址。这种方式需要硬件支持，程序可以在内存中移动（对换/紧凑），可以实现虚拟存储。</li>
</ol>
<p>其中，<strong>重定位</strong>是将装入模块中指令和数据的相对地址调整成相应内存单元的绝对地址。</p>
<p>程序<strong>链接</strong>方式也有三种：</p>
<ol>
<li>静态链接：在程序运行前将目标模块和所需库函数链接，以后不再拆开；</li>
<li>装入时动态链接；</li>
<li>运行时动态链接：可加快装入过程，节省大量内存空间。</li>
</ol>
<h3 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h3><ol>
<li>单一连续分配：内存分为系统区和用户区，用户区仅一道用户程序独占。最简单，适用于单用户、单任务 OS；</li>
<li>固定分区分配：系统初启时将用户区划分为若干分区，大小和分界固定且每个分区只允许装入一道作业。程序道数、程序大小受限，且有较多内部碎片；</li>
<li>动态分区分配：见下；</li>
<li>动态可重定位分区分配：见下。</li>
</ol>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p>分区个数、大小可变。常用空闲分区表或空闲分区链来管理可用内存。</p>
<p><strong>动态分区分配算法</strong>：</p>
<ol>
<li><strong>首次适应（FF）</strong>：将空闲分区按地址递增的次序排列，找第一个满足大小要求的空闲分区。优点是保留了高地址的大空闲区，缺点是低地址产生碎片，增加查找开销；</li>
<li><strong>循环首次适应（NF）</strong>：按地址递增的次序排列，从上次找到的空闲分区的下一个空闲分区开始查找。优点是空闲分区分布更均匀，缺点是缺乏大空闲区；</li>
<li><strong>最佳适应（BF）</strong>：按容量大小递增排序，找满足大小要求的最小空闲分区。缺点是产生大量碎片；</li>
<li><strong>最坏适应（WF）</strong>：按容量大小递减排序，找满足大小要求的最大空闲分区。</li>
</ol>
<h4 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h4><p>在动态分区分配方式的基础上增加<strong>紧凑</strong>功能：将内存中的所有作业进行移动，将多个分散的空闲分区拼接成一个大分区。</p>
<h3 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h3><p><strong>对换</strong>指把内存中<strong>暂时不能运行</strong>的进程或暂时不用的<strong>程序和数据</strong>调出到外存上，以便腾出足够的内存空间，再把<strong>已具备运行条件的进程</strong>或<strong>进程所需的程序和数据</strong>调入内存。</p>
<p>优点：改善内存利用率，提高处理机利用率和系统吞吐量。</p>
<p>类型：</p>
<ul>
<li>整体对换：以进程为单位；</li>
<li>页面（分段）对换：以页或段为单位。</li>
</ul>
<h3 id="离散分配方式"><a href="#离散分配方式" class="headerlink" title="离散分配方式"></a>离散分配方式</h3><p>离散分配方式分为以下三种：</p>
<ul>
<li><strong>分页存储管理方式</strong></li>
<li><strong>分段存储管理方式</strong></li>
<li><strong>段页式存储管理方式</strong>：程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页</li>
</ul>
<h3 id="分页和分段的比较"><a href="#分页和分段的比较" class="headerlink" title="分页和分段的比较"></a>分页和分段的比较</h3><ol>
<li>页是信息的<strong>物理</strong>单位，分页是为了实现离散分配，提高内存利用率；段是信息的<strong>逻辑</strong>单位，分段是为了满足用户需求。</li>
<li>页大小固定且由系统决定；段长度不固定，且由用户编写的程序决定。</li>
<li>分页的地址空间是一维线性的；分段的地址空间是二维的。</li>
</ol>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h3><ul>
<li>理论基础：局部性原理</li>
<li>定义：具有<strong>请求调入</strong>功能和<strong>置换</strong>功能，能从<strong>逻辑</strong>上对内存容量加以扩充的一种存储器系统</li>
<li>特性：<ul>
<li>离散性：实现的前提；</li>
<li>多次性：一个作业被分多次调入内存；</li>
<li>对换性：允许在作业运行过程中换入、换出；</li>
<li>虚拟性：能从逻辑上扩充内存容量。</li>
</ul>
</li>
<li>实现：分页请求系统 / 分段请求系统</li>
</ul>
<h3 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h3><p>为了支持虚拟存储器功能，在基本分页基础上增加请求调页功能和页面置换功能。</p>
<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p>
<p>请求分段存储管理方式与其在实现原理及所需硬件支持上都十分相似。</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="1-最佳（Optimal）"><a href="#1-最佳（Optimal）" class="headerlink" title="1. 最佳（Optimal）"></a>1. 最佳（Optimal）</h4><p>将<strong>最长时间内不再被访问</strong>的页面换出。通常可以保证获得最低的缺页率，然而是一种<strong>理论上的算法</strong>，因为无法知道一个页面多长时间不再被访问。</p>
<h4 id="2-先进先出（FIFO）"><a href="#2-先进先出（FIFO）" class="headerlink" title="2. 先进先出（FIFO）"></a>2. 先进先出（FIFO）</h4><p>将<strong>最先进入的页面</strong>换出。</p>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<h4 id="3-最近最久未使用（LRU）"><a href="#3-最近最久未使用（LRU）" class="headerlink" title="3. 最近最久未使用（LRU）"></a>3. 最近最久未使用（LRU）</h4><p>将<strong>最近最久未使用</strong>的页面换出。</p>
<p>可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面总是在栈顶，而最近最久未使用的页面总是在栈底。</p>
<h4 id="4-Clock"><a href="#4-Clock" class="headerlink" title="4. Clock"></a>4. Clock</h4><p><img src="https://user-images.githubusercontent.com/18595460/40115969-be203032-5944-11e8-9f36-cfc7bf5426d2.png" alt="clock"></p>
<p>为每个页面设置一个<strong>访问位</strong>，当该页面被访问或首次调入内存时，将访问位置为 1。</p>
<p>首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。</p>
<h3 id="“抖动”"><a href="#“抖动”" class="headerlink" title="“抖动”"></a>“抖动”</h3><ul>
<li><strong>根本原因</strong>：同时在系统中运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求；</li>
<li>其他原因：置换算法选择不当；全局置换使抖动传播；</li>
<li><strong>现象</strong>：致使每个进程在运行时，频繁出现缺页；</li>
<li><strong>后果</strong>：排队等待页面调入/调出的进程数目增加，处理机利用率极具下降，有效工作停滞。</li>
<li>预防方法：<ul>
<li>采取局部置换策略：缺页时只在分配给自己的内存空间进行置换，不从其他进程获得新的物理块，以限制抖动的传播；</li>
<li>把工作集算法融入到处理机调度中：工作集指近期进程访问页面集合；</li>
<li>利用“L=S”准则调节缺页率：L 是缺页之间的平均时间，S 是平均缺页服务时间；</li>
<li>挂起某些优先级低的进程。</li>
</ul>
</li>
</ul>
<h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><p>管理对象：I/O 设备、相应的设备控制器、通道。</p>
<p>主要任务：完成用户提出的 I/O 请求，提高 I/O 速率，以及提高设备的利用率，并能为更高层的进程方便地使用这些设备提供手段。</p>
<h3 id="I-O-系统的基本功能"><a href="#I-O-系统的基本功能" class="headerlink" title="I/O 系统的基本功能"></a>I/O 系统的基本功能</h3><ol>
<li>隐藏物理设备的细节；</li>
<li>与设备的无关性；</li>
<li>提高处理机和 I/O 设备的利用率；</li>
<li>对 I/O 设备进行控制；</li>
<li>确保对设备的正确共享；</li>
<li>错误处理。</li>
</ol>
<p>其中，对 I/O 设备进行控制有四种方式：</p>
<ol>
<li>采用轮询的可编程 I/O 方式；</li>
<li>采用中断的可编程 I/O 方式；</li>
<li>直接存储器访问方式；</li>
<li>I/O 通道方式。</li>
</ol>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p><strong>中断</strong>是指 CPU 对 I/O 设备发来的终端信号的一种响应。CPU 暂停正在执行的程序，保留 CPU 环境后，自动转去执行该 I/O 设备的中断处理程序。执行完后，再回到断点，继续执行原来的程序。</p>
<p>中断是<strong>多道程序</strong>实现的基础，因为进程之间的切换是通过中断来完成的；中断也是<strong>设备管理</strong>的基础，为了提高处理机的利用率和实现 CPU 与 I/O 设备并行执行，必须有中断的支持。</p>
<p>另外，还有<strong>异常</strong>（由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等）和<strong>陷入</strong>（在用户程序中使用系统调用）。</p>
<h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>由 OS 向用户提供的所有内核态的功能，用户进程（应用程序）都必须通过<strong>系统调用</strong>这个中介过程来获取。C 语言首先提供了与系统调用相对应的库函数。</p>
<h3 id="假脱机（SPOOLING）系统"><a href="#假脱机（SPOOLING）系统" class="headerlink" title="假脱机（SPOOLING）系统"></a>假脱机（SPOOLING）系统</h3><p>假脱机技术是对脱机输入/输出系统的模拟，建立在通道技术和多道程序技术的基础上，以高速随机外存（通常为磁盘）为后援存储器。通过假脱机技术，可<strong>将一台物理 I/O 设备虚拟为多台逻辑 I/O 设备</strong>，以允许多个用户共享一台物理 I/O 设备。</p>
<p><strong>原理</strong>：用多道程序中的两道分别模拟输入/输出时的外围控制机功能，在高速磁盘和低速 I/O 设备间传送数据。</p>
<p><strong>组成</strong>：</p>
<ol>
<li>输入井和输出井：在磁盘上开辟的两个存储区域，模拟脱机输入/输出时的磁盘；</li>
<li>输入缓冲区和输出缓冲区：在内存中开辟的两个缓冲区，用于缓和 CPU 和磁盘间速度不匹配的矛盾；</li>
<li>输入进程和输出进程：模拟脱机输入/输出时的外围控制机；</li>
<li>井管理程序：用于控制作业与磁盘井之间信息的交换。</li>
</ol>
<p><strong>特点</strong>：</p>
<ol>
<li>提高了 I/O 的速度；</li>
<li>将独占设备改造为共享设备；</li>
<li>实现了虚拟设备功能。</li>
</ol>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>缓冲引入的原因：</p>
<ol>
<li>缓和 CPU 与 I/O 设备间速度不匹配的矛盾；</li>
<li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制；</li>
<li>解决数据粒度不匹配的问题；</li>
<li>提高 CPU 和 I/O 设备之间的并行性。</li>
</ol>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>磁盘访问时间包括<strong>寻道时间</strong>（主要）、<strong>旋转延迟时间</strong>和<strong>传输时间</strong>。当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。磁盘调度的目标是使磁盘的平均寻道时间最少。</p>
<h4 id="1-先来先服务（FCFS）-1"><a href="#1-先来先服务（FCFS）-1" class="headerlink" title="1. 先来先服务（FCFS）"></a>1. 先来先服务（FCFS）</h4><p>根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h4 id="2-最短寻道时间优先（SSTF）"><a href="#2-最短寻道时间优先（SSTF）" class="headerlink" title="2. 最短寻道时间优先（SSTF）"></a>2. 最短寻道时间优先（SSTF）</h4><p>要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。</p>
<p>会出现饥饿现象。当新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。</p>
<h4 id="3-扫描算法"><a href="#3-扫描算法" class="headerlink" title="3. 扫描算法"></a>3. 扫描算法</h4><p>在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。</p>
<p>当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。</p>
<h4 id="4-循环扫描算法"><a href="#4-循环扫描算法" class="headerlink" title="4. 循环扫描算法"></a>4. 循环扫描算法</h4><p>对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>由创建者所定义的、具有文件名的一组相关元素的集合。从逻辑结构角度分为<strong>有结构文件</strong>（由若干个相关记录组成）和<strong>无结构文件</strong>（被看成一个字符流），在文件系统中是一个最大的数据单位。</p>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><ul>
<li>文件控制块（FCB）：OS 用于<strong>描述</strong>和<strong>控制</strong>文件的一个<strong>数据结构</strong>。</li>
<li>目录：文件控制块的有序集合。</li>
<li>索引节点：<strong>文件描述信息</strong>单独形成的数据结构（而不包含文件名）。由于检索目录文件只用到文件名，即用不到该文件的描述信息，因此检索目录时索引节点不用调入内存，从而大大节省了系统开销。</li>
</ul>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>常用的两种文件共享方法：</p>
<ol>
<li>基于有向无环循环图（利用索引节点）；</li>
<li>利用符号链。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要参考西安电子科技大学出版社《计算机操作系统（第四版）》。</p>
<p>其他参考资料：</p>
<ul>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md">Interview-Notebook/notes/计算机操作系统.md</a></li>
<li><a href="https://wenku.baidu.com/view/e181715fc77da26924c5b023.html">操作系统重点知识总结_百度文库</a></li>
<li><a href="http://www.baike.com/wiki/%E5%A4%84%E7%90%86%E6%9C%BA">处理机_互动百科</a></li>
</ul>
]]></content>
      <categories>
        <category>学科补完计划</category>
      </categories>
      <tags>
        <tag>学科复习笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>中文短文本情感分析 web 应用开发记录（一）</title>
    <url>/blog/sentiment-analysis-webapp-record1/</url>
    <content><![CDATA[<p>“中文短文本情感分析 web 应用”是我带领的小组在《软件工程》这门课的大作业选题。按照这门课大作业的传统风格，就是做一个比较寻常的网站/APP，不过我这次提议另辟蹊径，一是我个人对情感分析这个方面比较感兴趣，想要借此机会进行了解和实践；二是组内成员都志在继续深造，做一个带有科研意味的项目或许能为简历添色。</p>
<p>先简单介绍一下我们的项目。该 web 应用可分析用户输入的中文短文本中蕴含的情感，并输出数值化结果。前端使用 Vue.js 开发，后台使用 Flask 开发。算法部分目前包含自主实现的词袋模型和引入的 SnowNLP。项目地址如下（目前服务器关了，想要尝试效果可以将项目 clone 到本地，照着 README 运行）：</p>
<ul>
<li><a href="http://kyonhuang.top/sentiment-analysis-webapp/">在线使用地址</a></li>
<li><a href="https://github.com/bighuang624/sentiment-analysis-webapp">项目地址</a></li>
</ul>
<p>截止这篇博文写作时，这个项目算是成型，也在 Github 上获得了 7 个 star。但是也遇到了一些问题，当然最大的问题就是分析效果不好。效果不好的原因包括很多，后文会一一介绍，当然其中一个是我们目前的算法部分还没有涉及到深度学习，不过我正在争取在近期用 LSTM 等实现效果较好的模型。</p>
<p>这篇博文首先会简单介绍情感分析的概念、技术和难点。之后针对我们的项目，详细介绍我们使用的算法、迄今为止遇到的问题和一些改进措施。</p>
<span id="more"></span>

<h2 id="什么是情感分析？"><a href="#什么是情感分析？" class="headerlink" title="什么是情感分析？"></a>什么是情感分析？</h2><p><strong>情感分析（Sentiment analysis）</strong>或意见挖掘（Opinion mining）是对人群对于产品、服务、组织、个体、问题、事件、话题等实体的意见、情感、情绪、评价、态度的计算研究。鉴于网络社交媒体的风行，我们拥有了海量的情绪化数据。情感分析已经成为自然语言处理中最有吸引力的研究领域之一，它与管理科学、社会科学领域有交集。情感分析在现实中的典型应用包括舆情分析、民意调查、产品意见调查、预测股票市场行情等等。</p>
<p>最典型的情感分析会分析一段文本对某个对象的情感是正面的还是负面。更细致的处理包括情感的分类（快乐、愤怒、恐惧、悲哀等）和情感的程度。意见挖掘可能还需要从文本中挖掘出对象的属性，再分析对应属性的情感。</p>
<p>早期的情感分析技术包括监督方法（支持向量机、最大熵、朴素贝叶斯等监督机器学习方法）和非监督方法（包括利用情感词汇、语法分析和句法模式的各种方法），而深度学习走红后，其应用到情感分析的出色效果催生大量基于深度学习的情感分析研究[1]。</p>
<h2 id="中文情感分析的难点"><a href="#中文情感分析的难点" class="headerlink" title="中文情感分析的难点"></a>中文情感分析的难点</h2><p>以下是我在查阅资料后总结的一些中文情感分析的难点：</p>
<ol>
<li>很多情感的表达是隐晦的，没有特别明显的代表性词语。例如“蓝屏”这个词一般不会出现在情感词典之中，但这个词明显表达了不满的情绪。因此需要另外根据具体领域构建针对性的情感词典。</li>
<li>同一个词在不同语境或领域里有不同的意思，可能表达不同的情感态度，例如“我家洗衣机声音很大”这些很可能是差评，而“我家音响声音很大”很可能就是好评。反讽的表达同理。</li>
<li>网络流行语等新词也会影响情感分析，比如“给力”、“不明觉厉”、“累觉不爱”等，这些词利用传统的分词一般都会被切开，而且会影响词性标注，如果想避免只能加入人工干预，修改分词的粒度和词性标注的结果。</li>
<li>以上三条在做英语情感分析时也会遇到。但是中文独有的问题是缺少高质量的有标注数据集。相比起来，英文情感分析有公认的数据集 <a href="http://ai.stanford.edu/~amaas/data/sentiment/">IMDB</a>。此外，可能还需要一些高质量的情感词典，英文有 SentiWordNet，但是中文的词典资源质量不高，不细致，另外缺乏主客观词典。当然，因为有监督的机器学习方法的风行，现在情感分析也不一定非要情感词典。</li>
</ol>
<p>因为我们的项目主要还是拿文本分类的方法进行处理，所以以上问题不是都遇到了，仅停留在了解层面，如有谬误欢迎指出。</p>
<h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>首先谈谈数据。根据前文所述，中文的有标注数据集很难找。我前两周和做过类似工作的学长交流时，他的做法是自行标注。而我们选择的做法是自己用 Python 编写爬虫爬取各类含评论的网站，将评论正文作为数据，评论的星级作为标签：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/douban-comment.png"></p>
<p>我们最终爬取了豆瓣的 146856 条电影评论和蜂窝网的 174055 条酒店评论作为我们的数据集。你可以在 <a href="https://github.com/bighuang624/sentiment-analysis-webapp/tree/master/training">sentiment-analysis-webapp/training/</a> 找到这两份数据以及训练模型的代码。</p>
<p>我们希望最终给出的结果也能反应情感的程度，而不是单纯的正负二元分类。因此，我们没有对标签做后续处理。</p>
<h3 id="算法部分实现过程"><a href="#算法部分实现过程" class="headerlink" title="算法部分实现过程"></a>算法部分实现过程</h3><h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>既然是使用监督机器学习算法，那么自然需要特征。计算机是看不懂自然语言的，<strong>从文本中提取特征</strong>最终的结果一般是将文本转换为<strong>向量</strong>，而这一步不管是使用什么算法，都需要首先对文本进行分词。</p>
<p>成熟的中文分词工具还是比较多的，包括 <a href="https://github.com/FudanNLP/fnlp">FudanNLP</a>、结巴分词、THULAC、Stanford CoreNLP。其中 Stanford CoreNLP 是重量级工具，需要自备数据集、数据字典等，不太方便；另外三个工具经过简单的比较后，我们最终选用了结巴分词，因为确实很容易使用，分词效果也很好。</p>
<p>分词的相关代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_word_cut</span>(<span class="params">mytext</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(jieba.cut(mytext))</span><br><span class="line">    </span><br><span class="line">X[<span class="string">&#x27;cutted_comment&#x27;</span>]=X.comment.apply(chinese_word_cut)</span><br></pre></td></tr></table></figure>

<h4 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h4><p>我们的算法都是使用 scikit-learn 实现的，其中从文本中提取特征的方法在<code>sklearn.feature_extraction.text</code>包中。</p>
<p>比较典型的自然语言向量化方法有词袋模型（带或不带 TF-IDF）、词嵌入等等，在这里可以简单的介绍一下。</p>
<h5 id="词袋模型"><a href="#词袋模型" class="headerlink" title="词袋模型"></a>词袋模型</h5><p><strong>词袋模型（bag of words）</strong>是信息检索领域常用的文档表示方法。其前提是不考虑词语的出现顺序，也不考虑词语和前后词语之间的连接。<strong>文档中每个单词的出现都是独立的，不依赖于其它单词是否出现</strong>。这样，每个句子被编码成一个 $R^{|V| \times 1}$向量，其中 $|V|$是语料库中所有单词的数量。所有单词组成一个词汇表，每个句子向量的第 $i$ 位即是词汇表中第 $i$ 个词在句子中出现的次数。</p>
<p>词袋模型可以以单个词语做单位，也可以以 n 个连续的单词做单位（被称为 n-gram）。词袋模型的优点是原理简单，容易实现；其缺点是文本中单词顺序和上下文所蕴含的信息被完全丢弃。</p>
<p>词袋模型的相关代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"></span><br><span class="line">max_df=<span class="number">0.8</span> <span class="comment">#在超过这一比例的文档中出现的关键词过于平凡，去除掉</span></span><br><span class="line">min_df=<span class="number">3</span> <span class="comment">#在低于这一数量的文档中出现的关键词过于独特，去除掉</span></span><br><span class="line"></span><br><span class="line">vect = CountVectorizer(max_df=max_df, min_df=min_df, token_pattern=<span class="string">u&#x27;(?u)\\b[^\\d\\W]\\w+\\b&#x27;</span>)</span><br><span class="line">term_matrix = pd.DataFrame(vect.fit_transform(X_train.cutted_comment).toarray(), columns=vect.get_feature_names())</span><br></pre></td></tr></table></figure>

<h5 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h5><p>TF-IDF 是在词袋模型的基础上<strong>度量词语重要性</strong>的指标。其基于基本假设：<strong>对区别文档最有意义的词语应该是那些在文档中出现频率高，而在整个文档集合的其他文档中出现频率少的词语，所以如果特征空间坐标系取TF词频作为测度，就可以体现同类文本的特点</strong>。</p>
<p>根据以上思想，我们通过 TF-IDF 这个指标来寻找重要的词语。TF（Term Frequency）指<strong>词项频率</strong>，用于计算该词描述文档内容的能力；IDF（Inverse Document Frequency）指<strong>逆文档频率</strong>，用于计算该词区分文档的能力。TF-IDF 通过以下方法计算：假定文档集中有 $N$ 篇文档，$f_{ij}$ 为词项 $i$ 在文档 $j$ 中出现的频率（即次数），则词项 $i$ 在文档 $j$ 中的词项频率 $TF_{ij}$ 定义为</p>
<p>$$TF_{ij} = \frac{f_{ij}}{max_kf_{kj}}$$</p>
<p>这里有一个归一化的操作，通过除以同一文档中出现最多的词项（可能不考虑停用词的频率）的频率来计算。</p>
<p>假定词项 $i$ 在文档集的 $n_i$ 篇文档中出现，那么词项 $i$ 的 IDF 定义如下：</p>
<p>$$IDF_i = log_2{\frac{N}{n_i}}$$</p>
<p>于是词项 $i$ 在文档中的得分被定义为 $TF_{ij} \times IDF_i$。相关代码如下（其实就是将<code>sklearn.feature_extraction.text</code>提供的<code>CountVectorizer</code>换为<code>TfidfVectorizer</code>）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">max_df=<span class="number">0.8</span> <span class="comment">#在超过这一比例的文档中出现的关键词过于平凡，去除掉</span></span><br><span class="line">min_df=<span class="number">3</span> <span class="comment">#在低于这一数量的文档中出现的关键词过于独特，去除掉</span></span><br><span class="line"></span><br><span class="line">vect = TfidfVectorizer(max_df=max_df, min_df=min_df, token_pattern=<span class="string">u&#x27;(?u)\\b[^\\d\\W]\\w+\\b&#x27;</span>)</span><br><span class="line">term_matrix = pd.DataFrame(vect.fit_transform(X_train.cutted_comment).toarray(), columns=vect.get_feature_names())</span><br></pre></td></tr></table></figure>

<p>TF-IDF 在通用情况下效果一般不错，但是也存在一些问题：（1）单纯地认为文本频数小的单词就越重要，文本频数大的单词就越无用；（2）没有体现出单词的位置信息（例如在 Web 文档中处于网页不同位置或标签中的词应该有不同的权重）。</p>
<h5 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h5><p><strong>词嵌入（Word Embedding）</strong>是指把一个维数为所有词的数量的高维空间（one-hot 形式表示的词）“嵌入”到一个维数低得多的连续向量空间中，每个单词或词组被映射为实数域上的向量。因为我们暂时还没用到相关技术，所以不对学习词嵌入的方法进行介绍了（可能会在下一篇博文谈论）。想要了解更多可以看<a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Sequence_Models/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E4%B8%8E%E8%AF%8D%E5%B5%8C%E5%85%A5">自然语言处理与词嵌入 - 吴恩达《深度学习》系列课程笔记</a>。</p>
<h4 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h4><p>谈一下停用词的问题。无论是处理中文还是英文，都需要处理停用词。<strong>停用词指那些用于辅助表达但本身不携带任何含义的词</strong>，比如英文中的定冠词“the”。这些词经常在文本中大量出现，如果将其和那些包含信息更丰富的词汇放在一起统计，就容易对我们把握文本的特征形成干扰。所以在文本分类中，一般要首先在文本数据中去掉这些停用词。</p>
<p>scikit-learn 中自带了英文停用词。如果想做中文停用词的处理，可以用一些机构开源的停用词表。哈工大、四川大学、百度都有类似的词表，可以在<a href="https://github.com/chdd/weibo/tree/master/stopwords">这里</a>找到。</p>
<p>不过一个值得讨论的问题是，我们做的是情感分析工作，而非单纯的文本分类。实际上，很多语气词和标点等都是停用词，但是却对句子的情感表达有着很大的影响。因此，一般在做情感分析工作时，倾向于不去处理停用词。我们会在后文的效果展示中讨论是否去除停用词对我们实际的模型效果的影响。</p>
<p>还是放一下处理停用词的相关代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_custom_stopwords</span>(<span class="params">stop_words_file</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(stop_words_file) <span class="keyword">as</span> f:</span><br><span class="line">        stopwords = f.read()</span><br><span class="line">    stopwords_list = stopwords.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    custom_stopwords_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> stopwords_list]</span><br><span class="line">    <span class="keyword">return</span> custom_stopwords_list</span><br><span class="line">    </span><br><span class="line">stop_words_file = <span class="string">&quot;stopwords.dat&quot;</span> <span class="comment"># 停用词表文件名</span></span><br><span class="line">stopwords = get_custom_stopwords(stop_words_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里增加了一个选项</span></span><br><span class="line">vect = CountVectorizer(max_df = max_df, </span><br><span class="line">                       min_df = min_df, </span><br><span class="line">                       token_pattern=<span class="string">u&#x27;(?u)\\b[^\\d\\W]\\w+\\b&#x27;</span>, </span><br><span class="line">                       stop_words=<span class="built_in">frozenset</span>(stopwords))</span><br></pre></td></tr></table></figure>

<h4 id="分类器"><a href="#分类器" class="headerlink" title="分类器"></a>分类器</h4><p>我们初期使用的分类算法是<a href="http://kyonhuang.top/Machine-learning-in-action-notes/#/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF">朴素贝叶斯</a>，相关代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line">nb = MultinomialNB()</span><br><span class="line">nb.fit(X_train.cutted_comment, y_train)</span><br></pre></td></tr></table></figure>

<h4 id="管道和模型持久化"><a href="#管道和模型持久化" class="headerlink" title="管道和模型持久化"></a>管道和模型持久化</h4><p>scikit-learn 提供<strong>管道</strong>功能，可以将处理流程中的工作顺序连接，隐藏其中的功能，从外部一次调用，就能完成顺序定义的全部工作。这样做可以简化调用过程，减少出错几率。</p>
<p>同时，scikit-learn 也支持<strong>模型持久化</strong>，即将训练好的模型保存到硬盘，待后台程序启动时可以直接加载到内存。这样，就不必每次启动后台程序时都要花费大量时间和资源进行训练了。相关代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br><span class="line">pipe = make_pipeline(vect, nb)</span><br><span class="line">pipe.fit(X_train.cutted_comment, y_train)</span><br><span class="line">y_pred=pipe.predict(X_test.cutted_comment)</span><br><span class="line">joblib.dump(pipe, <span class="string">&quot;hotel_comment.pkl&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>为了量化模型效果，需要模型实际预测输出和样本真是输出之间的差异（即<strong>误差</strong>）。因为过拟合的存在，训练误差不适合作为模型选择标准，因此需要从数据集中划分出与训练集互斥的测试集，以测试误差作为泛化误差的近似。</p>
<p>这里，我们选用<strong>交叉验证法（cross-validation）</strong>，这是一种十分常用的模型评估方法。<strong>k 折交叉验证（k-fold CV）</strong>指划分 k 个互斥子集，每次用 k-1 个子集作训练集，余下一个子集作测试集，进行 k 次训练与测试并取均值。其优点是结果准确，Kaggle 的参赛者大多会提交 CV 分最高的模型，而非在官方提供的测试集上得分最高的模型；缺点是计算量比较大。</p>
<p>常用的 k 值包括 5、10、20。这里我们统一用 5 折交叉验证来分析各种搭配得到的模型效果。其中所使用的停用词为<a href="https://github.com/dongxiexidian/Chinese/blob/master/stopwords.dat">这份</a>。</p>
<p>对于豆瓣数据集，各种模型的评分如下：</p>
<ul>
<li>CountVectorizer + 不去除停用词：0.505020743656528</li>
<li>CountVectorizer + 去除停用词：0.4937080095876466</li>
<li>TfidfVectorizer + 不去除停用词：0.49594151903667905</li>
</ul>
<p>而对于酒店数据集，各种模型的评分如下：</p>
<ul>
<li>CountVectorizer + 不去除停用词：0.5133750057452774</li>
<li>CountVectorizer + 去除停用词：0.5060018311093455</li>
<li>TfidfVectorizer + 不去除停用词：0.5297950445100629</li>
</ul>
<p>可以看到，去除停用词的效果普遍比不去除停用词要差。而词袋模型和 TF-IDF 的效果比较结果则与数据集有关，这也说明需要针对具体问题选择合适的学习算法。</p>
<h2 id="问题和改进措施"><a href="#问题和改进措施" class="headerlink" title="问题和改进措施"></a>问题和改进措施</h2><p>从之前 CV 的分数，可以判断我们模型的正确率大概在 50% 左右，相比起在 5 种给分中随机预测的 20% 看似要好很多，但实际表现为不管输入的是正面还是负面情感句子、程度如何，基本上都给 5 分，偶尔会给 4 分。</p>
<h3 id="样本类别不均衡"><a href="#样本类别不均衡" class="headerlink" title="样本类别不均衡"></a>样本类别不均衡</h3><p>从模型经常给出高分预测的表现，我们很容易做出样本中<strong>正负类别样本不均衡</strong>的判断。实际上，我们的酒店评论数据集中，有 148939 条标签值大于 3，而只有 6895 条标签值小于 3，比例达到 21.6 : 1。豆瓣数据集情况略好，但正负面评论数比例也达到了 5.69 : 1。数据集中样本类别不均衡导致训练出的模型偏向于给出正面预测，以减小损失函数。</p>
<p>处理样本不均衡的方式包括以下几种：</p>
<ul>
<li><p><strong>尝试其他评价指标</strong>：当样本类别不均衡时，准确度这个指标不但没有说服力，反而会对分类器的好坏产生误导。这时，<strong>精确率（Precision）</strong>、<strong>召回率（Recall）</strong>以及 <strong>F1 得分（F1 Score，精确率与召回率的调和平均）</strong>作为评价指标会更加有效。</p>
</li>
<li><p><strong>对数据集进行过采样和欠采样</strong>：</p>
<ul>
<li><strong>过采样（over-sampling）</strong>指采样个数大于该类样本个数，适用于小类的数据样本。具体表现为添加部分样本的副本；</li>
<li><strong>欠采样（under-sampling）</strong>指采样个数小于该类样本个数，适用于大类的数据样本。具体表现为删除部分样本。</li>
</ul>
</li>
<li><p><strong>数据增强</strong>：数据增强是 CV 中经常使用的方式，联系到 NLP 领域，可以将文本进行句子顺序打乱、句内词序打乱、同义词替换等操作来增加相应类别的样本量。</p>
</li>
</ul>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>使用 scikit-learn 提供的方法，我们来计算一下在原始酒店数据集上用 TfidfVectorizer + 不去除停用词训练出来的模型的精确率、召回率和 F1 得分：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">metrics.accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0.5307027623293653</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">metrics.confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[    0,     0,   151,   237,    27],</span></span><br><span class="line"><span class="string">       [    0,     0,   227,  1017,   106],</span></span><br><span class="line"><span class="string">       [    0,     0,   530,  3603,   507],</span></span><br><span class="line"><span class="string">       [    0,     1,   327, 12089,  6894],</span></span><br><span class="line"><span class="string">       [    0,     0,    58,  7266, 10474]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">metrics.precision_score(y_test, y_pred, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0.29816554278872476</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">metrics.recall_score(y_test, y_pred, average=<span class="string">&#x27;micro&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0.5307027623293653</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">metrics.f1_score(y_test, y_pred, average=<span class="string">&#x27;weighted&#x27;</span>)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0.5048778200537771</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到精确率相对来说比较低。</p>
<!--1. 说明什么？
2. 进一步处理数据-->

<h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><p>解决了样本类别不均衡以及模型评估的问题，我们很容易想到，我们一开始采用的朴素贝叶斯是否是在这个问题上表现最好的机器学习模型？SVM、随机森林或者 Kaggle 前任大杀器 XGBoost 会不会有更出色的结果？</p>
<p>To be continued…</p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>文本分类中常见的特征选择方法除开 TF-IDF 外，还包括信息增益、互信息、期望交叉熵、CHI 统计等[2]。根据清华大学刘知远老师在博士阶段的研究，TF-IDF 具有较强的普适性，能够满足绝大部分的中文场景下的需求。不过也有其他研究工作表明使用信息增益的性能表现也很优秀。由于我们之后会使用深度学习模型在做端到端的学习，并且特征选择不是目前的瓶颈，因此这里不进行深入研究。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过这个项目，我感觉我确实很喜欢情感分析这个研究方向。我也因此承担了绝大部分的算法研究开发工作，查阅了很多文献和网络资料，由此对情感分析研究现状乃至自然语言处理的一些基础知识有了比较深入的了解，可谓受益匪浅。</p>
<p>比较可惜的是，我们在课程作业结题时实现的版本还不尽人意，而且因为事务忙碌和自身安排原因，深度学习模型计划了很久都没有动手实现。写这篇博文一是对现有工作做一个总结，同时有些算法写的比较详细，巩固一下所学知识；二就是督促自己尽早实现基于深度学习的模型，届时也会出该系列的第二篇博文。也欢迎看到这里的读者在 Github 和这里继续关注我们的工作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="引用文献"><a href="#引用文献" class="headerlink" title="引用文献"></a>引用文献</h3><ul>
<li>[1] <a href="https://arxiv.org/abs/1801.07883">Deep Learning for Sentiment Analysis : A Survey</a>. Lei Zhang, Shuai Wang, Bing Liu.</li>
<li>[2] 徐泓洋, 杨国为. <a href="http://www.wanfangdata.com.cn/details/detail.do?_type=perio&id=gykzjsj201711038">中文文本特征选择方法研究综述</a>[J]. 工业控制计算机, 2017, 30(11):80-81.</li>
</ul>
<h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><ul>
<li>《互联网大规模数据挖掘与分布式处理》 1.3.1</li>
</ul>
<h3 id="网络资料"><a href="#网络资料" class="headerlink" title="网络资料"></a>网络资料</h3><ul>
<li><a href="https://www.zhihu.com/question/20700012">中文情感分析 (Sentiment Analysis) 的难点在哪？现在做得比较好的有哪几家？ - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34482959">如何用Python和机器学习训练中文文本情感分类模型？</a></li>
<li><a href="https://blog.csdn.net/simona081/article/details/80275506">处理文本分类中样本不均衡的问题 - CSDN博客</a></li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>开源小项目</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>自然语言处理</tag>
        <tag>文本分类</tag>
        <tag>情感分析</tag>
        <tag>情感计算</tag>
      </tags>
  </entry>
  <entry>
    <title>自动编码器一览（一）</title>
    <url>/blog/autoencoder-intro-1/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/autoencoder-roadmap.png"></p>
<p>最近在研究用自动编码器（Autoencoder, AE）做表征学习（Representation Learning），看了一些资料和论文，自己也有一些想法，现在准备开始写 related work，值此机会想要先整理一下。题图来自 THU 唐杰老师的微博，清晰地展现了自动编码器的发展历程。</p>
<p>本系列预计会写三篇博文，第一篇包含自动编码器的总体框架和思想，之后介绍为实现各种目标而产生的一些经典变体，会涵盖题图中提到的大部分自动编码器；第二篇包含一些我个人比较感兴趣、最近看过的一些变形，它们更适用于各自的任务；第三篇可能会拖得稍微久一点，我想把最近非常火热的变分自动编码器以及它的一些变形弄通。</p>
<p>本文中包含以下内容：</p>
<ul>
<li>表征学习简介（Representation Learning Intro）</li>
<li>自动编码器框架（Autoencoder Framework）</li>
<li>堆叠自动编码器（Stacked Autoencoder）</li>
<li>去噪自动编码器（Denoising Autoencoder, DAE）</li>
<li>收缩自动编码器（Contractive AutoEncoder, CAE）</li>
<li>稀疏自动编码器（Sparse Autoencoder）</li>
<li>LSTM 自动编码器（LSTM Autoencoder）</li>
<li>卷积自动编码器（Convolutional Autoencoder）</li>
</ul>
<p>“自动编码器一览”系列：</p>
<ul>
<li><a href="http://kyonhuang.top/autoencoder-intro-1/">自动编码器一览（一）</a></li>
<li><a href="http://kyonhuang.top/autoencoder-intro-2/">自动编码器一览（二）</a></li>
<li><a href="http://kyonhuang.top/autoencoder-intro-3/">自动编码器一览（三）</a></li>
</ul>
<span id="more"></span>

<h2 id="表征学习"><a href="#表征学习" class="headerlink" title="表征学习"></a>表征学习</h2><p>在开始介绍自动编码器之前，我们首先对<strong>表征学习（Representation Learning，也称表示学习）</strong>做一个简单的介绍，帮助我们在之后更好地理解自动编码器架构设计的目的。</p>
<p>表征学习（或者称表示学习）指从原始数据中自动学习有效的<strong>特征</strong>（或者更一般性称为<strong>表征</strong>），并提高最终机器学习模型的性能。表征学习目前已经成为机器学习社区的热点之一，在每届 NIPS、ICML、ICLR 等会议都有较多的相关论文以及 workshops。</p>
<p>表征学习的关键是解决<strong>语义鸿沟（Semantic Gap）</strong>问题。语义鸿沟问题是指输入数据的底层特征和高层的语义信息之间的不一致性和差异性。比如图片分类任务，图片中每个物体的颜色和形状等属性都不尽相同，不同图片在像素级别上的表示（即底层特征）差异性也会非常大。人类理解这些图片是建立在比较抽象的高层语义概念上的，因此如果让一个分类模型直接建立在底层特征之上，会对模型的能力要求过高。如果有一个好的表示在某种程度上可以反映出数据的高层语义特征，那么我们就可以相对容易地构建后续的机器学习模型 [1]。</p>
<p>考虑到直接将高维度的原始数据输入到各类算法中会导致计算量非常大，因此，表征学习最大的目标之一就是在尽量保留对后续任务有用的信息的同时，对数据进行降维。比起进行线性降维的 PCA，自动编码器可以进行非线性的降维。同时，一个好的表征应该比较稀疏（用极可能少的资源表示尽可能多的信息，计算速度快）、对噪声不敏感（学习到的表征尽量不受原始数据中噪声的影响）、具有一般性，是任务或领域独立的（学习到的表征能够尽可能在更多任务上取得较好效果）、具有较好的可重构性、具有很强的表示能力（同样大小的向量可以表示更多信息）等等。</p>
<p>根据 [2] 所述，对表征学习的研究大致分为两类，一类基于概率图模型，另一类基于神经网络。这两类研究的根本区别在于，深度学习模型的层级结构被解释为对概率图模型的描述还是对计算图的描述。更简单地说，区别在于深度学习模型的隐藏单元是被视为潜在的随机变量还是计算节点。其中，自动编码器是后者的代表之一。</p>
<h2 id="自动编码器框架"><a href="#自动编码器框架" class="headerlink" title="自动编码器框架"></a>自动编码器框架</h2><p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/autoencoder_framework.png"></p>
<p>在这里，我们使用“自动编码器框架”来代指最基本的自动编码器架构和指导思想，以与单个自动编码器进行叙述上的区分。</p>
<p>自动编码器框架包含两个参数化函数。第一个函数 $f_{\theta}$ 称为<strong>编码器（encoder）</strong>，它从原始输入 $x$ 中提取特征向量 $h = f_{\theta}(x)$。第二个函数 $g_{\theta}$ 称为<strong>解码器（decoder）</strong>，它是一个从特征空间到输入空间的映射，产生一个<strong>重构（reconstruction）</strong> $r = g_{\theta}(h)$。通过让解码器产生的重构与作为输入的原始数据尽可能相似，即尝试在训练集上获得最小的重构损失 $L(x,r)$，编码器和解码器的参数组 $\theta$ 同时通过训练得到。具有较好泛化性意味着能够在测试集也取得较低的重构损失，而编码器所提取的特征向量即自动编码器框架学习得到的<strong>表征</strong>。</p>
<p>总结一下，自动编码器框架的训练目的是为了找到一组参数 $\theta$ 的值，使得重构损失最小。最经典的自动编码器使用多层感知器（Multi-Layer Perceptrons, MLPs）作为编码器和解码器，其常用的形式如下：</p>
<p>$$f_{\theta}(x) = s_f(Wx + b)$$</p>
<p>$$g_{\theta}(h) = s_g(W^{‘}h + b^{‘})$$</p>
<p>其中，$s_f$ 和 $s_g$ 是编码器和解码器所使用的激活函数，一般为非线性的 sigmoid、Relu 函数等。因此，模型整体的参数组 $\theta = { W, b, W^{‘}, b^{‘} }$，其中 $W$ 和 $W^{‘}$ 是编码器和解码器的权重矩阵，$b$ 和 $b^{‘}$ 是编码器和解码器的偏置向量。由于我们要求原始输入和输出尽可能相似，编码器和解码器可能最终被训练为恒等映射，不符合我们的要求，因此通常对表征做一定的约束。</p>
<p>由于自动编码器框架将原始输入同时作为模型的输入和输出，因此无需使用有标签的数据进行训练，这种无监督学习的方式使得自动编码器的通用性大为提升。其实早在 1988 年，自动编码器的思想就已经被提出，但是由于数据的稀疏高维，使得当时的模型很难优化，因此直到 2006 年，Hinton 采用梯度下降算法来逐层优化受限玻尔兹曼机（Restricted Boltzmann Machine，RBM）以获得对原始样本的抽象表示并取得显著效果后，自动编码器才得到广泛的关注。</p>
<h2 id="堆叠自动编码器"><a href="#堆叠自动编码器" class="headerlink" title="堆叠自动编码器"></a>堆叠自动编码器</h2><p>可以看到，最基本的自动编码器框架是一个简单的三层结构，包含输入层、隐藏层（中间层）和输出层。其中，输出层的存在是为了将原始数据作为假想的目标输出，以构建监督误差来训练整个网络。当训练结束后，我们就不再关心输出层，只关心从输入到中间层的映射。</p>
<p>考虑到深度神经网络是在逐层的学习数据的表征，在底层构建较为简单的特征，以此为基础在较高层构建更为复杂和抽象的表征，我们很容易想到，将最基本的自动编码器学习到的特征 $h$ 作为原始信息，再训练一个新的自动编码器，来得到新的特征表达。这就是论文 “Greedy Layer-Wise Training of Deep Networks” [3] 所提出的<strong>堆叠自动编码器（Stacked Autoencoder，又称栈式自动编码器）</strong>的基本思想。通过堆叠自动编码器学习到的高层表征更加抽象，具有更好的扩展性。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/Stacked-autoencoder.png"></p>
<p>显然，堆叠自动编码器的训练和普通的多层神经网络不同，不是每一遍逐层进行，而是首先训练得到最底层的自动编码器，得到其编码器函数，然后再训练更高层的自动编码器，最后堆叠得到整个堆叠自动编码器。因此，除开进行无监督表征学习，堆叠自动编码器也可以用来进行<strong>深度神经网络的初始化</strong>，在通过无监督学习得到堆叠自动编码器后可以在最后一个隐藏层后，根据具体任务加上一个输出层，并通过监督学习的方式，利用梯度下降对整个模型进行全局微调。这就是<strong>逐层非监督预训练（layer-wise unsuperwised pre-training）</strong>。</p>
<h2 id="去噪自动编码器"><a href="#去噪自动编码器" class="headerlink" title="去噪自动编码器"></a>去噪自动编码器</h2><p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/denoising_autoencoder.png"></p>
<p>考虑到自动编码器框架中的编码器和解码器本质上还是神经网络，因此，当神经网络的层数加深、结构愈发复杂而使参数增加时，自动编码器一样面临着过拟合的风险。在 ICML 2008 上，论文 “Extracting and composing robust features with denoising autoencoders” [4] 首次提出去噪自动编码器（Denoising Autoencoder, DAE）模型。为了强制让隐藏层学习到更加健壮的特征，去噪自动编码器 DAE 在输入层对原始输入加入随机噪声。</p>
<p>为了和图中符号匹配，请注意我们在本节中使用原论文 [4] 中的符号表示进行叙述，可能与前文中符号不同。去噪自动编码器 DAE 的描述如下：</p>
<ol>
<li>设有纯净输入（clean input）$\mathbf{x} \in [0, 1]^d$，通过部分损坏纯净输入得到损坏输入（corrupted input）$\tilde{\mathbf{x}} \sim q_{\mathcal{D}}(\tilde{\mathbf{x}} | \mathbf{x})$。</li>
<li>原论文中的输入损坏过程 $q_{\mathcal{D}}(\tilde{\mathbf{x}} | \mathbf{x})$ 是随机选择纯净输入 $\mathbf{x}$ 中固定比例的一部分（一般不超过一半），将这些部分的值设置为 0。当然可以使用其他方法来损坏数据，例如引入高斯噪声。</li>
<li>编码器函数 $f_{\theta}$ 将损坏输入 $\tilde{\mathbf{x}}$ 映射到隐藏表征 $\mathbf{y} = f_{\theta}(\tilde{\mathbf{x}})$。</li>
<li>解码器函数 $g_{\theta^{‘}}$ 将 $\mathbf{y}$ 重构为 $\mathbf{z} = g_{\theta^{‘}}(\mathbf{y})$。</li>
<li>通过训练来最小化交叉熵重构损失 $L_{H}(\mathbf{x}, \mathbf{z})=-\sum_{k=1}^{d}\left[\mathbf{x}_{k} \log \mathbf{z}_{k}+\left(1-\mathbf{x}_{k}\right) \log \left(1-\mathbf{z}_{k}\right)\right]$。</li>
</ol>
<p>可以看到，DAE 有两个功能：一是对输入进行编码，即保留输入中的有关信息；二是尝试消除应用于输入的随机损坏过程的影响。其中，后者只能通过捕捉输入之间的统计依赖关系来完成。也就是说，DAE 试图从未损坏的值中预测随机损坏的值。注意到，能够从其余变量中预测任何变量子集是完全捕获一组变量之间的联合分布的充分条件，这也是 Gibbs 采样的工作原理 [5]。可以看出，这里提到的随机损坏过程与目前已经在训练神经网络时广泛使用的 Dropout 非常相似（然而，DAE 的提出时间要早于 Dropout）。</p>
<p>原论文同时通过流形学习、信息论、生成模型等多种角度对 DAE 进行解释。其中，从流形学习（manifold learning）视角来看，如下图所示，DAE 可以看作是一种学习一个流形的方式。假设训练数据（下图中标<code>x</code> 的数据）聚集在一个低维流形的周围，那么损坏数据（下图中标<code>.</code>的数据）通过损坏过程得到，它们距离流形较远。因此，整个模型试图将损坏数据投影回流形上，这样的模型更加稳健。而中间层表征可以被解释为流形上点所在的坐标系。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/DAE-in-manifold-learning-perspective.png" alt="DAE-in-manifold-learning-perspective"></p>
<h2 id="收缩自动编码器"><a href="#收缩自动编码器" class="headerlink" title="收缩自动编码器"></a>收缩自动编码器</h2><p>同样是为了抑制过拟合，<strong>收缩自动编码器（Contractive AutoEncoder, CAE）</strong>[6] 采用的方法是与正则化相结合，在损失函数中加入编码器的雅克比（Jacobian）矩阵范式来约束。</p>
<p>$$\mathcal{J}_{\mathrm{CAE}}(\theta)=\sum_{x \in D_{n}}\left(L(x, g(f(x)))+\lambda\left\|J_{f}(x)\right\|_{F}^{2}\right)$$</p>
<p>上式是 CAE 的损失函数，可以看到其分为两部分，第一部分是原始自动编码器的损失函数，用于最小化重构误差；而第二部分是 F 范式下的雅克比矩阵，如下：</p>
<p>$$\left\|J_{f}(x)\right\|_{F}^{2}=\sum_{i j}\left(\frac{\partial h_{j}(x)}{\partial x_{i}}\right)^{2}$$</p>
<p>想要最小化损失函数，就要使得偏导尽可能小，从而使模型对局部的抖动具有健壮性。这样，在第一部分保留最具代表性的特征信息的同时，第二部分倾向于丢掉所有特征信息，两者的共同作用即是<strong>只</strong>保留具有代表性的好的特征信息。</p>
<p>和 DAE 相比，CAE 主要挖掘样本内在的特征，使用样本本身的梯度信息，而不考虑样本中未出现的情况；而 DAE 对输入加入了噪声，改变了原数据的分布，因此对样本中未出现的测试数据同样具有健壮性。同时，DAE 的实现比 CAE 要简单，无需计算隐藏层的雅克比矩阵。</p>
<h2 id="稀疏自动编码器"><a href="#稀疏自动编码器" class="headerlink" title="稀疏自动编码器"></a>稀疏自动编码器</h2><p>自动编码器除了可以学习低维表征外，也可以学习高维的稀疏表征。为了学习得到稀疏的表征，<strong>稀疏自动编码器（Sparse Autoencoder）</strong>在原来的损失函数中加入了一个控制稀疏化的正则项。最常见的思路是使用 L1 范数（对所有输出简单求和）来作为度量表征稀疏性的正则项，然而少有稀疏自动编码器的相关论文采用这种方法。</p>
<p>由于神经网络的稀疏性还可以被解释为单个神经元被激活的概率很小，因此我们先指定一个稀疏性参数 $\rho$ 来代表隐藏层神经元的平均激活程度，$\rho$ 是一个很小的值（例如 0.05）。这样，我们就可以引入一个度量来衡量神经元的实际激活度 $\hat \rho$ 与期望激活度 $\rho$ 之间的差异，然后将这个度量作为惩罚项即可。一般我们会选择 KL 散度（Kullback-Liebler Divergence）来作为度量，则有</p>
<p>$$\mathrm{KL}\left(\rho \| \hat{\rho}_{j}\right)=\rho \log \frac{\rho}{\hat{\rho}_{j}}+(1-\rho) \log \frac{1-\rho}{1-\hat{\rho}_{j}}$$</p>
<p>损失函数为</p>
<p>$$\mathcal{J}_{\mathrm{sparse}}(\theta)=\mathcal{J}_{\mathrm{AE}}(\theta)+\beta \sum_{j=1}^{n} \mathrm{KL}\left(\rho \| \hat{\rho}_{j}\right)$$</p>
<p>稀疏自动编码器的优点是有很高的可解释性，同时进行了隐式的特征选择。</p>
<h2 id="LSTM-自动编码器-amp-卷积自动编码器"><a href="#LSTM-自动编码器-amp-卷积自动编码器" class="headerlink" title="LSTM 自动编码器 &amp; 卷积自动编码器"></a>LSTM 自动编码器 &amp; 卷积自动编码器</h2><p>在自动编码器的后续发展中，人们也开始想到，编码器和解码器不一定要表示为多层感知器。因此，自动编码器开始和各具特色的其他常用神经网络结构相结合，从而得到卷积自动编码器（Convolutional Autoencoder）、LSTM 自动编码器（LSTM Autoencoder）等模型。单纯的神经网络和与神经网络相结合的自动编码器的主要区别在于，单纯的神经网络通常用于监督学习的特定任务上，经过端到端的训练来学习内部的权重，提取的特征与任务紧密结合；而与神经网络相结合的自动编码器学习得到能够尽可能重建输入的结构权重，这样提取的特征可以应用于更多的任务。</p>
<p>在计算机视觉的各种任务中，精心设计的卷积自动编码器已经成为各大模型不可或缺的部分。不管结构如何改变，其核心思想还是先通过多个卷积层（以及池化层）将高维图片降维得到向量表示，之后将反卷积网络（Deconvolution Network）组成解码器，来将特征向量重构为输入。想进一步了解反卷积可见 [8]。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/Convolutional-AutoEncoder.png"></p>
<p>本身适用于各类序列建模的 LSTM 在与自动编码器结合后，更是焕发了强大的活力。以学习句子的表征为例，在下图中，作为编码器的 LSTM 的每一步接受一个单词（的 embedding）和上一步的隐藏状态作为输入。当最后一个单词被输入时，对应的神经元的隐藏状态作为表征，输入到作为解码器的 LSTM 中。在解码器中，每一个单元将上一步的隐藏状态和输出（也可以是输出对应的标签）作为输入，通过 softmax 层预测对应的词并输出，从而重构出输入的句子。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/LSTM-AE-Seq2Seq.png"></p>
<p>实际上，对于 NLP 略有所知的同学们应该早已看出，将输出目标从原始输入换成监督学习任务中的有标注数据，LSTM 自动编码器有一个更为响亮的名字：Seq2Seq（Sequence to Sequence）。Seq2Seq 结构存在两个问题，一是将整个句子的信息压缩为一个低维向量，会造成信息损失；二是句子如果过长，长程依赖很难被完全学习，从而使得准确率下降。因此，人们把 Seq2Seq 结构与注意力机制（Attention Mechanism）相结合，由此推动了 NLP 领域的蓬勃发展。当然，这与本篇博客的主要内容已相去甚远，因而不再详述。</p>
<p>可以看出，将常用神经网络结构与自动编码器相结合其实更多是一个大概的思想，在具体实现时，编码器和解码器可以自由变换，例如 LSTM 自动编码器中可以将 LSTM 换成 GRU，或者将单向 LSTM 换为双向。总而言之，两者的结合使得双方都获得了新的可能性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>[1] 邱锡鹏. 神经网络与深度学习. <a href="https://nndl.github.io/">https://nndl.github.io/</a></li>
<li>[2] Yoshua Bengio, Aaron C. Courville, Pascal Vincent. “Representation Learning: A Review and New Perspectives”, IEEE Trans. Pattern Anal. Mach. Intell., 2013</li>
<li>[3] Yoshua Bengio, Pascal Lamblin, Dan Popovici, Hugo Larochelle. “Greedy Layer-Wise Training of Deep Networks”, NIPS 2006</li>
<li>[4] Pascal Vincent, Hugo Larochelle, Yoshua Bengio, Pierre-Antoine Manzagol. “Extracting and composing robust features with denoising autoencoders”, ICML 2008</li>
<li>[5] Denoising Autoencoders (dA) — DeepLearning 0.1 documentation. <a href="http://deeplearning.net/tutorial/dA.html">http://deeplearning.net/tutorial/dA.html</a></li>
<li>[6] Salah Rifai, Pascal Vincent, Xavier Muller, Xavier Glorot, Yoshua Bengio. “<a href="http://www.icml-2011.org/papers/455_icmlpaper.pdf">Contractive Auto-Encoders: Explicit Invariance During Feature Extraction</a>“, ICML 2011</li>
<li>[7] Convolutional Autoencoders – P. Galeone’s blog. <a href="https://pgaleone.eu/neural-networks/2016/11/24/convolutional-autoencoders/">https://pgaleone.eu/neural-networks/2016/11/24/convolutional-autoencoders/</a></li>
<li>[8] 反卷积(Transposed Convolution, Fractionally Strided Convolution or Deconvolution). <a href="https://blog.csdn.net/kekong0713/article/details/68941498">https://blog.csdn.net/kekong0713/article/details/68941498</a></li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/68230198">机器学习中表征问题里的各种 trade-off - 知乎</a></li>
<li>Pascal Vincent, Hugo Larochelle, Isabelle Lajoie, Yoshua Bengio, Pierre-Antoine Manzagol. “Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion”, Journal of Machine Learning Research, 2010</li>
<li>Jiwei Li, Minh-Thang Luong, Dan Jurafsky. “A Hierarchical Neural Autoencoder for Paragraphs and Documents”, ACL 2015</li>
<li><a href="https://blog.csdn.net/luohenyj/article/details/78394060">[深度学习]Contractive Autoencoder - 落痕月极的博客 - CSDN博客</a></li>
</ul>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>深度学习笔记</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>自动编码器</tag>
        <tag>Autoencoder</tag>
        <tag>表征学习</tag>
        <tag>Representation Learning</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title>ANTLR v4 学习笔记（一）－ANTLR 初体验</title>
    <url>/blog/ANTLR-learning-notes-1/</url>
    <content><![CDATA[<p>新学期又迎来新课程《解释器构造实践》，通过综合应用来加深对编译原理技术的理解。该实验课最终要求设计并编制调试一个 CMM（C Minus Minus，C 语言的一个子集）程序结构的解释器，对输入的满足 CMM 语法的源程序文件进行解释执行。</p>
<p>课程推荐使用自动化生成工具 ANTLR，因此在这里持续记录我的解释器构造及 ANTLR 学习过程。当然也不排除之后可能会换用其他工具，或者全部自己实现。</p>
<p>ANTLR 目前更新到 v4.7，有一本详尽的使用说明《The Definitive ANTLR 4 Reference》。可惜到目前为止还没有找到中文译本，只有一些零零碎碎的翻译。所幸读完前两章，感觉我的英文水平还是能支持我不用查太多的词就能理解书中所著内容。因此这篇学习笔记也会整理一些书中重要的内容（当然会加以翻译）。</p>
<p>更新记录：</p>
<ul>
<li>17.09.06 《The Definitive ANTLR 4 Reference》Chapter 1、2 阅读完毕，笔记初版发布</li>
<li>17.09.11 Chapter 3 阅读完毕，增加动手上路章节。</li>
<li>17.09.20 对全文进行一定的润色，并修正了一些不太贴切的翻译</li>
</ul>
<span id="more"></span>

<h2 id="我对编译技术的认识"><a href="#我对编译技术的认识" class="headerlink" title="我对编译技术的认识"></a>我对编译技术的认识</h2><p>在正式进行 ANTLR 的学习前，先让我们聊一聊在经过上学期《编译技术及应用》的学习，以及查阅了有关资料后，我对编译技术和编译工具的一点认识。</p>
<p>说实话，如果单单是谈在《编译技术及应用》这门课上的认识的话，我可能只能像孔乙己一样，接连便是难懂的话，什么“上下文无关文法”，什么“LL(1)”，引得各位都哄笑起来，屏幕内外充满了快活的空气…  </p>
<p>尽管经过了计算器和 JSONCompiler 两次实验，但我们可能对编译技术的应用还没有什么认识，觉得编译器的唯一用处就是写一个能把 xx 语言翻译成 xx 然后再运行成功…</p>
<p>基于写这篇博文的契机，我查了一下编译技术的各种应用，才发现其实“编译”这个概念应用还是很广泛的。</p>
<p>比如我的博客是用 hexo 这个博客框架搭建的，而你现在看到的这篇博文是 hexo 将我写的 markdown 文件解析成 html 生成的，这其中自然有编译模块的功劳。</p>
<p>再比如作为一个前端，有不少我使用过或日常接触的工具、框架其实都是编译相关知识的应用：Babel 作为 ES 6 的所有新特性还没有在主流浏览器全面推广的一个暂时的解决方法，将 ES 6 编译成 ES 5 等浏览器能够运行的 JavaScript 代码；在 Vue 中频繁出现的模版引擎、<code>v-for=&quot;item in list&quot;</code>等也有编译的身影。如果真正对编译原理理解透彻，大概可以去摸摸 v8 ，帮助提高一下 Node.js 的运行效率。</p>
<p>编程，本质上是程序员通过语言来控制计算机按照人的意志去进行各种运算和操作。自 20 世纪 50 年代早期，第一个只能进行单目运算的编译程序诞生起，编译技术一直作为人与计算机之间的传声筒，支撑着计算机语言的发展，使其更加系统化、合理化。</p>
<p>在知乎上“编译原理学了有什么用？”这个提问下，有答主贴了一幅《C 编译器解剖》序的照片，其中有一段话：</p>
<blockquote>
<p>操作系统和编译器就如武侠小说中的“九阴真经”，没看过“九阴真经”的侠客也可以行走江湖，但看过并练成九阴真经的人最终才更有机会登上华山之巅。</p>
</blockquote>
<p>怀着对程序员之巅的心向往之，我也对编译原理更生敬畏。</p>
<p>当然，如何让这门古老的屠龙术落地，而不至于成为学生心中虚无缥缈的空中楼阁。我个人认为可以再开设一些相关的新课题，让学生能够充分了解编译技术的实用性，从而能够自主学习、实践。我也希望《解释器构造实践》能成为一个不错的起点。</p>
<h2 id="初识-ANTLR"><a href="#初识-ANTLR" class="headerlink" title="初识 ANTLR"></a>初识 ANTLR</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 1 Meet ANTLR。书里的这一章主要是介绍 ANTLR 的下载安装方法，并运行了一个简单的 demo。</p>
</blockquote>
<h3 id="安装-ANTLR"><a href="#安装-ANTLR" class="headerlink" title="安装 ANTLR"></a>安装 ANTLR</h3><p>ANTLR 是用 Java 编写的，所以就算你想使用 C# 或者 C++ 来配合 ANTLR 生成解释器，安装 ANTLR 前也需要有 Java 环境。</p>
<p>之后需要下载 antlr-4.x-complete.jar（越新越好，4.x 指最新版本的版本号）并把它放在你记得住的地方。这个 jar 包包含了运行 ANTLR 工具所需要的所有依赖，还包含两个支持库：一个树状排版库，以及 StringTemplate，一个用于生成代码以及其他结构化文本的模版引擎。</p>
<p>安装的具体步骤请直接看<a href="http://www.antlr.org/">官网</a>的 Quick Start，在此不作展示。</p>
<h2 id="ANTLR-全貌"><a href="#ANTLR-全貌" class="headerlink" title="ANTLR 全貌"></a>ANTLR 全貌</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 2 The Big Picture，书中这一章介绍了从字符流到语法分析树的过程、ANTLR 运行流程中的一些重要术语，以及ANTLR 自带的 Listener、Visitor 这两种遍历树的机制。</p>
</blockquote>
<p>想要实现一种语言，我们就需要构建读取句子的应用，并对输入的元素做出正确的反应。</p>
<p>如果一个应用可以计算或执行句子，我们就叫它<strong>解释器（interpreter）</strong>。包括计算器、配置文件读取器、Python 解释器都属于解释器。</p>
<p>而如果一个应用将句子转换成另一种语言，我们就叫它<strong>翻译器（translator）</strong>。例如 Java 到 C# 的翻译器和<strong>编译器</strong>都属于翻译器。</p>
<p>不管是解释器还是翻译器，想要正确运行，应用首先都要识别出所有有效的句子、词组、字词组等，识别语言的程序就叫<strong>解析器（parser）</strong>或<strong>语法分析器（syntax analyzer）</strong>。</p>
<p>完全 DIY 一个解析器非常麻烦，所以我们需要 ANTLR 的帮助。ANTLR 是一种能写出程序的程序，只需编写 ANTLR 的语法（grammars）文件，描述我们要解析的语言的语法，ANTLR 就能够自动生成用来解析这种语言的解析器。而用来声明我们语言的ANTLR语言的语法，就是<strong>元语言（meta-language）</strong>。</p>
<h3 id="最基本的解析过程"><a href="#最基本的解析过程" class="headerlink" title="最基本的解析过程"></a>最基本的解析过程</h3><p>为了简单起见，我们将解析分为两个阶段，第一阶段是<strong>词法分析（lexical analysis）</strong>，对应的分析程序叫做<strong>词法分析器（lexer）</strong>，负责将符号（token）分组成<strong>符号类（token class or token type）</strong>。而第二阶段就是真正的<em>语法分析</em>，默认 ANTLR 会构建出一棵<strong>语法分析树（parse tree / syntax tree）</strong>。下图展示了一个简单的赋值表达式的解析过程：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr1.jpg" />

<p>语法树的叶子是输入的 token，而上级结点是包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是：</p>
<ol>
<li>树形结构易于遍历和处理，并且容易被程序员理解，方便了应用代码做进一步处理。</li>
<li>多种解释或翻译的应用代码都可以重用一个解析器。但 ANTLR 也支持像传统解析器生成器那样，将应用处理代码直接嵌入到语法中。</li>
<li>对于因为计算依赖而需要多趟处理的翻译器来说，比起多次调用解析器去解析，遍历语法树多次更加高效。</li>
</ol>
<h3 id="深入-ANTLR-的解析过程"><a href="#深入-ANTLR-的解析过程" class="headerlink" title="深入 ANTLR 的解析过程"></a>深入 ANTLR 的解析过程</h3><p>ANTLR 生成的解析器叫做<strong>递归下降语法分析器（recursive-descent parser）</strong>，属于自顶向下语法分析器（top-down parser）的一种。</p>
<p>顾名思义，递归下降指的就是解析过程是从语法树的根开始，向叶子（token）递归。还是以前面的赋值表达式解析为例，其递归下降语法分析器的代码大概是下面这个样子：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr2.jpg" />

<p>很酷的一点是<code>stat()</code>、<code>assign()</code>、<code>expr()</code>等方法调用所形成的调用栈能与语法分析树的内部节点一一对应。<code>match()</code>的调用对应树的叶子，而<code>assign()</code>方法直接顺序读取输入字符，而不用做任何选择。相比之下，<code>stat()</code>方法要复杂一些，因为在解析时，它需要<strong>向前看（lookahead）</strong>一些字符才能确认走哪个代码分支，有时甚至要读取完所有输入才能得出预测结果。</p>
<p>虽然 ANTLR 默默地为我们处理了这整个过程，但对这个选择过程有一个基本的了解会使得对生成的解析器进行 debug 变得更加容易。</p>
<h3 id="用语法分析树构建语言应用"><a href="#用语法分析树构建语言应用" class="headerlink" title="用语法分析树构建语言应用"></a>用语法分析树构建语言应用</h3><p>在内部，ANTLR 的数据结构会尽可能地共享数据来节约内存。如下图所示，语法分析树的叶子节点指向 token 流中的 token，而 token 中的起止字符索引指向字符流，并不拷贝子字符串。而像空格这种不与任何 token 相关的字符会直接被 Lexer 丢弃掉。</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr3.jpg" />

<p>ANTLR 为每条规则都会生成一个 RuleNode，叫做<strong>上下文（Context）对象</strong>，它会记录根据规则识别词组时产生的所有上下文信息。每一个上下文对象都知道已经识别的短语的起始 token 和结束 token，并且提供了对这些短语的访问。例如，<code>AssignContext</code>提供<code>ID()</code>和<code>expr()</code>方法来访问标识符节点和表达式子树。</p>
<h3 id="语法分析树的-Listener-和-Visitor-机制"><a href="#语法分析树的-Listener-和-Visitor-机制" class="headerlink" title="语法分析树的 Listener 和 Visitor 机制"></a>语法分析树的 Listener 和 Visitor 机制</h3><p>ANTLR 在其运行库提供了 Listener 和 Visitor 两种语法分析树遍历机制。</p>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>Listener 的特点是全自动化，我们不必写一个语法分析树的遍历器，ANTLR 会生成一个 ParseTreeWalker 的子类来主导深度优先遍历过程，我们只需处理各种事件就可以了。例如当遍历器遍历到<code>assign</code>规则的节点时，会触发<code>enterAssign()</code>并向其传递<code>AssignContext</code>参数；而当遍历器遍历完<code>assign</code>节点的所有子节点时，触发<code>exitAssign()</code>。下图展示了 ParseTreeWalker 如何进行深度优先遍历：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr4.jpg" />

<p>而下图展示了 ParseTreeWalker 的完整监听器方法调用队列：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr5.jpg" />

<h4 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h4><p>而 Visitor 则提供了可控的遍历方式，我们可以自行决定是否将子结点作为参数调用<code>visit()</code>方法。</p>
<p>在使用 ANTLR 生成时加上参数<code>-visitor</code>，会生成带有默认实现的 Visitor 实现类。我们不必实现接口中的每一个方法，只需要覆盖我们感兴趣的方法。</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr6.jpg" />

<h2 id="动手上路"><a href="#动手上路" class="headerlink" title="动手上路"></a>动手上路</h2><blockquote>
<p>对应《The Definitive ANTLR 4 Reference》中 Chapter 3 A Starter ANTLR Project。</p>
</blockquote>
<h3 id="ANTLR-工具，运行时类库和生成代码"><a href="#ANTLR-工具，运行时类库和生成代码" class="headerlink" title="ANTLR 工具，运行时类库和生成代码"></a>ANTLR 工具，运行时类库和生成代码</h3><p>ANTLR 分为两个重要的部分：ANLTR 工具自身和 ANTLR 运行时（runtime） API。运行 ALTLR 工具会生成能够辨认语法所描述语言的句子的代码（词法分析程序和语法分析程序）；而运行时类库提供了生成代码所需的一系列类与方法，例如 Parser, Lexer 和 token。</p>
<p>我们先对一份语法运行 ANTLR，然后借助 jar 包中的运行时类库（runtime classes in the jar）对生成的代码进行编译。最后，编译得到的应用与运行库结合着运行。</p>
<p>《The Definitive ANTLR 4 Reference》（后文可能简写为《Reference》）给出了一份简单的示例，让我们可以快速了解 ANTLR 所需语法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Grammers always start with a grammer header. This grammer */</span></span><br><span class="line"><span class="comment">/** is called ArrayInit and must match the filename: ArrayInit.g4 */</span></span><br><span class="line">grammar ArrayInit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A rule called init that that matches comma-separated values between &#123;...&#125; */</span></span><br><span class="line">init : <span class="string">&#x27;&#123;&#x27;</span> value (<span class="string">&#x27;,&#x27;</span> value)* <span class="string">&#x27;&#125;&#x27;</span> ;  <span class="comment">// must match at least one value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** A value can be either a nested array/struct or a simple integer (INT) */</span></span><br><span class="line">value : init</span><br><span class="line">      | INT</span><br><span class="line">      ;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// parser rules start with lowercase letters, lexer rules with uppercase</span></span><br><span class="line">INT :  [<span class="number">0</span>-<span class="number">9</span>]+ ;              <span class="comment">// Define Token INT as one or more digits</span></span><br><span class="line">WS  :  [ \t\r\n]+ -&gt; skip ;  <span class="comment">// Define whitespace rule, toss it out </span></span><br></pre></td></tr></table></figure>

<p>之后通过命令行运行<code>antlr4 ArrayInit.g4</code>，ANTLR 为我们生成很多一般需要我们自己手写的文件：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/antlr-generation.jpg" />

<p>这些文件的功能如下：</p>
<ul>
<li>ArrayInitParser.java：包含了专用于 ArrayInit 语法的解析器（parser）类的定义。</li>
<li>ArrayInitLexer.java：包含专用的词法分析程序（lexer）类的定义。</li>
<li>ArrayInit.Tokens：对于我们定义的每个 token，ANTLR 分配了一个 token 类型码（token type number）并将这些值保存在 ArrayInit.tokens。因为这个文件的存在，当我们将较大规模的语法分割为各种小型的语法表达时，ANTLR 能够使同种 token 的类型码保持一致。</li>
<li>ArrayInitListener.java, ArrayInitBaseListener.java：ANTLR 生成的解释器会默认根据输入构建一棵树。通过遍历这棵树，一个遍历器可以将事件（回调函数）传递给我们提供的监听者对象（listener object）。ArrayInitListener 是描述我们可以实现的回调函数的接口，而ArrayInitBaseListener 是默认空实现的集合，使我们可以方便的重写（override）那些我们感兴趣的回调函数。通过<code>-visitor</code>命令行参数，ANTLR 也可以为我们生成树的 visitors。</li>
</ul>
<h3 id="测试生成的解析器"><a href="#测试生成的解析器" class="headerlink" title="测试生成的解析器"></a>测试生成的解析器</h3><p>之后，我们通过<code>javac *.java</code>来编译 ANTLR 生成的所有代码。UNIX 系统用户可以将以下代码写入<code>.bash_profile</code>或其他启动脚本，以免每次都要在命令行输入一遍：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="string">&quot;.:/usr/local/lib/antlr-4.7-complete.jar:<span class="variable">$CLASSPATH</span>&quot;</span></span><br><span class="line"><span class="built_in">alias</span> antlr4=<span class="string">&#x27;java -jar /usr/local/lib/antlr-4.7-complete.jar&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grun=<span class="string">&#x27;java org.antlr.v4.gui.TestRig&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之后就可以通过<code>grun</code>命令来测试生成的解析器了。注意输入要以 EOF（Unix 系统 Ctrl + D，Windows 系统 Ctrl + Z）作为结束。加上<code>-tokens</code>命令行参数，输出的每一行会展示一个单独的 token 及其所有信息：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/grun-the-example1.jpg" />

<p><code>-tree</code>会生成一个 Lisp 风格的简单语法分析树：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/grun-the-example2.jpg" />

<p>而<code>-gui</code>会生成一个展示语法分析树的 GUI 界面：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/grun-the-example3.jpg" />

<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/grun-the-example4.jpg" />

<p>根据我们定义的语法规则，ANTLR 自动生成了这棵语法分析树。之后我们会利用 ANTLR 内置的遍历器触发<code>enterInit()</code>和<code>enterValue()</code>等各种回调函数。</p>
<h3 id="将生成的解析器集成进-Java-程序"><a href="#将生成的解析器集成进-Java-程序" class="headerlink" title="将生成的解析器集成进 Java 程序"></a>将生成的解析器集成进 Java 程序</h3><p>我们来写一个简单的 Java <code>main()</code>方法来集成生成的解析器，并打印出和使用<code>-tree</code>参数一样的语法分析树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import ANTLR&#x27;s runtime libraries</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// create a CharStream that reads from standard input</span></span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></span><br><span class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></span><br><span class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</span><br><span class="line">        </span><br><span class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></span><br><span class="line">        System.out.println(tree.toStringTree(parser));  <span class="comment">// print LISP-style tree</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下。语法错误也可以被报告：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/integrating-test.jpg" />

<h3 id="构建语言应用"><a href="#构建语言应用" class="headerlink" title="构建语言应用"></a>构建语言应用</h3><p>我们的目标不仅仅是识别，还想做一些翻译工作。最简单的方法是利用 ANTLR 内置的语法分析树遍历器，这样我们不需要自己去进行树遍历，大大减少了工作量。</p>
<p>我们给 ArrayInit 加一个新需求：将 short 数组<code>&#123;99, 3, 451&#125;</code>翻译为字符串<code>\u0063\u0003\u01c3</code>。实现这个需求，我们只需要继承<code>ArrayInitBaseListener</code>，来实现其中的一些监听器方法。</p>
<p>我们在 ShortToUnicodeString.java 中实现我们的监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Convert short array inits like &#123;1, 2, 3&#125; to &quot;\u0001\u0002\u0003&quot; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToUnicodeString</span> <span class="keyword">extends</span> <span class="title">ArrayInitBaseListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitInit</span><span class="params">(ArrayInitParser.InitContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterValue</span><span class="params">(ArrayInitParser.ValueContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.valueOf(ctx.INT().getText());</span><br><span class="line">        System.out.printf(<span class="string">&quot;\\u%04x&quot;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不需要覆盖每一个<code>enter/exit</code>方法，只需要实现我们需要的那些。代码里<code>ctx.INT()</code>代表上下文对象请求已经匹配的整数 INT 的值。记住我们之前提到的，上下文对象会记录根据规则识别词组时产生的所有信息。</p>
<p>接下来，我们要创建一个主程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import ANTLR&#x27;s runtime libraries</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// create a CharStream that reads from standard input</span></span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a lexer that feeds off of input CharStream</span></span><br><span class="line">        ArrayInitLexer lexer = <span class="keyword">new</span> ArrayInitLexer(input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a buffer of tokens pulled from the lexer</span></span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// create a parser that feeds off the tokens buffer</span></span><br><span class="line">        ArrayInitParser parser = <span class="keyword">new</span> ArrayInitParser(tokens);</span><br><span class="line">        </span><br><span class="line">        ParseTree tree = parser.init();  <span class="comment">// begin parsing at init rule</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Create a generic parse tree walker that can trigger callbacks</span></span><br><span class="line">        ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Walk the tree created during the parse, trigger callbacks</span></span><br><span class="line">        walker.walk(<span class="keyword">new</span> ShortToUnicodeString(), tree);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比起上一节的主程序，我们多创建了一个树遍历器（<code>ParseTreeWalker walker</code>），并用它来遍历语法分析器返回的语法分析树，它会触发<code>ShortToUnicodeString</code>中的回调方法。</p>
<p>javac 进行编译后就可以使用了：</p>
<img src="https://raw.githubusercontent.com/bighuang624/bighuang624.github.io/master/images/antlr/note1/translate-test.jpg" />

<p>我们可以通过传入不同的监听器来产生完全不同的输出。监听器将语法和我们的语言应用很大程度上解耦了，使语法具有了更大的重用性。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第一篇笔记到这里就结束了。我们聊了一下我对编译技术的一点看法，并阅读了《The Definitive ANTLR 4 Reference》的前三章。而书的 Part I: Introducing ANTLR and Computer Languages 还剩第四章 A Quick Tour，根据实验课的要求，这一章我会单独写一篇学习笔记，示例与内容也会和书上有一些区别。在这之后我会继续学习解释器构造，并继续写这本书的阅读笔记，敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/dc_726/article/details/45399371">Antlr v4入门教程和实例 - 西代零零发 - CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>解释器构造</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
        <tag>ANTLR</tag>
        <tag>解释器</tag>
      </tags>
  </entry>
  <entry>
    <title>ANTLR v4 学习笔记（二）－实现变种计算器</title>
    <url>/blog/ANTLR-learning-notes-2/</url>
    <content><![CDATA[<p>继续学习解释器构造和 ANTLR。在系列博文的上一篇 <a href="http://kyonhuang.top/ANTLR-learning-notes-1/">ANTLR v4 学习笔记（一）－ANTLR 初体验</a>，我们已经学习了如何安装、使用 ANTLR，并研究了构建语言应用程序所需的关键过程、术语和构建块。接下来，我们将通过一个不算复杂的例子来描述 ANTLR 的功能，来让我们对 ANTLR 有个大概的感觉。</p>
<p>我将用 ANTLR 来实现一个变种计算器（变种意指它和普遍看到的计算器不太一样），它遵循上学期编译原理课程第一次实践作业要求。稍后我也将给出对这个计算器的要求描述。</p>
<p>这篇博文对应着《The Definitive ANTLR 4 Reference》中的 Chapter 4 A Quick Tour，但示例和内容与书上有些区别，而且没有覆盖整个 Chapter 4 的所有内容。我会更多地介绍实现学习过程中的经历和错误、自己对 ANTLR 的理解，以及一些实践经验和心得等等。</p>
<span id="more"></span>

<h2 id="计算器描述"><a href="#计算器描述" class="headerlink" title="计算器描述"></a>计算器描述</h2><p>计算器接受四则运算表达式为输入（如下所示）。如果表达式语法正确，则输出计算结果，否则报错，指出错误位置及原因。</p>
<p>例子1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input <span class="number">1</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-a/<span class="number">2</span>;    print(b);    print(a);Output <span class="number">1</span>:    <span class="number">5246.04</span>    <span class="number">3497.36</span></span><br></pre></td></tr></table></figure>

<p>例子2:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input <span class="number">2</span>:     a=(<span class="number">10.44</span>*<span class="number">356</span>+<span class="number">1.28</span>)/<span class="number">2</span>+<span class="number">1024</span>*<span class="number">1.6</span>;    b=a*<span class="number">2</span>-c/<span class="number">2</span>;    print(b);Output <span class="number">2</span>:    Error(line <span class="number">2</span>,position <span class="number">6</span>): undefined identifier.</span><br></pre></td></tr></table></figure>

<p>以上两个示例包含了这个计算器的全部特性：</p>
<ol>
<li>   每个语句需要以“<code>;</code>”结束；</li>
<li>   涉及的操作符只要求加减乘除；支持括号；</li>
<li>   操作数为整数或浮点数；</li>
<li>   变量不需要先声明，可直接赋值，它的类型由右边表达式的类型决定；每个变量在使用之前必须要已经有赋值；</li>
<li>   变量名可以是由数字和字母组成，但首字符必须是字母； </li>
<li>   输出语句使用<code>print()</code>函数，输出并换行；</li>
<li>   <code>print()</code>函数不仅可以输出变量，还可以直接输出表达式的值，例如<code>print(1+2)</code>；</li>
<li>   尽量考虑周全，顾及corner cases。例如除零；</li>
<li>程序不需要 GUI，接受一个源文件路径为命令行参数。</li>
</ol>
<h2 id="匹配运算表达式的语法"><a href="#匹配运算表达式的语法" class="headerlink" title="匹配运算表达式的语法"></a>匹配运算表达式的语法</h2><p>在经过之前的学习后，我们可以比较轻松地写出一份匹配运算表达式的 ANTLR 语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a grammar called Calculator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">grammar Calculator;</span><br><span class="line"><span class="comment">// 程序起始规则，语法分析的起点</span></span><br><span class="line">program : stat+;</span><br><span class="line"></span><br><span class="line">stat: define NEWLINE?            # defineStat</span><br><span class="line">    | print NEWLINE?             # printStat</span><br><span class="line">    | NEWLINE                    # blank</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line">define: VAR <span class="string">&#x27;=&#x27;</span> expr <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="comment">// 计算表达式</span></span><br><span class="line">expr: expr op=(<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr     # MulDiv </span><br><span class="line">     | expr op=(<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr    # AddSub</span><br><span class="line">     | <span class="string">&#x27;(&#x27;</span>expr<span class="string">&#x27;)&#x27;</span>                # parens</span><br><span class="line">     | NUMBER                    # number</span><br><span class="line">     | VAR                       # <span class="keyword">var</span></span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">print: <span class="string">&#x27;print&#x27;</span><span class="string">&#x27;(&#x27;</span>VAR<span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span>       # printVAR</span><br><span class="line">      | <span class="string">&#x27;print&#x27;</span><span class="string">&#x27;(&#x27;</span>expr<span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span>     # printExpr </span><br><span class="line">      ;</span><br><span class="line"><span class="comment">// 操作数类别</span></span><br><span class="line">NUMBER: INT|FLOAT;</span><br><span class="line">VAR : [a-zA-Z][a-zA-Z0-<span class="number">9</span>]*;</span><br><span class="line">INT : [<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">FLOAT : [<span class="number">0</span>-<span class="number">9</span>]+<span class="string">&#x27;.&#x27;</span>[<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">NEWLINE: <span class="string">&#x27;\r&#x27;</span>? <span class="string">&#x27;\n&#x27;</span>? ;</span><br><span class="line">WS : [ \t]+ -&gt; skip;</span><br><span class="line">MUL : <span class="string">&#x27;*&#x27;</span> ;  </span><br><span class="line">DIV : <span class="string">&#x27;/&#x27;</span> ;  </span><br><span class="line">ADD : <span class="string">&#x27;+&#x27;</span> ;  </span><br><span class="line">SUB : <span class="string">&#x27;-&#x27;</span> ; </span><br></pre></td></tr></table></figure>

<p>这份语法有一些值得注意的地方：</p>
<ul>
<li>语法分析器的规则以小写字母开头；</li>
<li>词法分析器的规则以大写字母开头；</li>
<li>我们使用<code>|</code>来分隔同一个语言规则的若干备选分支，并使用圆括号把一些符号组合成子规则；</li>
<li>WS 词法规则中，<code>-&gt; skip</code>是一条指令，告诉词法分析器匹配并丢弃空白字符；</li>
<li>你也许会注意到一些<code>#</code>开头的标签。如果备选分支上没有标签，ANTLR 就只为每条规则生成一个方法；</li>
<li>我们为运算符等词法符号定义了一些名字，这样，在之后访问器的编写中，我们可以将这些词法符号的名字当作常量使用，使代码更加清晰。</li>
</ul>
<p>现在我们已经可以通过 ANTLR 内置的测试组件来进行测试。由于 Eclipse 的最新版本 ANTLR 插件里的 ANTLR 版本仍然是 4.4（官网的 ANTLR 包已到 4.7 版本），所以我们还是自己通过命令行生成 java 文件并编译：</p>
<img src="/images/antlr/note2/cal1.jpg" />

<p>添加的<code>-gui</code>参数使我们可以看到关于输入的语法分析树：</p>
<img src="/images/antlr/note2/caltree.jpg" />

<p>ANTLR 语法分析器能够自动报告语法错误并从错误中恢复。例如，我们的输入少一个<code>;</code>，语法分析器会自动输出错误信息：</p>
<img src="/images/antlr/note2/cal1-error.jpg" />

<p>添加<code>-gui</code>参数生成的可视化语法分析树会将错误节点自动标红：</p>
<img src="/images/antlr/note2/caltree-error.jpg" />

<h3 id="语法优化"><a href="#语法优化" class="headerlink" title="语法优化"></a>语法优化</h3><p>这里的“优化”不是指对语法本身，而是对 ANTLR 语法文件，即<code>.g4</code>作为扩展名的文件。ANTLR 允许我们将非常大的语法拆分为多个部分，根据习惯，我们将其分为语法分析器的语法和词法分析器的语法两部分。</p>
<p>这样做的好处是对于两种词法规则或者语法规则相同的语言，我们可以复用这些“模块”来构建语法分析器。</p>
<p>词法规则文件 CalculatorLexerRules.g4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意开头是 &quot;lexer grammer&quot;</span></span><br><span class="line">lexer grammar CalculatorLexerRules;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作数类别</span></span><br><span class="line">NUMBER: INT|FLOAT;</span><br><span class="line">VAR : [a-zA-Z][a-zA-Z0-<span class="number">9</span>]*;</span><br><span class="line">INT : [<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">FLOAT : [<span class="number">0</span>-<span class="number">9</span>]+<span class="string">&#x27;.&#x27;</span>[<span class="number">0</span>-<span class="number">9</span>]+;</span><br><span class="line">NEWLINE: <span class="string">&#x27;\r&#x27;</span>? <span class="string">&#x27;\n&#x27;</span>? ;</span><br><span class="line">WS : [ \t]+ -&gt; skip;</span><br><span class="line">MUL : <span class="string">&#x27;*&#x27;</span> ;  </span><br><span class="line">DIV : <span class="string">&#x27;/&#x27;</span> ;  </span><br><span class="line">ADD : <span class="string">&#x27;+&#x27;</span> ;  </span><br><span class="line">SUB : <span class="string">&#x27;-&#x27;</span> ; </span><br></pre></td></tr></table></figure>

<p>语法规则文件 CalculatorExpr.g4，之前语法中的词法规则全部通过 import 语句导入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a grammar called CalculatorExpr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 注意 grammer 要和文件名相同</span></span><br><span class="line">grammar CalculatorExpr;</span><br><span class="line"><span class="comment">// 引入词法规则</span></span><br><span class="line"><span class="keyword">import</span> CalculatorLexerRules;</span><br><span class="line"><span class="comment">// 程序起始规则，语法分析的起点</span></span><br><span class="line">program : stat+;</span><br><span class="line"></span><br><span class="line">stat: define NEWLINE?            # defineStat</span><br><span class="line">    | print NEWLINE?             # printStat</span><br><span class="line">    | NEWLINE                    # blank</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line">define: VAR <span class="string">&#x27;=&#x27;</span> expr <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="comment">// 计算表达式</span></span><br><span class="line">expr: expr op=(<span class="string">&#x27;*&#x27;</span>|<span class="string">&#x27;/&#x27;</span>) expr     # MulDiv </span><br><span class="line">     | expr op=(<span class="string">&#x27;+&#x27;</span>|<span class="string">&#x27;-&#x27;</span>) expr    # AddSub</span><br><span class="line">     | <span class="string">&#x27;(&#x27;</span>expr<span class="string">&#x27;)&#x27;</span>                # parens</span><br><span class="line">     | NUMBER                    # number</span><br><span class="line">     | VAR                       # <span class="keyword">var</span></span><br><span class="line">     ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">print: <span class="string">&#x27;print&#x27;</span><span class="string">&#x27;(&#x27;</span>VAR<span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span>       # printVAR</span><br><span class="line">      | <span class="string">&#x27;print&#x27;</span><span class="string">&#x27;(&#x27;</span>expr<span class="string">&#x27;)&#x27;</span><span class="string">&#x27;;&#x27;</span>     # printExpr </span><br><span class="line">      ;</span><br></pre></td></tr></table></figure>

<p>要生成 java 文件，我们只需要对语法文件使用<code>antlr4</code>命令即可。这样我们就得到了和之前一样的 java 文件（测试就不贴图了）：</p>
<img src="/images/antlr/note2/import-java.jpg" />

<p>import 语句赋予我们编写模块化语法的能力，这使得 ANTLR 语法文件的耦合度降低，复用性提高。</p>
<h2 id="使用-Visitor-构建计算器"><a href="#使用-Visitor-构建计算器" class="headerlink" title="使用 Visitor 构建计算器"></a>使用 Visitor 构建计算器</h2><p>我们最终的目的是将生成的语法分析器集成到程序中，因此我们需要写一些 Java 代码。我们会用 Visitor（访问者模式）来实现我们的变种计算器。</p>
<p>由于我的实现代码基于 Calculator.g4 生成的 java 文件，而非拆分后的 CalculatorExpr.g4，所以之后的文件名、类名和方法名还是会以 Calculator 开头。当然，所有功能都是相同的，使用哪份语法文件生成的 java 文件都不会有影响。</p>
<p>我们通过以下命令来让 ANTLR 生成 Visitor 而非 Listener：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">antlr4 -no-listener -visitor -encoding UTF-8 Calculator.g4</span><br></pre></td></tr></table></figure>

<p>这样，ANTLR 会自动生成一个访问器接口文件 CalculatorVisitor.java，以及该访问器的一个默认实现类 CalculatorBaseVisitor。实现时，我们需要自己写一个 Visitor 的子类，继承<br>CalculatorBaseVisitor<Float>（这样表达式的计算结果都是浮点数），并重写其中的方法，以实现变量键值对存储、计算、打印等需求。</p>
<p>以下是我们实现的 Visitor 子类 MainVisitor 的完整代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainVisitor</span> <span class="keyword">extends</span> <span class="title">CalculatorBaseVisitor</span>&lt;<span class="title">Float</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个 map，存放变量与值的键值对</span></span><br><span class="line">    Map&lt;String, Float&gt; memory = <span class="keyword">new</span> HashMap&lt;String, Float&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * define: VAR &#x27;=&#x27; expr &#x27;;&#x27;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitDefine</span><span class="params">(CalculatorParser.DefineContext ctx)</span> </span>&#123;</span><br><span class="line">        String <span class="keyword">var</span> = ctx.VAR().getText();</span><br><span class="line">        <span class="keyword">float</span> value = visit(ctx.expr());</span><br><span class="line">        memory.put(<span class="keyword">var</span>, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * expr op=(&#x27;*&#x27;|&#x27;/&#x27;) expr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitMulDiv</span><span class="params">(CalculatorParser.MulDivContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.MUL)</span><br><span class="line">            <span class="keyword">return</span> left * right;</span><br><span class="line">        <span class="keyword">return</span> left / right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * expr op=(&#x27;+&#x27;|&#x27;-&#x27;) expr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitAddSub</span><span class="params">(CalculatorParser.AddSubContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> left = visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">float</span> right = visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (ctx.op.getType() == CalculatorParser.ADD)</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        <span class="keyword">return</span> left - right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NUMBER</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitNumber</span><span class="params">(CalculatorParser.NumberContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Float.valueOf(ctx.NUMBER().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VAR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitVar</span><span class="params">(CalculatorParser.VarContext ctx)</span> </span>&#123;</span><br><span class="line">        String <span class="keyword">var</span> = ctx.VAR().getText();</span><br><span class="line">        <span class="keyword">if</span> (memory.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            <span class="keyword">return</span> memory.get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>) <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#x27;(&#x27;expr&#x27;)&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitParens</span><span class="params">(CalculatorParser.ParensContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.expr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print: (&#x27;print&#x27;&#x27;(&#x27;VAR&#x27;)&#x27;&#x27;;&#x27;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintVAR</span><span class="params">(CalculatorParser.PrintVARContext ctx)</span> </span>&#123;</span><br><span class="line">        String <span class="keyword">var</span> = ctx.VAR().getText();</span><br><span class="line">        <span class="keyword">if</span> (memory.containsKey(<span class="keyword">var</span>))</span><br><span class="line">            System.out.println(memory.get(<span class="keyword">var</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.err.println(<span class="string">&quot;undefined identifier&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> visitChildren(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * print: (&#x27;print&#x27;&#x27;(&#x27;expr&#x27;)&#x27;&#x27;;&#x27;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">visitPrintExpr</span><span class="params">(CalculatorParser.PrintExprContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(visit(ctx.expr()));</span><br><span class="line">        <span class="keyword">return</span> visitChildren(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们需要写一个 Calculator.java 来新建所需要的所有对象，并针对 program 规则启动语法分析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.*;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String inputFile = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Usage:\n\tjava -jar Calculator.jar [sourceFile]&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            inputFile = args[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;The file path cannot be recognized&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InputStream instream = System.in;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(inputFile != <span class="keyword">null</span>)</span><br><span class="line">            instream = <span class="keyword">new</span> FileInputStream(inputFile);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">        ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(instream);</span><br><span class="line">        <span class="comment">// 新建词法分析器对象</span></span><br><span class="line">        CalculatorLexer lexer = <span class="keyword">new</span> CalculatorLexer(input);</span><br><span class="line">        <span class="comment">// 新建词法符号流管道</span></span><br><span class="line">        CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lexer);</span><br><span class="line">        <span class="comment">// 新建语法分析器对象</span></span><br><span class="line">        CalculatorParser parser = <span class="keyword">new</span> CalculatorParser(tokens);</span><br><span class="line">        <span class="comment">// 启动语法分析器，从 program 规则开始进行语法分析</span></span><br><span class="line">        ParseTree tree = parser.program();</span><br><span class="line">        </span><br><span class="line">        MainVisitor cal = <span class="keyword">new</span> MainVisitor();</span><br><span class="line">        </span><br><span class="line">        cal.visit(tree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，现在我们的变种计算器就有了一个初步版本。打包成 jar 包后，我们可以看一下效果：</p>
<img src="/images/antlr/note2/Calculator-effect.jpg" />

<p>我觉得可以。</p>
<h2 id="继续完善"><a href="#继续完善" class="headerlink" title="继续完善"></a>继续完善</h2><p>那么这时候，一般就会有人跳出来说：“我觉得不行。我觉得很普通。”</p>
<p>其实我也是这么认为的（阿黄真的很严格！）。</p>
<p>实际上，我们这个计算器还有一些需要继续完善的地方。比如下面这种情况：</p>
<img src="/images/antlr/note2/exception.jpg" />

<p>可以看到并未赋值的变量 c 被当作 0。然而在我们的要求中，这样的变量应该当作未初始化，使用时要报错。另外，当被除数为 0 时，输出的结果会是 “Infinity”，而我们还是希望这种情况发生时会报错。以上情况说明<strong>我们定义的语法没有覆盖到所有设想中的错误</strong>。</p>
<p>另外，ANTLR 自带的错误报告采用以下的语句，基本算是直接输出了行号、错误信息等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.err.println(<span class="string">&quot;line &quot;</span> + line + <span class="string">&quot;:&quot;</span> + charPositionInLine + <span class="string">&quot; &quot;</span> + msg);</span><br></pre></td></tr></table></figure>

<p>说实话，不是很显眼。我还是喜欢错误报告开头有一些比较明显的标示，比如<code>Error(line 2,position 6): undefined identifier</code>感觉就要好一些。</p>
<p>不幸的是，Chapter 4 尚未涉及到 ANTLR 的错误处理机制。这部分内容在 Chapter 9 Error Reporting and Recovery 中。为了不用麻烦糖糖先记着，我们不妨先对这部分内容进行一些学习。</p>
<h3 id="错误报告格式优化"><a href="#错误报告格式优化" class="headerlink" title="错误报告格式优化"></a>错误报告格式优化</h3><p>先从错误报告格式优化开始。ANTLR 的错误报告通过 ANTLRErrorListener 接口，由 ConsoleErrorListener 实现，输出信息比较简单。</p>
<p>ANTLRErrorListener 包含四个方法：<strong>syntaxError</strong>、reportAmbiguity、reportAttemptingFullContext、reportContextSensitivity。其中 syntaxError 顾名思义用于处理语法错误，而后三个用于二义性处理。</p>
<p>ANTLR 也内置了一些 ANTLRErrorListener 的实现。除开默认采用的 ConsoleErrorListener，还有一个空实现 <strong>BaseErrorListener</strong>。我们可以 new 一个 BaseErrorListener 来自定义一些错误的处理方法，然后通过 addErrorListener 把它添加到语法分析器上。</p>
<p>根据以上思路，我们可以在 Calculator.java 中新建语法分析器对象的语句后加上几行代码，用于移除 ANTLR 默认的错误处理，以及添加一个我们自定义的错误监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除默认的错误处理</span></span><br><span class="line">parser.removeErrorListeners();</span><br><span class="line"><span class="comment">// 添加自定义错误监听器</span></span><br><span class="line">parser.addErrorListener(<span class="keyword">new</span> BaseErrorListener() &#123;</span><br><span class="line">    <span class="comment">//出现语法错误</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, <span class="keyword">int</span> line, <span class="keyword">int</span> charPositionInLine, String msg, RecognitionException e)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error(line &quot;</span> + line + <span class="string">&quot;, position &quot;</span> + charPositionInLine + <span class="string">&quot;): &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在的错误报告看起来就更加有条理了：</p>
<img src="/images/antlr/note2/newErrorReport.jpg" />

<h3 id="部分错误特例的处理方式"><a href="#部分错误特例的处理方式" class="headerlink" title="部分错误特例的处理方式"></a>部分错误特例的处理方式</h3><p>不幸的是，读完了 Chapter 9，我仍然没有找到关于调用未初始化变量、被除数为 0 时报错应该怎么写。<br>现在我的权宜之计是直接<code>System.err.println</code>，也就是跳过错误机制。由于上下文对象会记录根据规则识别词组时产生的所有信息，可以通过<code>ctx.start.getLine()</code>获得<code>ctx.start.getCharPositionInLine()</code>错误出现的行数和行内具体位置。</p>
<img src="/images/antlr/note2/undefined-error.jpg" />

<p>可以看到所显示的位置好像并不是特别准确，个人认为是 ctx 给出的位置会追溯到所在规则开始的地方。也许随着学习更加深入，我会找到比较优雅的实现方法。</p>
<h2 id="计算器运行截图"><a href="#计算器运行截图" class="headerlink" title="计算器运行截图"></a>计算器运行截图</h2><p><img src="http://upload-images.jianshu.io/upload_images/2702529-952930bcab492aee.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result1.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2702529-891de540a356c539.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="result2.jpg"></p>
<h2 id="计算器实现中遇到的问题"><a href="#计算器实现中遇到的问题" class="headerlink" title="计算器实现中遇到的问题"></a>计算器实现中遇到的问题</h2><p>实现这个变种计算器的过程当然也不是一帆风顺的，尤其我是先动手摸索再看的 Chapter 4。以下几个小坑可能还会有新司机踩上，特此写明：</p>
<ul>
<li>开始的语法写输出语句为<code>print: (&#39;print&#39;&#39;(&#39;VAR|expr&#39;)&#39;&#39;;&#39;);</code>没有在<code>VAR|expr</code>外加一层括号，导致后续开发匹配错误。当然，我认为现在开两个备选分支的写法应该更好。</li>
<li>第一次实现时，没有给备选分支加上标签，之后实现 Visitor 时很多方法就需要自己写 if 判断，十分麻烦。通过标签来对每种输入都获得一个不同的事件是坠吼的。</li>
<li>开始的语法写的是<code>WS : [ \t\r\n]+ -&gt; skip;</code>。后来测试时感觉直接跳过换行符好像有时对错误定位会有影响，于是改成现在的样子。</li>
</ul>
<h2 id="我对-ANTLR-的理解"><a href="#我对-ANTLR-的理解" class="headerlink" title="我对 ANTLR 的理解"></a>我对 ANTLR 的理解</h2><p>那么到现在为止，我已经使用 ANTLR 写了几个示例，并完成了一个小项目。经过实际体验，ANTLR 真的可以使我们开发语言类应用程序时，少做很多繁琐的工作。</p>
<p>只要输入一份合法的语法（当然用户需要自行保证语法的准确性），无论多复杂，ANTLR 的语法分析器都能够自动识别，并在运行时以<strong>动态方式</strong>对语法执行分析。相比静态分析必须考虑所有可行的输入序列，动态分析使得我们不必为了适应底层的语法分析策略而扭曲我们语法，从而省略了很多不必要的工作。这是 ANTLR 4 相比其他语法分析器的一个很大的优势。</p>
<p>举个例子，选择使用 ANTLR 进行编译相关的开发工作有一个重要的原因，是它能够自动处理直接左递归（间接左递归暂时不能够）。</p>
<p>我们知道，左递归指某个语言规则在某个备选分支的起始位置调用了自身。由于含有左递归的文法必然不是 LL(1) 文法，也就不可能使用确定的自顶向下分析法。然而，允许使用左递归的文法来表示语言规则又要简洁的多。ANTLR 可以将直接左递归规则自动重写为等价的非左递归形式，省却了不少麻烦。</p>
<p>此外，ANLTR 语法文件独立于程序。在生成的所需的语法分析器之后，我们只需要用熟悉的 Java 来实现我们所需要的语法分析树遍历器（重写部分方法），以符合我们的要求即可。不需要自己去写词法分析器、语法分析器，ANLTR 大大降低了语言类应用程序开发的门槛。</p>
<p>当然，无论工具有多方便，终究只能帮助人完成事务、减少工作量，而非完全替代。想要使用好 ANTLR，还是得对编译原理有透彻的理解。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ANTLR 学习的第二篇笔记到这里就结束了。在这之后我会继续学习解释器构造，阅读《The Definitive ANTLR 4 Reference》，并博客上持续记录学习过程中的一点心得。敬请期待。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《The Definitive ANTLR 4 Reference》</li>
<li><a href="http://blog.csdn.net/yuexiang321/article/details/52770283">antlr入门实例——计算器 - Yue Xiang - CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>解释器构造</category>
      </categories>
      <tags>
        <tag>编译技术</tag>
        <tag>ANTLR</tag>
        <tag>解释器</tag>
      </tags>
  </entry>
  <entry>
    <title>《C 程序设计语言》读书笔记</title>
    <url>/blog/C-programming-language-notes/</url>
    <content><![CDATA[<p>我所在的专业没有开设 C 语言的课程，而大一虽然有开设 C++，但一是两门语言还是有一些区别，二是也过去了一年，很多东西都差不多忘干净了。这学期的系统级程序设计课程（即著名的“csapp”）和 C 语言密不可分，因此我借来了《C 程序设计语言》来补一补相关知识，并记了一些笔记。最终这门课拿了满绩，还是对得起自己的付出。</p>
<p>我认为《C 程序设计语言》是一本很好的 C 语言入门书籍，简洁清晰。这里的笔记也都是 C 语言最基础的语法。越往深里学，越会感觉 C 语言和计算机系统的相辅相成，博大精深，也越烧脑。但是现在都必须要按需所学了，还是希望有机会能够继续深入挖掘 C 语言的精粹。</p>
<span id="more"></span>

<h2 id="序与引言"><a href="#序与引言" class="headerlink" title="序与引言"></a>序与引言</h2><p>C 语言的 ANSI 标准的目的是制定“一个无歧义性的且<strong>与具体机器无关</strong>的 C 语言定义”。比起之前的标准，ANSI 标准要求对变量进行正确的声明和显式的强制类型转换，并为 C 语言定义了一个函数库。</p>
<p>指针提供了与具体机器无关的地址算术运算。</p>
<p>编译的<strong>预处理阶段</strong>将对程序文本进行<strong>宏替换</strong>、<strong>包含其他源文件</strong>以及进行<strong>条件编译</strong>。</p>
<p>C 语言不提供直接处理诸如字符串、集合、列表或数组等符合对象的操作。所有高层的机制必须由显式调用的函数提供。</p>
<h2 id="第-1-章-导言"><a href="#第-1-章-导言" class="headerlink" title="第 1 章  导言"></a>第 1 章  导言</h2><h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 名字 替换文本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOWER  0</span></span><br></pre></td></tr></table></figure>

<p><code>#define</code>指令行的末尾没有分号。</p>
<h3 id="参数－传值调用"><a href="#参数－传值调用" class="headerlink" title="参数－传值调用"></a>参数－传值调用</h3><p>在 C 语言中，所有函数参数都是“<strong>通过值</strong>”传递的。也就是说，传递给被调用函数的参数值存放在临时变量中。被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值。</p>
<p>必要时，也可以让函数能够修改主调函数中的变量。这种情况下，调用者需要向被调用函数提供设置值的变量的<strong>地址</strong>（从技术角度看，地址就是指向变量的<strong>指针</strong>），而被调用函数则需要将对应的参数声明为指针类型，并通过它间接访问变量。</p>
<p>当<strong>把数组名作为参数时</strong>，传递给函数的值是<strong>数组起始元素的位置或地址</strong>——它并不复制数组元素本身。在被调用函数中，可以通过数组下标访问或<em>修改</em>数组元素的值。</p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>当在 C 语言程序中出现类似<code>&quot;hello\n&quot;</code>的字符串常量时，它将以字符数组的形式存储，数组的各元素分别存储字符串的各个字符，并<strong>以<code>\0</code>标志字符串的结束</strong>。因此，存储字符串的物理存储单元数比括在双引号中的字符数多一个。</p>
<h3 id="外部变量与作用域"><a href="#外部变量与作用域" class="headerlink" title="外部变量与作用域"></a>外部变量与作用域</h3><p>函数在使用外部变量之前，必须要知道外部变量的名字。如果在外部变量的作用范围内就无所谓，<strong>而如果在另外一个文件中使用，则需要在函数中使用 extern 类型的声明</strong>。</p>
<p>人们通常把变量和函数的 extern 声明放在一个单独的文件中（习惯上称之为头文件），并在每个源文件的开头使用<code>#include</code>语句将所要用的头文件包含进来。</p>
<p>为了与老版本的 C 语言程序兼容，ANSI C 语言把空参数表看成老版本 C 语言的声明方式，并且对参数表不再进行任何检查。<strong>在 ANSI C 中，如果要声明空参数表，则必须使用关键字 void 进行显式声明</strong>。</p>
<p>请注意分以下两个概念：</p>
<ul>
<li>定义（define）：创建变量或分配存储单元；</li>
<li>声明（declaration）：说明变量的性质，但并不分配存储单元。</li>
</ul>
<h2 id="第-2-章-类型、运算符和表达式"><a href="#第-2-章-类型、运算符和表达式" class="headerlink" title="第 2 章  类型、运算符和表达式"></a>第 2 章  类型、运算符和表达式</h2><h3 id="数据类型及长度"><a href="#数据类型及长度" class="headerlink" title="数据类型及长度"></a>数据类型及长度</h3><p>short 类型通常为 16 位，long 类型通常为 32 位，int 类型可以为 16 位或 32 位。各编译器可以根据硬件特性自主选择合适的类型长度。</p>
<p>类型限定符 signed 与 unsigned 可用于限定 char 类型或任何整型。unsigned 类型的数总是正值或 0，而 signed 类型的数可为负值。例如对于 8 位的 char 对象，则 unsigned char 类型变量的取值范围为 0 ~ 255，而 signed char 类型变量的取值范围 -128 ~ 127（在采用对二的补码的机器上）。不带限定符的 char 类型对象是否带符号取决于具体机器，但可打印字符总是正值。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>无符号整数常量以字母 u 或 U 结尾。后缀 ul 或 UL 表明是 unsigned long 类型。</p>
<p>没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型，而后缀 l 或 L 则表示 long double 类型。</p>
<p>字符常量<code>\0</code>表示值为 0 的字符，也就是空字符（null）。</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>对数组而言，const 限定符指定数组所有元素的值都不能被修改。const 限定符也可配合数组参数使用，以表明函数不能修改数组元素的值。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>取模运算符 % 不能应用于 float 或 double 类型。</p>
<h3 id="关系运算符与逻辑运算符"><a href="#关系运算符与逻辑运算符" class="headerlink" title="关系运算符与逻辑运算符"></a>关系运算符与逻辑运算符</h3><p>关系运算符<code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code>的优先级比算术运算符低。</p>
<p>不等于运算符<code>!=</code>的优先级比赋值运算符<code>=</code>的优先级要高。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="字符型转换为整型"><a href="#字符型转换为整型" class="headerlink" title="字符型转换为整型"></a>字符型转换为整型</h4><p>C 语言没有指定 char 类型的变量是无符号变量（unsigned）还是带符号变量（signed）。当把一个 char 类型的值转换为 int 类型的值时，对于不同的机器，其结果有可能为负整数，这反映了不同机器结构之间的区别。</p>
<p>在某些机器中，如果 char 类型值的最左一位为 1，则转换为负整数（进行“符号扩展”）。而在另一些机器中，会在 char 类型值的左边添加 0，这样导致的转换结果值总是正值。</p>
<p>为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据，最好指定 signed 或 unsigned 限定符。</p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>详见附录 A.6</p>
<p>表达式中 float 类型的操作数不会自动转换为 double 类型，这种设计考虑到节省空间和机器执行时间的需要。</p>
<p>在把参数传递给函数时也可能进行类型转换。在没有函数原型的情况下，char 与 short 类型都将被转换为 int 类型，float 类型也将被转换为 double 类型。因此，即使调用函数的参数为 char 或 float 类型，我们也把函数参数声明为 int 或 double 类型。</p>
<h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><p>C 语言提供了 6 个只能作用于整型操作数（带符号或无符号的 char、short、int 与 long 类型）的操作运算符。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&amp;</code></td>
<td align="center">按位与（AND）</td>
</tr>
<tr>
<td align="center"><code>｜</code></td>
<td align="center">按位或（OR）</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">按位异或（XOR）</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移</td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移</td>
</tr>
<tr>
<td align="center"><code>~</code></td>
<td align="center">按位求反（一元运算符）</td>
</tr>
</tbody></table>
<p>按位与运算符<code>&amp;</code>常用于屏蔽某些二进制位，例如<code>n = n &amp; 0177</code>将 n 中除 7 个低二进制位外的其他各位均置为 0（注意 0177 是八进制，转换为二进制位 1111111）。</p>
<p>按位或运算符<code>|</code>常用于将某些二进制位置为 1，例如<code>x = x | SET_ON;</code>将 x 中对应于 SET_ON 中为 1 的那些二进制位置为 1。 </p>
<p>在对 unsigned 类型的无符号值进行右移位时，左边空出的部分用 0 填补；当对 signed 类型的带符号值进行右移时，某些机器将对左边空出的部分用符号位填补（即“算术移位”，正负不变），而另一些机器则对左边空出的部分用 0 填补（即“逻辑移位”，取绝对值）。</p>
<p>一元运算符<code>~</code>用于求整数的二进制反码，例如<code>x = x &amp; ~077</code>将把 x 的最后六位设置为 0（注意 077 是八进制，转换为二进制位 111111）。</p>
<h2 id="第-4-章-函数与程序结构"><a href="#第-4-章-函数与程序结构" class="headerlink" title="第 4 章  函数与程序结构"></a>第 4 章  函数与程序结构</h2><h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>由于 C 语言不允许在一个函数中定义其他函数，因此函数本身是“外部的”。外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。</p>
<p>如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性使用关键字 extern。</p>
<p>外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数组的长度。</p>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>用 static 声明限定外部变量与函数，可以<strong>将其后声明的对象的作用域限定为被编译源文件的剩余部分</strong>。</p>
<p>static 也可用于声明内部变量。static 类型的内部变量与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，<strong>static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量</strong>。</p>
<h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>register 声明只适用于自动变量以及函数的形式参数，它告诉编译器，它所声明的变量在程序中使用频率较高，可以放在寄存器中。然而，编译器可以忽略过量的或不支持的寄存器变量声明，所以每个函数中实际只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。无论寄存器变量实际是不是存放在寄存器中，它的地址都不能访问。</p>
<h3 id="程序块结构"><a href="#程序块结构" class="headerlink" title="程序块结构"></a>程序块结构</h3><p><strong>C 语言有块作用域</strong>。在<code>&#123;</code>和<code>&#125;</code>构成的程序块中，局部变量（块开头声明的变量）可以隐藏程序块外同名的变量。自动变量（包括形式参数）也可以隐藏同名的外部变量与函数。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在不进行显式初始化的情况下，<strong>外部变量和静态变量</strong>都将被初始化为 0，而<strong>自动变量和寄存器变量</strong>的初值则没有定义（即初值为无用的信息）。</p>
<p>对于<strong>外部变量与静态变量</strong>来说，初始化表达式必须是<strong>常量表达式</strong>，且只初始化一次。</p>
<p>对于<strong>自动变量和寄存器变量</strong>来说，初始化表达式可以不是<strong>常量表达式</strong>；表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用。</p>
<h3 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h3><p>从概念上讲，预处理器是编译过程中单独执行的第一个步骤。</p>
<h4 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h4><p><code>#include &quot;文件名&quot;</code>或<code>#include &lt;文件名&gt;</code>的行都被替换为由<em>文件名</em>指定的文件的内容。<code>#include &quot;文件名&quot;</code>在源文件所在位置查找该文件；没有找到或<code>#include &lt;文件名&gt;</code>则根据相应规则查找该文件。</p>
<h4 id="宏替换"><a href="#宏替换" class="headerlink" title="宏替换"></a>宏替换</h4><p>想将一个较长的宏定义分成若干行，需要在持续的行末尾加上一个反斜杠符<code>\</code>。</p>
<p>宏定义也可以带参数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(A, B)  ((A) &gt; (B) ? (A) : (B))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用语句</span></span><br><span class="line">x = max(p+q, r+s);</span><br><span class="line"><span class="comment">// 将被替换为</span></span><br><span class="line"><span class="comment">// x = ((p+q) &gt; (r+s) ? (p+q) : (r+s));</span></span><br></pre></td></tr></table></figure>

<p>可以看到，要适当使用圆括号以保证计算次序的正确性。</p>
<p>可以通过<code>#undef</code>指令取消名字的宏定义。</p>
<p>如果在替换文本中，参数名以<code>#</code>作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dprint(expr) printf(#expr <span class="meta-string">&quot; = %g\n&quot;</span>, expr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用语句</span></span><br><span class="line">dprint(x/y);</span><br><span class="line"><span class="comment">// 该宏将被扩展为</span></span><br><span class="line"><span class="comment">// dprint(&quot;x/y&quot; &quot; = %g\n&quot;, x/y)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>预处理器运算符<code>##</code>为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与<code>##</code>相邻，则该参数将被实际参数替换，<code>##</code>与前后的空白符将被删除，并对替换后的结果重新扫描。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> paste(front, back) front ## back</span></span><br></pre></td></tr></table></figure>

<p>因此，宏调用<code>paste(name, 1)</code>的结果将建立记号<code>name1</code>。</p>
<h4 id="条件包含"><a href="#条件包含" class="headerlink" title="条件包含"></a>条件包含</h4><p><code>#if</code>语句对其中的常量整型表达式（其中不能包含<code>sizeof</code>、类型转换运算符或<code>enum</code>常量）进行求值，若该表达式的值不等于 0，则包含其后的各行，直到遇到<code>#endif</code>、<code>#elif</code>或<code>#else</code>语句为止。</p>
<p>在<code>#if</code>语句中可以使用表达式<code>defined(名字)</code>，当名字已经定义时其值为 1，否则为 0。</p>
<p>C 语言专门定义了两个预处理语句<code>#ifdef</code>与<code>#ifndef</code>，它们用来测试某个名字是否已经定义。</p>
<h2 id="第-5-章-函数与程序结构"><a href="#第-5-章-函数与程序结构" class="headerlink" title="第 5 章  函数与程序结构*"></a>第 5 章  函数与程序结构*</h2><p><strong>指针</strong>是一种<strong>保存变量地址</strong>的变量。</p>
<p>ANSI C 使用类型<code>void*</code>（指向<code>void</code>的指针）代替<code>char*</code>作为通用指针的类型。</p>
<h3 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h3><p>指针是能够存放一个地址的一组存储单元（通常是两个或四个字节）。</p>
<p>一元运算符<code>&amp;</code>可用于<strong>取一个对象的地址</strong>。因此，下列语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = &amp;c;</span><br></pre></td></tr></table></figure>

<p>将把 c 的地址赋值给变量 p，我们称 p 为“指向” c 的指针。地址运算符<code>&amp;</code>只能应用于<strong>内存</strong>中的对象，即变量和数组元素。它不能作用于表达式、常量或 register 类型的变量。</p>
<p>一元运算符<code>*</code>是<strong>间接寻址</strong>或<strong>间接引用</strong>运算符。<strong>当它作用于指针时，将访问指针所指向的对象</strong>。如果指针 ip 指向整型变量 x，那么在 x 可以出现的任何上下文中都可以使用<code>*ip</code>代替：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *ip;    <span class="comment">/* ip 是指向 int 类型的指针 */</span></span><br><span class="line"></span><br><span class="line">ip = &amp;x;    <span class="comment">/* ip 现在指向 x */</span></span><br><span class="line">y = *ip;    <span class="comment">/* y 的值现在为 1 */</span></span><br><span class="line">*ip = <span class="number">0</span>;    <span class="comment">/* x 的值现在为 0 */</span></span><br><span class="line">ip = &amp;z[<span class="number">0</span>];    <span class="comment">/* ip 现在指向 z[0] */</span></span><br></pre></td></tr></table></figure>

<p>注意：类似<code>*</code>和<code>++</code>这样的一元运算符遵循<strong>从右至左</strong>的结合顺序。例如，语句<code>(*ip)++</code>中的圆括号是必需的，否则该表达式将对 ip 进行加一运算，而不是对 ip 指向的对象进行加一运算。</p>
<h3 id="指针和函数参数"><a href="#指针和函数参数" class="headerlink" title="指针和函数参数"></a>指针和函数参数</h3><p>C 语言是以<strong>传值</strong>的方式将参数值传递给被调用函数，因此被调用函数不能直接修改主调函数中变量的值。但指针参数使得被调用函数能够访问和修改主调函数中对象的值。</p>
<p>由于一元运算符<code>&amp;</code>用来取变量的地址，这样<code>&amp;a</code>就是一个指向变量 a 的指针。</p>
<h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p><strong>数组名所代表的就是该数组最开始的一个元素的地址</strong>，所以，赋值语句<code>pa = &amp;a[0]</code>也可以写成<code>pa = a</code>。<code>*(pa+1)</code>引用的是数组元素<code>a[1]</code>的内容。<code>&amp;a[i]</code>和<code>a+i</code>的含义也是相同的。</p>
<p>但是，数组名和指针之间有一个不同之处。<strong>指针是一个变量，而数组名不是</strong>。因此，类似于<code>a = pa</code>和<code>a++</code>形式的语句是非法的。</p>
<p>如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理。</p>
<h3 id="地址算术运算"><a href="#地址算术运算" class="headerlink" title="地址算术运算"></a>地址算术运算</h3><p>C 语言保证，0 永远不是有效的数据地址。因此，若需要返回指针的函数返回 0，则表示发生了异常事件。</p>
<p>指针与整数之间不能相互转换，但 0 是唯一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。程序中经常用符号 NULL 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。</p>
<p>如果指针 p 和 q 指向同一个数组的成员，那么它们之间就可以进行关系比较运算。同时，这两个指针的减法运算也有意义：若 p &lt; q，那么 q-p+1 就是位于 p 和 q 指向的元素之间的元素的数目。 </p>
<p><strong>有效的指针运算</strong>包括：</p>
<ul>
<li><strong>相同类型</strong>指针之间的赋值运算（两个指针之一是<code>void*</code>类型的情况除外）；</li>
<li>指针同整数之间的加法或减法运算；</li>
<li>指向<strong>相同数组</strong>中元素的两个指针间的减法或比较运算；</li>
<li>将指针赋值为 0 或指针与 0 之间的比较运算。</li>
</ul>
<h3 id="字符指针与函数"><a href="#字符指针与函数" class="headerlink" title="字符指针与函数"></a>字符指针与函数</h3><p>字符串常量是一个字符数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当类似于这样的一个字符串出现在程序中时，实际上是通过<strong>字符指针</strong>访问该字符串的。在上述语句中，<code>printf</code>接受的是<strong>一个指向字符数组第一个字符的指针</strong>。也就是说，字符串常量可通过一个指向其第一个元素的指针访问。</p>
<p>语句<code>pmessage = &quot;now is the time&quot;;</code>将把一个指向该字符数组的指针赋值给<code>pmessage</code>。<strong>该过程并没有进行字符串的复制，而只是涉及到指针的操作。</strong>C 语言没有提供将整个字符串作为一个整体进行处理的运算符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> amessage[] = <span class="string">&quot;now is the time&quot;</span>;    <span class="comment">/* 定义一个数组 */</span></span><br><span class="line"><span class="keyword">char</span> *pmessage = <span class="string">&quot;now is the time&quot;</span>;     <span class="comment">/* 定义一个指针 */</span></span><br></pre></td></tr></table></figure>
<p>上述声明中，数组中单个字符可以进行修改，但<code>amessage</code>始终指向同一个存储位置；另一方面，<code>pmessage</code>是一个指针，之后可以被修改以指向其他地址，但如果试图修改字符串的内容，结果是没有定义的。</p>
<h3 id="指针数组以及指向指针的指针"><a href="#指针数组以及指向指针的指针" class="headerlink" title="指针数组以及指向指针的指针"></a>指针数组以及指向指针的指针</h3><p>由于<strong>指针本身也是变量</strong>，所以它们也可以像其他变量一样存储在数组中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *lineptr[MAXLINES]</span><br></pre></td></tr></table></figure>

<p>表示<code>lineptr</code>是一个<strong>指针数组</strong>。详细地说，它是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，<code>lineptr[i]</code>是一个字符指针，而<code>*lineptr[i]</code>是该指针指向的第 i 个文本行的首字母。</p>
<p>每执行一次自增运算，都使得<code>*lineptr</code>指向下一行。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组*"></a>多维数组*</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">daytab[i][j]    <span class="comment">/* [行][列] */</span></span><br></pre></td></tr></table></figure>

<p>如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须<strong>指明数组的列数</strong>。数组的行数没有太大关系，因为函数调用时传递的是一个指针，它指向由行向量构成的一维数组。因此：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span> daytab[<span class="number">2</span>][<span class="number">13</span>]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>也可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span> daytab[][<span class="number">13</span>]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>还可以写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span> (*daytab)[<span class="number">13</span>]) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组（包裹在外的第二维数组的首地址）。因为<strong>方括号<code>[]</code>的优先级高于<code>*</code>的优先级</strong>，所以上述声明中必须使用圆括号。如果去掉括号，则声明变为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *daytab[<span class="number">13</span>]</span><br></pre></td></tr></table></figure>

<p>相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。</p>
<p>一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。</p>
<h3 id="指针与多维数组"><a href="#指针与多维数组" class="headerlink" title="指针与多维数组"></a>指针与多维数组</h3><p>假如有下面两个定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> *b[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>从语法角度讲，<code>a[3][4]</code>和<code>b[3][4]</code>都是对一个 int 对象的合法应用。但 a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间；</p>
<p>而对于 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化。假定 b 的每个元素都指向一个具有 20 个元素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空间。</p>
<p>指针数组的一个重要优点在于，数组的每一行长度可以不同。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>根据 C 语言的约定，<code>argv[0]</code>的值是启动该程序的程序名，因此<code>argc</code>的值至少为 1。ANSI 标准要求<code>argv[argc]</code>的值必须为一空指针。</p>
<h3 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h3><p>在 C 语言中，函数本身不是变量，但<strong>可以定义指向函数的指针</strong>。</p>
<p>和数组名一样，当一个变量为函数的地址时，前面不需要加上取地址符<code>&amp;</code>；</p>
<p>由于任何类型的指针都可以转换为<code>void *</code>类型，并且在将它转换为原来的类型时不会丢失信息，所以，调用函数时可以将参数强制转换为<code>void*</code>类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*comp)(<span class="keyword">void</span> *, <span class="keyword">void</span> *)</span><br></pre></td></tr></table></figure>

<p>表明<code>comp</code>是一个<strong>指向函数的指针</strong>，该函数具有两个<code>void*</code>类型的参数，其返回值类型为<code>int</code>。<code>*comp</code>代表一个函数。</p>
<h3 id="复杂声明"><a href="#复杂声明" class="headerlink" title="复杂声明"></a>复杂声明</h3><p>C 语言的复杂声明容易让人混淆，因为 C 语言的声明不能从左至右阅读，并且使用了太多的圆括号。例如下面两个声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* f: 是一个函数，它返回一个指向 int 类型的指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pf: 是一个指向函数的指针，该函数返回一个 int 类型的对象 */</span></span><br><span class="line"><span class="keyword">int</span> (*pf)();</span><br></pre></td></tr></table></figure>
<p>他们之间的含义差别说明：<code>*</code>是一个前缀运算符，其优先级低于<code>()</code>。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>ANSI 标准在结构方面最主要的变化是定义了结构的赋值操作–结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值。</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关键字 struct 引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字 struct 后面的名字是可选的，称为<strong>结构标记</strong>。结构标记用于为结构命名，在定义后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。</p>
<p>结构中定义的变量称为<strong>成员</strong>。<strong>结构成员、结构标记和普通变量（即非成员）可以采用相同的名字</strong>，因为通过上下文分析总可以对它们进行区分，因此不会冲突。另外，不同结构中的成员可以使用相同的名字。</p>
<p>struct 声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> ... &#125; x, y, z;</span><br></pre></td></tr></table></figure>

<p>如果结构声明的后面<strong>不带变量表</strong>，则<strong>不需要为它分配存储空间</strong>，它仅仅描述了一个结构的模版或轮廓。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可使用该标记定义，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt</span>;</span></span><br></pre></td></tr></table></figure>

<p>结构的<strong>初始化</strong>可以在定义的后面使用初值表进行，初值表中同每个成员对应的初值必须是常量表达式，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">maxpt</span> =</span> &#123; <span class="number">320</span>, <span class="number">200</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构的函数进行初始化。</p>
<h3 id="结构和函数"><a href="#结构和函数" class="headerlink" title="结构和函数"></a>结构和函数</h3><p>如果传递给函数的结构很大，使用<strong>指针</strong>方式的效率通常比复制整个结构的效率要高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">origin</span>, *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">pp = &amp;origin;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;origin is (%d,%d)\n&quot;</span>, (*pp).x, (*pp).y);</span><br></pre></td></tr></table></figure>

<p>其中，<code>(*pp).x</code>中的圆括号是必须的，因为结构成员运算符<code>.</code>的优先级高于<code>*</code>的优先级。</p>
<p>鉴于结构指针的使用频率非常高，为了使用方便，C 语言对于使用指向结构的指针 p 引用相应结构成员提供另一种简写方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;结构成员</span><br></pre></td></tr></table></figure>

<h3 id="类型定义（typedef）"><a href="#类型定义（typedef）" class="headerlink" title="类型定义（typedef）"></a>类型定义（typedef）</h3><p>typedef 声明并没有创建一个新类型，只是为某个已存在的类型增加了一个新的名称而已。实际上，typedef 类似于 #define 语句，但由于 typedef 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。</p>
<p>除了使表达方式更简洁之外，使用 typedef 还有两个重要原因：</p>
<ol>
<li>使程序参数化，以提高程序的可移植性；</li>
<li>为程序提供更好的说明。</li>
</ol>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p><strong>联合</strong>是可以（在不同时刻）保存不同类型和长度的对象的变量，编译器负责跟踪对象的长度和对齐要求。联合提供了一种方式，以在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息。</p>
<p>联合的目的：一个变量可以合法地保存多种数据类型中任何一种类型的对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">u_tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="keyword">float</span> fval;</span><br><span class="line">    <span class="keyword">char</span> *sval;</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure>

<p>变量 u 必须足够大，以保存这 3 种类型中最大的一种，具体长度同具体的实现有关。</p>
<p>实际上，联合就是一个结构，它的所有成员相对于基地址的偏移量都为 0，此结构空间要大到足够容纳最“宽”的成员，并且，其对齐方式要适合于联合中所有类型的成员。对联合允许的操作与对结构允许的操作相同。</p>
<p>联合只能用其第一个成员类型的值进行初始化。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>C 语言</tag>
      </tags>
  </entry>
  <entry>
    <title>【paper reading】2021 小样本分割论文选读</title>
    <url>/blog/few-shot-segmentation-2021/</url>
    <content><![CDATA[<p>根据手头想法的需要，读一读 2021 年顶会顶刊的小样本分割相关论文并做笔记于此。有开源代码的论文优先，持续更新。</p>
<ul>
<li>Prior Guided Feature Enrichment Network for Few-Shot Segmentation (TPAMI 2020)</li>
<li>Few-Shot Segmentation Via Cycle-Consistent Transformer (NeurIPS 2021)</li>
<li>Simpler is Better: Few-shot Semantic Segmentation with Classifier Weight Transformer (ICCV 2021)</li>
<li>Few-Shot Segmentation Without Meta-Learning: A Good Transductive Inference Is All You Need? (CVPR 2021)</li>
<li>Self-Guided and Cross-Guided Learning for Few-Shot Segmentation (CVPR 2021)</li>
<li>Adaptive Prototype Learning and Allocation for Few-Shot Segmentation (CVPR 2021)</li>
<li>Mining Latent Classes for Few-shot Segmentation (ICCV 2021)</li>
<li>Few-Shot 3D Point Cloud Semantic Segmentation (CVPR 2021)</li>
</ul>
<!-- [参考](https://github.com/xiaomengyc/Few-Shot-Semantic-Segmentation-Papers) -->

<span id="more"></span>

<h3 id="Prior-Guided-Feature-Enrichment-Network-for-Few-Shot-Segmentation"><a href="#Prior-Guided-Feature-Enrichment-Network-for-Few-Shot-Segmentation" class="headerlink" title="Prior Guided Feature Enrichment Network for Few-Shot Segmentation"></a>Prior Guided Feature Enrichment Network for Few-Shot Segmentation</h3><p>TPAMI 2020 | <a href="http://arxiv.org/abs/2008.01449">arxiv</a> | <a href="https://github.com/dvlab-research/PFENet">github</a></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TPAMI2020-prior-guided-feature-enrichment-network-for-FSS-figure3.png"></p>
<p>这篇工作被很多 2021 年的相关论文作为 baseline 并且效果仍然有竞争力，因此先介绍一下。该论文提出了 <strong>Prior Guided Feature Enrichment Network (PFENet)</strong> 来解决两个问题：(1) 很多分割方法都依赖于 high-level 特征，然而 <a href="http://arxiv.org/abs/1903.02351">CANet, CVPR 2019</a> 的实验结果表明<strong>小样本模型仅仅使用 high-level 特征会导致表现下降</strong>；(2) 样本数量过少会导致 support 物体的尺寸和姿态都和 query target 有很大不同，在该文中被称为 <strong>spatial inconsistency</strong>，并且 ablation study 的实验结果表明仅仅集成 multi-scale 结构对于该问题只是次优解。因此，本文提出了以下两点贡献：</p>
<p><strong>prior generation</strong>：使用 <strong>high-level 特征</strong>（实践中是 conv5_x 的最后一层的输出）来生成 prior mask。在用 support mask 遮盖提取的 support 特征后，计算 support 和 query 特征的 pixel-wise cosine 相似度。对于 query 中的每个像素，取其和所有 support 像素的相似度中的最大值来得到 prior mask。之后 prior mask 经过 min-max normalization 来将所有值放缩到 [0, 1] 范围。如果 shot 数大于 1，将同一 query 特征和不同 support 特征得到的多张 prior masks 求平均来得到最终的 prior mask 输入到 FEM。<!-- 源码显示这里是先单独做 normalization 再总体求平均 --></p>
<!-- 按照 CyCTR 的意思，这里只用 support 的前景信息来计算这个 prior mask 就不合适了。正好 OSAD 任务没有完全的前景信息，如何在这一块上做一些改变，让它不像现在的样子？ -->

<!-- 和 OSADNet_v2 的最后一个模块有点像，不过那个是 query 和其他 query 算的一个 transductive 方法 -->

<!-- 另外在 5-shot 设置能不能不要单纯求均值？感觉会有信息损失 -->

<p><strong>Feature Enrichment Module (FEM)<strong>：这一块看下图比较好理解，就是用多个 average pooling 来将 query 特征、support prototype 和 prior mask 的拼接产物放缩到不同大小，然后做 multi-scale 的信息交互。注意 query 特征和 support 特征是通过</strong>拼接 middle-level 特征</strong>（实践中是 conv3_x、conv_4x 的最后一层的输出）得到，另外如果 shot 数大于 1，直接取所有处理后的 support 特征的均值作为新的 support 特征。inter-scale interaction 的每个 scale 的产物也会过一个 3x3 + 1x1 的卷积层组成的分类头得到损失 $\mathcal{L}^i_1$，然后所有 scale 产物拼接后经过 1x1 卷积也用分类头得到损失 $\mathcal{L}_{2}$。最终的总损失为 $\mathcal{L} = \frac{\sigma}{n}\sum^n_{i=1} \mathcal{L}^i_1 + \mathcal{L}_{2}$，$\sigma$ 在所有实验中设为 1.0。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TPAMI2020-prior-guided-feature-enrichment-network-for-FSS-figure4.png"></p>
<p>一个稍微需要注意的点是图中带圈的 M 的结构如下图所示，其中 auxiliary 特征指 finer 特征，main 特征指 coarse 特征。对于没有 auxiliary 特征的 main 特征（如上图最上面的一个 scale），省略下图的第一步拼接操作。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TPAMI2020-prior-guided-feature-enrichment-network-for-FSS-figure5.png"></p>
<p>实验结果：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TPAMI2020-prior-guided-feature-enrichment-network-for-FSS-table1.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TPAMI2020-prior-guided-feature-enrichment-network-for-FSS-table3.png"></p>
<h3 id="Few-Shot-Segmentation-Via-Cycle-Consistent-Transformer"><a href="#Few-Shot-Segmentation-Via-Cycle-Consistent-Transformer" class="headerlink" title="Few-Shot Segmentation Via Cycle-Consistent Transformer"></a>Few-Shot Segmentation Via Cycle-Consistent Transformer</h3><p>NeurIPS 2021 | <a href="https://papers.nips.cc/paper/2021/hash/b8b12f949378552c21f28deff8ba8eb6-Abstract.html">link</a> | <a href="https://github.com/GengDavid/CyCTR">github（尚未包含代码）</a></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-cycle-consistent-TRansformer-figure1.png"></p>
<p>已有的小样本分割工作通常从 support 的图像特征提取 semantic-level prototypes，其中根据可以分为两类：(1) 如上图 (a) 所示的 class-wise mean pooling (<a href="http://arxiv.org/abs/1908.06391">PANet, ICCV 2019</a>; <a href="http://arxiv.org/abs/1810.09091">SG-One, IEEE Trans. Cybern., 2020</a>; <a href="http://arxiv.org/abs/1903.02351">CANet, CVPR 2019</a>)，将属于不同类别的区域的特征算均值得到 prototypes；(2) 如上图 (b) 所示的 clustering，使用 EM 算法 (<a href="https://arxiv.org/abs/2008.03898">RPMM, ECCV 2020</a>) 或者 K-means (<a href="https://arxiv.org/abs/2007.06309">PPNet, ECCV 2020</a>) 来生成多个 prototypes 。然而，基于 prototypes 的方法会导致不同程度的 support information 的损失。因此，一些工作 (<a href="https://openaccess.thecvf.com/content_ICCV_2019/html/Zhang_Pyramid_Graph_Networks_With_Connection_Attentions_for_Region-Based_One-Shot_Semantic_ICCV_2019_paper.html">PGNet, ICCV 2019</a>; <a href="https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123580715.pdf">DAN, ECCV 2020</a>) 用 attention 机制来从 support 前景像素提取信息。然而，<strong>这些方法忽略了存在对分割有帮助的信息的 support 背景像素</strong>；同时，support 和 query 图像间的包含尺度、颜色、场景等差别使得只有一小部分 support 像素是对 query 图像的分割有帮助，而<strong>另一些 support 像素会和 query 的前景像素有很大差别，导致 attention 无法准确表示语义上的对齐</strong>。</p>
<p>本文提出了 <strong>Cycle-Consistent Transformer (CyCTR)</strong> 模块，包含两种 Transformer 部件：(1) <strong>self-alignment block</strong>：通过聚合相关的上下文信息来编码 query 的图像特征，Query、Key 和 Value 都来自同个 embedding；(2) <strong>cross-alignment block</strong>：将 support 图像的 pixel-wise 特征聚合到 query 图像的 pixel-wise 特征中，query 图像的特征是 Query，support 图像的特征作为 Key 和 Value。另外，一种新的 <strong>cycle-consistent attention</strong> 被部署在 cross-alignment block 上。从一个 support 像素的特征出发，我们找到它在 query 特征上的最近邻，然后在找到与这个最近邻最相似的 support 特征。如果起点和终点的 support 特征属于同一类别，就称作建立起了 <strong>cycle-consistency relationship</strong>。这个操作被集成到 attention 中来让 query 特征只去注意 cycle-consistent support 特征。因此，我们可以在避免将 bias 引入到 query 特征的前提下，利用 support 的背景像素。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-cycle-consistent-TRansformer-figure3.png"></p>
<!-- 从 Figure 3 可以看出，CyCTR 还是在增强 query 特征 -->

<p>具体实现上，support 和 query 特征都被拉伸成 1D 序列输入到 transformer 中，序列的长度分别为 $H_qW_q$ 和 $N_s$。如上图所示，$L$ 个编码器堆叠起来，每个编码器输出的 query 特征被输入到下一个编码器中的 self-alignment block，直到最终输出的 query 特征进行 pixel-wise 的分类。在 <strong>cross-alignment block</strong> 中，首先计算一个 affinity map $A = \frac{QK^T}{\sqrt{d}}, A \in \mathbb{R}^{H_qW_q \times N_s}$ 来度量所有 query 和 support 像素的关联度。然后，对于第 $j$ 个 support 像素，可以找到与其最相似的 query 像素 $i^{\star}=\text{argmax}_i A_(i,j)$。然后再返回找到与 query 像素 $i^{\star}$ 最相似的 support 像素 $j^{\star}=\text{argmax}_j A_(i^{\star},j)$。给定 support 像素标签 $M_s \in \mathbb{R}^{N_s}$，获得一个 additive bias $B \in \mathbb{R}^{N_s}$：</p>
<p>$$B_{j}= \begin{cases}0, &amp; \text { if } M_{s(j)}=M_{s\left(j^{\star}\right)} \\<br>-\infty, &amp; \text { if } M_{s(j)} \neq M_{s\left(j^{\star}\right)} \end{cases}$$</p>
<p>则对于位置为 $i$ 的单个 query token（即像素）$Z_{q(i)} \in \mathbb{R}^d$，通过下式来聚合 support 信息：</p>
<p>$$\text{CyCAtten}(Q_i, K_i, V_i) = \text{softmax}(A_{i} + B)V$$</p>
<p>当在 self-alignment block 中执行 self-attention 时，也可能存在 query token 聚合到无关甚至是有害的特征（尤其当背景较为复杂时）。然而，由于没有 query 像素的标签，无法在 query 的像素上执行 cycle-consistent attention。受到 <a href="https://openreview.net/forum?id=gZ9hCDWe6ke">DeformableAttention (ICLR 2021)</a>，可以通过学习的方式获得 consistent 像素 $\triangle = f(Q + \text{Coord}), \triangle \in \mathbb{R}^{H_pW_p \times P}$ 以及对应的 attention weights $A^{<code>&#125; = g(Q + \text&#123;Coord&#125;), A^&#123;</code>} \in \mathbb{R}^{H_qW_q \times P}$，$P$ 代表被聚合的像素的数量。$\text{Coord} \in \mathbb{R}^{H_qW_q \times N_s}$ 是位置编码，$f(\cdot)$ 和 $g(\cdot)$ 是用于预测 offsets 和 attention weights 的全连接层。因此，self-alignment block 中的 self-attention 可以被表示为：</p>
<p>$$\text{PredAtten}(Q_r, V_r) = \sum^P_g\text{softmax}(A^{`})_{(r,g)}V_{r+\triangle_{r,g}}$$</p>
<p>其中，$r \in {0,1, \dots, H_qW_q}$ 是拉伸的 query 特征的 index，$Q$ 和 $V$ 通过对拉伸的 query 特征用可学习的参数进行线性变换得到。</p>
<p>以上讨论的是 1-shot 的情况。当 shot 数大于 1 时，可以将所有 support 特征拉伸并拼接作为输入。然而这样会导致计算量过大，因此可以采取一个非常简单的 mask-guided sampling 策略来减小计算复杂度。给定 $k$-shot support 特征 $Z_s \in \mathbb{R}^{kH_sW_s \times d}$，support tokens（即像素）通过从所有 support 图像的前景区域均匀随机采样 $N_{fg}$ 个（$N_{fg} \leq \frac{N_s}{2}$，其中 $N_s \leq kH_sW_s$）和从背景区域采样 $N_s - N_{fg}$ 个得到。通过选择一个合适的 $N_s$，这个策略既能有效减少计算量，也能够帮助平衡前景和后景的比例。</p>
<p>方法的整体框架如下图所示。值得注意的是，该方法还是先用 <a href="http://arxiv.org/abs/2008.01449">PFENet (TPAMI 2020)</a> 对 support 和 query 的特征进行了处理再输入到 cycle-consistent transformer 中。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-cycle-consistent-TRansformer-table5.png"></p>
<p>实验结果：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-cycle-consistent-TRansformer-table1.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-cycle-consistent-TRansformer-table2.png"></p>
<!-- 对于 OSAD 的参考/思考：

1. 在 FSAD 中，support 和 query 中与 affordance 不相关的像素更多，如何解决？能否参考 weak-shot segmentation 先把边界弄出来？ 
2. 用一个 CyCTR 模块来代替 FSAD 的中间处理部分呢？

-->

<h3 id="Simpler-is-Better-Few-shot-Semantic-Segmentation-with-Classifier-Weight-Transformer"><a href="#Simpler-is-Better-Few-shot-Semantic-Segmentation-with-Classifier-Weight-Transformer" class="headerlink" title="Simpler is Better: Few-shot Semantic Segmentation with Classifier Weight Transformer"></a>Simpler is Better: Few-shot Semantic Segmentation with Classifier Weight Transformer</h3><p>ICCV 2021 | <a href="http://arxiv.org/abs/2108.03032">arxiv</a> | <a href="https://github.com/zhiheLu/CWT-for-FSS">github</a></p>
<p>分割模型通常由编码器、解码器和一个简单的分类器（通常是一个 1x1 卷积层，参数 $\mathbf{w} \in \mathbb{R}^{2 \times d}$ 用于将 $d$ 个 channel 映射来二分类以区分前景和背景像素）组成。现有的一些小样本分割方法对三部分的参数都进行元学习。而本文提出考虑到样本量极少，三部分的参数都快速适应到新类仍然很难。因此，本文提出<strong>元学习阶段只关注分类器</strong>，而<strong>采用预训练的方式来处理编码器和解码器</strong>（本文采用 <a href="https://arxiv.org/abs/1612.01105">PSPNet (CVPR 2017)</a> 作为骨干分割网络），认为在经过大量基类的数据训练后它们能够泛化到新类上。之后，编、解码器的参数被冻结。在元学习阶段，首先使用 support 样本来训练分类器参数 $\mathbf{w}$。本文提出这样得到的总体模型的表现已经能够超越（当时的）SOTA <a href="https://arxiv.org/abs/2007.06309">PPNet (ECCV 2020)</a>，如下表 1、5 所示：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-FSSS-with-clssifier-weight-transformer-table1.PNG"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-FSSS-with-clssifier-weight-transformer-table5.PNG"></p>
<p>然而，本文继续提出，由于较大的类内变化（或者说类内差异）的存在，在 support 样本上学到的 $\mathbf{w}$ 无法很好地适应到每个 query 样本上。因此，本文提出 <b>Classifier Weight Transformer (CWT)</b>，在元学习阶段去学习每个 query 样本特定的分类器权重。模型流程图如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-FSSS-with-clssifier-weight-transformer-figure3.png"></p>
<p>具体地，CWT 中的 self-attention 可以被表示为：</p>
<p>$$\mathbf{w}^{*}=\mathbf{w}+\psi\left(\text{softmax}\left(\frac{\boldsymbol{w} \mathbf{W}_{q}\left(\boldsymbol{F} \mathbf{W}_{k}\right)^{\top}}{\sqrt{d_{a}}}\right)\left(\boldsymbol{F} \mathbf{W}_{v}\right)\right)$$</p>
<p>其中，$\boldsymbol{F} \in \mathbb{R}^{n \times d}$ 代表 query 样本 $n$ 个像素提取出的特征，$\mathbf{W}_{q}/\mathbf{W}_{k}/\mathbf{W}_{v} \in \mathbb{R}^{n \times d_{a}}$ 是可训练参数，而 $\mathbf{w}^{*}$ 即是将用在该 query 样本上的参数。CWT 的直觉是，相比背景像素，通常情况下 query 中的前景像素特征会和 $\mathbf{w}$ 计算得到更大的相似度，因此可以据此调整 $\mathbf{w}$。在（元）测试阶段，CWT 的参数也是冻结的。</p>
<p>除开表 1、5 外的其他实验结果：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-FSSS-with-clssifier-weight-transformer-table23.PNG"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-FSSS-with-clssifier-weight-transformer-table4.PNG"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-FSSS-with-clssifier-weight-transformer-table6.PNG"></p>
<!-- 这种 Transformer 结构能否用到 few-shot 3D 点云分割上？或者说这种 encoder 和 decoder 一起用所有 base data pre-train 然后 freeze 的范式 -->

<h3 id="Few-Shot-Segmentation-Without-Meta-Learning-A-Good-Transductive-Inference-Is-All-You-Need"><a href="#Few-Shot-Segmentation-Without-Meta-Learning-A-Good-Transductive-Inference-Is-All-You-Need" class="headerlink" title="Few-Shot Segmentation Without Meta-Learning: A Good Transductive Inference Is All You Need?"></a>Few-Shot Segmentation Without Meta-Learning: A Good Transductive Inference Is All You Need?</h3><p>CVPR 2021 | <a href="https://openaccess.thecvf.com/content/CVPR2021/html/Boudiaf_Few-Shot_Segmentation_Without_Meta-Learning_A_Good_Transductive_Inference_Is_All_CVPR_2021_paper.html">link</a> | <a href="https://github.com/mboudiaf/RePRI-for-Few-Shot-Segmentation">github</a></p>
<p>本文提出现有的小样本分割工作所遵循的两个假设在现实场景中通常是不可用的：(1) episodic training 假设 testing tasks 的 support shots 数量和 meta-training 阶段使用的任务保持一致；(2) base 和 novel 类别通常被假设从同一数据集中采样得到。针对假设 (1)，本文的思想与 <a href="https://openreview.net/forum?id=rylXBkrYDS">Transductive Fine-Tuning, ICLR 2020</a> 等小样本识别方法有共通之处，提出精心设计的 transductive fine-tuning 的方法 <b>RePRI (Region Proportion Regularized Inference)</b>，能够用线性的分类器取得 SOTA。针对假设 (2)，本文也引入了 cross-domain 的设置，即 base 和 novel 类别来自不同的数据集，并在 COCO-&gt;PASCAL 上取得 SOTA。</p>
<p>在 meta-training 阶段，RePRI 不采用 episodic training，而是用整个 base set 和标准交叉熵来训练特征提取器。在每个 testing task 进行 inference 时，RePRI 在优化时采用的损失包含三项：</p>
<ol>
<li>$\mathrm{CE}=-\frac{1}{K|\Psi|} \sum_{k=1}^{K} \sum_{j \in \Psi} \widetilde{y}_{k}(j)^{\top} \log \left(p_{k}(j)\right)$：标准的交叉熵 (cross-entropy, CE)，作用于 support 图像的有标签像素上。注意只使用这一项来进行优化通常导致过拟合于 support set，尤其是 1-shot 设置时；</li>
<li>$\mathcal{H}=-\frac{1}{|\Psi|} \sum_{j \in \Psi} p_{\mathcal{Q}}(j)^{\top} \log \left(p_{\mathcal{Q}}(j)\right)$：香农熵 (Shannon entropy)，作用于 query 图像像素的预测上，来使模型对 query 图像的预测更加有信心。直观来说，这一项让线性分类器的决策边界推向 query 特征空间的低密度区域。在对最初置信度较低的区域的预测有帮助的同时，仅仅将这项加入到损失中并不能解决 CE 导致的问题，甚至可能使表现进一步恶化，如下图 Figure 1 所示；</li>
<li>$\mathcal{D}_{\mathrm{KL}}=\widehat{p}_{\mathcal{Q}}^{\top} \log \left(\frac{\widehat{p}_{\mathcal{Q}}}{\pi}\right), \widehat{p}_{\mathcal{Q}}=\frac{1}{|\Psi|} \sum_{j \in \Psi} p_{\mathcal{Q}}(j)$：KL 散度，鼓励模型预测的背景/前景 (B/F) 比例接近于一个参数 $\pi \in [0, 1]^2$。论文指出这一项在损失中占关键位置，首先当参数 $\pi$ 与 query 图像的精确 B/F 比例不匹配时，该项有助于避免因 $\mathrm{CE}$ 和 $\mathcal{H}$ 最小化而导致的退化解；而如果能够准确估计 query 图像中的 B/F 比例（即有这个先验知识可供使用时），该项可以大幅提高方法整体的性能。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-a-good-transductive-inference-is-all-you-need-figure1.png"></p>
<p><strong>分类器的选择</strong>：RePRI 的线性分类器和 <a href="http://arxiv.org/abs/1904.04232">Baseline++, ICLR 2019</a> 相似：$s^{(t)}(j)=\text{sigmoid}\left(\tau\left[\cos \left(z(j), w^{(t)}\right)-b^{(t)}\right]\right)$。其中原型 $w^{(0)}$ 是 support 前景特征的均值：$w^{(0)}=\frac{1}{K|\Psi|} \sum_{k=1}^{K} \sum_{j \in \Psi} \widetilde{y}_{k}(j)_{1} z_{k}(j)$；$b^{(0)}$ 是对 query 前景的 soft predictions的均值 ：$b^{(0)}=\frac{1}{|\Psi|} \sum_{j \in \Psi} p_{\mathcal{Q}}(j)_{1}$。</p>
<p><strong>B/F 比例 $\pi$ 的联合估计</strong>：当没有先验知识时，RePRI 使用 $\widehat{p}_{\mathcal{Q}}$ 来联合学习 $\pi$ 和分类器的参数，这时 $\mathcal{D}_{\mathrm{KL}}$ 可以被视为 self-regularization 来防止模型的 marginal distribution 发生偏移。具体实现中，只在初始化后在之后的某一轮迭代 $t_{\pi}$ 更新一次 $\pi$ 即可，即</p>
<p>$$\pi^{(t)}= \begin{cases}\widehat{p}_{\mathcal{Q}}^{(0)} &amp; 0 \leq t \leq t_{\pi} \\<br>\hat{p}_{\mathcal{Q}}^{\left(t_{\pi}\right)} &amp; t&gt;t_{\pi}\end{cases}$$</p>
<p>实验结果：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-a-good-transductive-inference-is-all-you-need-table1.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/NeurIPS2021-a-good-transductive-inference-is-all-you-need-table2.png"></p>
<p>可以看到在 5-shot 上 RePRI 取得了全面的 SOTA。本文同样做了包含 (1) 训练时采用 1-shot task、测试时用 1-\5-\10-shot task；(2) cross-domain 等实验。具体请看原论文。</p>
<h3 id="Self-Guided-and-Cross-Guided-Learning-for-Few-Shot-Segmentation"><a href="#Self-Guided-and-Cross-Guided-Learning-for-Few-Shot-Segmentation" class="headerlink" title="Self-Guided and Cross-Guided Learning for Few-Shot Segmentation"></a>Self-Guided and Cross-Guided Learning for Few-Shot Segmentation</h3><p>CVPR 2021 | <a href="https://openaccess.thecvf.com/content/CVPR2021/html/Zhang_Self-Guided_and_Cross-Guided_Learning_for_Few-Shot_Segmentation_CVPR_2021_paper.html">link</a> | <a href="https://github.com/zbf1991/SCL">github</a></p>
<p>本文同样提出常用的 masked Global Average Pooling (GAP) 来将 support 图像转换为特征向量的方式会导致有区分性的信息因为求均值操作而损失。另外，当 shot 数量不为 1 时，常用的对所有 support 向量求均值会强制使得所有的 support 图像贡献相同，而不同的 support 图像的对于表示类别的贡献实际上是不同的。</p>
<p>为了解决这两个问题，本文提出 <b>Self-Guided and Cross-Guided Learning (SCL)</b>，首先用初始原型来对 support 图像做初始预测，预测覆盖和没有覆盖到的前景区域被用 masked GAP 编码成 primary 和 auxiliary support 向量来在 query 图像的分割上取得更好表现。同时，针对 shot 数量不为 1 的场景，本文提出 <strong>Cross-Guided Module (CGM)</strong> 来使用其他有标注 support 图像评估每张 support 图像的预测质量，使高质量的 support 图像能够对最终的融合做出更大的贡献。相比 attention 等复杂的方法，CGM 无需重新训练模型，可以直接在 inference 时被应用来提升最终的表现。SCL 遵循 episodic training 的方式，总损失为 $\mathcal{L}=\mathcal{L}_{c e}^{s 1}+\mathcal{L}_{c e}^{s 2}+\mathcal{L}_{c e}^{q}$，前两项来自 support set 的 Self-Guided Learning，后一项来自 query set。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-self-guided-and-cross-guided-learning-for-FSS-figure3.png"></p>
<p><strong>Self-Guided Learning on Support Set</strong>：这里首先以 1-shot 为例。用 masked GAP 获得的初始 support 向量 $\mathcal{v}_s$ 被扩展成和 support 特征图 $F_s$ 同样大小的 $V_s$，然后拼接得到新的特征图 $F_{sv} = \text{Concat}([F_s, V_s, V_s])$。通过将 $F_{sv}$ 输入到 <strong>support FPM</strong> 和 decoder，可以得到support 图像的概率图 $P_{s1} = \text{softmax}(\mathcal{D}(FPM_s(F_{sv})))$，其中 $\mathcal{D}(\cdot)$ 指 decoder。由于 SCL 是一个即插即用的模块，因此 support FPM 和 decoder 的设计遵循所选择的小样本分割 baseline。本文的实验部分选择插入到两种 baseline 中：(1) <a href="http://arxiv.org/abs/1903.02351">CANet (CVPR 2019)</a>，其 decoder 是 single-scale 结构的，因此 SCL 也采用 single-scale support FPM；(2) <a href="http://arxiv.org/abs/2008.01449">PFENet (TPAMI 2020)</a>，其 decoder 是 multi-scale 结构的，因此 SCL 也采用 multi-scale support FPM。single-scale 和 multi-scale 的 support FPM 结构如上图右边所示。</p>
<p>使用预测的 mask $\hat{M_s} = \text{argmax}(P_{s1})$ 和 ground-truth mask $M_s$，可以得到 primary support 向量 $\mathcal{v}_{pri}$ 和 auxiliary support 向量 $\mathcal{v}_{aux}$，前者代表预测正确的实际前景信息，后者代表预测错误的实际前景信息。换句话说，$\mathcal{v}_{pri}$ 保持着主要的 support 信息，而 $\mathcal{v}_{aux}$ 包含用 $\mathcal{v}_s$ 无法预测的、损失的重要信息。为了保证 $\mathcal{v}_{pri}$ 能够从 support 的特征图收集到大多数的信息，对 $P_{s1}$ 施加交叉熵得到 $\mathcal{L}_{c e}^{s 1}$：</p>
<p>$$\mathcal{L}_{c e}^{s 1}=-\frac{1}{h w} \sum_{i=1}^{h w} \sum_{c_{j} \in{0,1}}\left[M_{s}(i)=c_{j}\right] \log \left(P_{s 1}^{c_{j}}(i)\right)$$</p>
<p>接下来，$\mathcal{v}_{pri}$ 和 $\mathcal{v}_{aux}$ 也被扩展并与 $F_s$ 拼接得到 $F^A_{s} = \text{Concat}([F_s, V^{pri}_s, V^{aux}_s])$，然后得到 $P_{s2} = \text{softmax}(\mathcal{D}(FPM_s(F^A_{s})))$。为了确保集成 $\mathcal{v}_{pri}$ 和 $\mathcal{v}_{aux}$ 能够得到精准的分割 mask，同样施加交叉熵得到 $\mathcal{L}_{c e}^{s 2}$：</p>
<p>$$\mathcal{L}_{c e}^{s 2}=-\frac{1}{h w} \sum_{i=1}^{h w} \sum_{c_{j} \in{0,1}}\left[M_{s}(i)=c_{j}\right] \log \left(P_{s 2}^{c_{j}}(i)\right)$$</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-self-guided-and-cross-guided-learning-for-FSS-figure2.png"></p>
<p><strong>Training on Query Set</strong>：对于 query 的特征图 $F_q$，流程为 $F^A_{q} = \text{Concat}([F_q, V^{pri}_q, V^{aux}_q])$，其中 $V^{pri}_q$ 和 $V^{aux}_q$ 是 $\mathcal{v}_{pri}$ 和 $\mathcal{v}_{aux}$ 扩展大小得到；$P_{q} = \text{softmax}(\mathcal{D}(FPM_q(F^A_{q})))$，注意这里有一个单独的 <strong>query FPM</strong> $FPM_q$ 而非 $FPM_s$。同样计算交叉熵得到 $\mathcal{L}_{c e}^{q}$：</p>
<p>$$\mathcal{L}_{c e}^{q}=-\frac{1}{h w} \sum_{i=1}^{h w} \sum_{c_{j} \in{0,1}}\left[M_{q}(i)=c_{j}\right] \log \left(P_{q}^{c_{j}}(i)\right)$$</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-self-guided-and-cross-guided-learning-for-FSS-figure5.png"></p>
<p><strong>Cross-Guided Multiple Shot Learning</strong>：当 shot 数 &gt; 1 时，对于第 k 张 support 图像，首先将其作为 support 图像，将所有 K 张 support 图像作为 query 图像来输入到所提出的面向 1-shot 的模型中。对于第 i 张 support 图像，得到在第 k 张图像的支持下的预测 mask $\hat{M}_{s}^{i \mid k}$。因为第 i 张 support 图像的 ground-truth mask $M_s^i$ 是可得的，因此可以用预测和 ground-truth 的 masks 的 IOU 来计算一个置信度：</p>
<p>$$U_{s}^{k}=\frac{1}{K} \sum_{i=1}^{K} \text{IOU}\left(\hat{M}_{s}^{i \mid k}, M_{s}^{i}\right)$$</p>
<p>则对于给定的 query 图像的最终预测 score map：</p>
<p>$$\hat{P}_{q}=\text{softmax}\left(\frac{1}{K} \sum_{k=1}^{K} U_{s}^{k} \mathcal{G}\left(I_{q} \mid I_{s}^{k}\right)\right)$$</p>
<p>可以看到有更大的 $U_{s}^{k}$ 的 support 图像对于最终的预测有更大的贡献。</p>
<p>实验结果：</p>
<!-- 所以说设计即插即用的模块就是好，加在 SOTA 上就是新的 SOTA。 -->

<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-self-guided-and-cross-guided-learning-for-FSS-table1.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-self-guided-and-cross-guided-learning-for-FSS-table2.png"></p>
<h3 id="Adaptive-Prototype-Learning-and-Allocation-for-Few-Shot-Segmentation"><a href="#Adaptive-Prototype-Learning-and-Allocation-for-Few-Shot-Segmentation" class="headerlink" title="Adaptive Prototype Learning and Allocation for Few-Shot Segmentation"></a>Adaptive Prototype Learning and Allocation for Few-Shot Segmentation</h3><p>CVPR 2021 | <a href="https://openaccess.thecvf.com/content/CVPR2021/html/Li_Adaptive_Prototype_Learning_and_Allocation_for_Few-Shot_Segmentation_CVPR_2021_paper.html">link</a> | <a href="https://github.com/Reagan1311/ASGNet">github</a></p>
<p>本文认为虽然相比需要用稠密 affinity 矩阵来解决欠约束的像素匹配问题而容易过拟合的 affinity learning，常用的 prototypical learning 能够比单纯的像素特征更加鲁棒，但是仅用一个 prototype 不足以表示包含空间信息在内的所有信息。特别地，本文希望能够根据图像内容自适应地调整 prototypes 的数量和空间范围，从而能够更好地处理物体在尺寸和形状上的变化。例如对一个尺寸较小的物体，可能一个或少量 prototypes 就足够了；而对于尺寸较大的物体，可能需要更多的 prototypes 来表示所有重要的信息。</p>
<p>因此，本文提出 <b>Adaptive Superpixel-guided Network (ASGNet)</b>，包含 <strong>superpixel-guided clustering (SGC)</strong> 和 <strong>guided prototype allocation (GPA)</strong> 两个模块用于提取和分配多个 prototypes。SGC 模块在 support 图像上进行快速的、基于特征的 superpixel 提取，得到的 superpixel centroids 可以被视为 prototypical 特征，同时 superpixel 的数量和形状都是适应于图像内容的，因此得到的 prototypes 是自适应的。GPA 模块用一个 attention-like 机制来讲最相关的 support prototype 特征分配给 query 图像中的每个像素。最后，ASGNet 使用 <a href="http://arxiv.org/abs/2008.01449">PFENet (TPAMI 2020)</a> 中的特征增强结构并建立一个 FPN-like top-down 结构来引入 multi-scale 信息。当 shot 数大于 1 时，每张 support 图像都可以得到一组 prototypes，所有的 prototypes 被一块作为 GPA 的选择范围。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-adaptive-prototype-learning-and-allocation-for-FSS-figure2.png"></p>
<p><strong>Superpixel-guided Clustering</strong>：受到 <a href="https://arxiv.org/abs/1606.09518">maskSLIC (2016)</a>, <a href="https://arxiv.org/abs/1807.10174">Superpixel sampling networks (ECCV 2018)</a> 等工作的启发，SGC 模块被用于将特征图用聚类的方式集成到多个 superpixel centroids 中。给定 support 特征 $F_s \in \mathbb{R}^{c \times h \times w}$ 和 support mask $M_s \in \mathbb{R}^{h \times w}$，假设已经获得初始 superpixel 种子，SGC 首先将 support 特征图上每个像素的坐标的值进行放缩后和特征图进行拼接，从而引入位置信息。之后用 support mask 来筛除背景信息，这样我们获得 $F_s^{`} \in \mathbb{R}^{(c+2) \times N_m}$，$N_m$ 是在 support mask 中的像素的数量（注意这里我们对变量及其维度表示和原论文略有差别，我在阅读了源码后觉得这样表述会更清晰）。同样，我们也将初始 superpixel 种子的特征和其值放缩后的坐标拼接，有 $S^{0} \in \mathbb{R}^{(c+2) \times N_{sp}}$（$N_{sp}$ 是 superpixel 的数量。获得初始种子的方法见本节最后一段）。接下来，SGC 通过迭代式的方法更新 superpixel-based prototypes：在第 $t$ 轮迭代，首先计算每个像素 $p$ 和所有 superpixels 的 association map $Q^t$：</p>
<p>$$Q^t_{pi} = e^{- || F^{`}_p - S^{t-1}_i ||^2}$$</p>
<p>接下来，新的 superpixel centroids 被更新为 masked 特征的加权和：</p>
<p>$$S^t_i = \frac{1}{\sum_pQ^t_{pi}} \sum^{N_m}_{p=1} Q^t_{pi} F^{`}_p$$</p>
<!-- 这和那个基于 E-M 的有什么区别？区别好像是在于 E-M 会更新 base、attention 和 query features，而这个只更新 superpixel centroids -->


<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-adaptive-prototype-learning-and-allocation-for-FSS-figure3.png"></p>
<p>通常 superpixel 算法通过将图像划分为均匀大小的 grid cell 来选取初始种子（i.e., superpixel），但由于只需要从前景区域来初始化种子，本文参考 <a href="https://arxiv.org/abs/1606.09518">maskSLIC (2016)</a> 来迭代式地安置每个初始种子，流程如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-adaptive-prototype-learning-and-allocation-for-FSS-figure5.png"></p>
<p><strong>Guided Prototype Allocation</strong>：首先计算每个 prototype 和 query 特征每个位置的 cosine 相似度 $C^{x,y}_i$，这个相似度信息被输入到一个双分支结构。<strong>第一个分支</strong>计算每个位置的像素和哪个 prototype 最相似：</p>
<p>$$G^{x,y} = \text{argmax}_{i \in {0, \dots, N_{sp}}} C^{x,y}_i$$</p>
<p>根据得到的 guide map $G \in \mathbb{R}^{h \times w}$，可以通过将对应 prototype 放到 guide map 的每个位置得到 guide feature $F_G \in \mathbb{R}^{c \times h \times w}$。<strong>第二个分支</strong>将相似度信息 $C$ 在所有的 superpixels 相加来得到概率图 $P$。最终将 $P$、$F_G$ 和原本的 query 特征 $F_Q$ 拼接并过 $1 \times 1$ 卷积得到 refined query 特征 $F^{`}_Q$。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-adaptive-prototype-learning-and-allocation-for-FSS-figure4.png"></p>
<p>实验结果：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-adaptive-prototype-learning-and-allocation-for-FSS-table5.png"></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-adaptive-prototype-learning-and-allocation-for-FSS-table7.png"></p>
<h3 id="Mining-Latent-Classes-for-Few-shot-Segmentation"><a href="#Mining-Latent-Classes-for-Few-shot-Segmentation" class="headerlink" title="Mining Latent Classes for Few-shot Segmentation"></a>Mining Latent Classes for Few-shot Segmentation</h3><p>ICCV 2021 | <a href="http://arxiv.org/abs/2103.15402">arxiv</a> | <a href="https://github.com/LiheYoung/MiningFSS">github</a>：只给了一个在基础 metric-based 方法上做了些修改的 baseline，没有给论文所提出的方法的代码！</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-mining-latent-classes-for-FSS-figure2.png"></p>
<p>该论文的所谓“代码开源”令人不满，因此只做简单笔记。在 <a href="https://arxiv.org/abs/2007.06309">PPNet (ECCV 2020)</a> 等工作的基础上，本文的方法：</p>
<ol>
<li>将元训练分为离线标注（Offline Annotation）和协同训练（Joint Training）两个阶段。<b>离线标注</b>阶段，模型在所有训练图像得到的所有类别的原型集合（数量上限为图像数 $\times$ 类别数，当然不是每张图像都含所有类别的物体）中通过 K-Means 聚类产生 $K$ 个簇心，同时直接对所有代表背景的原型求均值得到全局背景原型，从而得到 $K+1$ 个新原型，用于给所有训练图像的所有像素用 cosine 相似度打 $K+1$ 类的伪标签（pseudo masks）。除开背景类别外，另外 $K$ 个聚类所得到的类不代表具体的物体种类，而是表示类别的一些共同特征（例如，“马”和“牛”都有的“四足动物”特征）；<b>协同训练</b>阶段采用 episodic training，并额外加了一个分支来用交叉熵训练预测 pseudo masks。该分支由三层带 BN 和 ReLU 的卷积构成，另外考虑到 pseudo masks 的噪声会在训练后期影响性能，因此模型参数更新时计算指数移动平均值（exponential moving average），使模型参数的更新更稳定。</li>
<li>由于学习新类时样本量过少，因此对用于像素二分类的背景和前景原型都分别进行纠偏。<b>背景原型纠偏</b>：在训练阶段采用指数移动平均值来不断用当前的背景原型来更新全局背景原型，在推断时用该全局背景原型和 support 的背景原型线性求和；<b>前景原型纠偏</b>：给定一张 support 图像，根据图像嵌入的 cosine 相似度选择前 N 张相关图像（一个问题就是这里没说相关图像是从哪个集合选），然后根据 support 的前景原型来挑选 K 个最相关的区域原型（这里也没说所谓的“区域”具体是怎么得到的），所有的嵌入通过 ResNet-50/101 的第三层的输出的平均池化得到。之后通过计算前景原型和区域原型的相似度来以加权求和的方式更新前景原型。</li>
</ol>
<p>实验结果就放一张在 PASCAL-5$^i$ 上的 SOTA 对比好了。虽然实验做的还比较详细，但是不给方法代码导致结果可信度要打一个问号。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/ICCV2021-mining-latent-classes-for-FSS-table1.png"></p>
<!-- ! 到这里了 -->

<!-- ICCV2021-mining-latent-classes-for-FSS- -->

<h3 id="Few-Shot-3D-Point-Cloud-Semantic-Segmentation"><a href="#Few-Shot-3D-Point-Cloud-Semantic-Segmentation" class="headerlink" title="Few-Shot 3D Point Cloud Semantic Segmentation"></a>Few-Shot 3D Point Cloud Semantic Segmentation</h3><p>CVPR 2021 | <a href="https://openaccess.thecvf.com/content/CVPR2021/html/Zhao_Few-Shot_3D_Point_Cloud_Semantic_Segmentation_CVPR_2021_paper.html">link</a> | <a href="https://github.com/Na-Z/attMPTI">github</a></p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-FS-3D-point-cloud-semantic-segmentation-figure1.png"></p>
<p>第一篇做小样本 3D 点云语义分割的论文。相比 2D 图像，点云更加无结构和无序，因此做语义分割的难度会更大。任务定义如上图所示，基本就是把 2D 数据换成 3D 点云。方法上，本文提出了 <strong>attention-aware multi-prototype transductive inference</strong> 框架。其包含以下三点：</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-FS-3D-point-cloud-semantic-segmentation-figure2.png"></p>
<p><strong>embedding network</strong>：对标 2D 视觉中的 CNN 等 backbone 网络。论文提出这个网络需要满足 (1) 能够<strong>根据局部上下文编码几何结构</strong>；(2) 能够<strong>根据全局上下文编码点云的语义信息和它们间的语义关系</strong>；(3) 能够快速适应不同的小样本任务。因此，本文提出一种 attention-aware multi-level feature learning network 来结合局部几何特征、全局语义特征和 metric-adaptive 特征。具体来说，该网络由三部分组成：(1) feature extractor，选用动态图 CNN 架构的 <a href="http://arxiv.org/abs/1801.07829">DGCNN (ACM Trans. Graph. 2019)</a> 来得到局部几何特征（第一个 EdgeConv 层的输出）和语义特征（整个 feature extractor 的输出）；(2) attention learner，选用了 self-attention network (SAN)；(3) metric learner，选用了 MLP 的堆叠并以一个相对更大的学习率更新。</p>
<!-- embedding 具体怎么运算论文（至少在正文）也没提，需要看代码理解 -->

<p><strong>multi-prototype generation</strong>：对于 support set 中 $N+1$ 类的每一个，都通过聚类生成 $n$ 个 prototypes。具体地，$n$ 个种子点通过 farthest point sampling 被从 support 点中采样得到。直觉上来说，如果 embedding space 学得够好，这个空间中最远的那些点能够可以内在地表示一个类别的不同视角。之后，我们计算其他点和这些种子点的距离并根据最近邻原则分配，最后计算每个簇的均值作为 prototypes。</p>
<p><strong>transductive inference</strong>：该方法首先构建了一张包含 $n \times (N+1)$ 个 prototypes 和 $T \times M$ 个 query 点、总计 $V = n \times (N+1) + T \times M$ 个节点的 k-NN graph。稀疏邻接矩阵 $\mathbf{A} \in \mathbb{R}^{V \times V}$ 通过计算每个点和其 $k$ 个最近邻的高斯相似度得到。为了让邻接矩阵是非负且对称的，有 $\mathbf{W} = \mathbf{A} + \mathbf{A}^{T}$，并进一步进行正则化有 $\mathbf{S} = \mathbf{D}^{-1/2}\mathbf{W}\mathbf{D}^{-1/2}$。同时定义标签矩阵 $\mathbf{Y} \in \mathbb{R}^{V \times (N+1)}$，其中对应有标签 prototypes 的行是 one-hot ground-truth 标签，其余为零向量。给定 $\mathbf{S}$ 和 $\mathbf{Y}$，标签传播有解析解 $\mathbf{Z}^{*} = (\mathbf{I} - \alpha \mathbf{S})^{-1}\mathbf{Y}$。最后每个点云对应的预测通过 softmax 后用交叉熵计算损失。</p>
<p>数值的实验结果如下表所示。原论文还有一些 ablation study 和分割结果的可视化。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-FS-3D-point-cloud-semantic-segmentation-table.png"></p>
<!-- ### Zero-Shot Instance Segmentation

CVPR 2021 | [link](https://openaccess.thecvf.com/content/CVPR2021/html/Zheng_Zero-Shot_Instance_Segmentation_CVPR_2021_paper.html) | [github](https://github.com/zhengye1995/Zero-shot-Instance-Segmentation)

这篇论文写的有点烂...有些细节好模糊 -->



<!-- ### UniT: Unified Knowledge Transfer for Any-shot Object Detection and Segmentation

CVPR 2021 | [link](https://openaccess.thecvf.com/content/CVPR2021/html/Khandelwal_UniT_Unified_Knowledge_Transfer_for_Any-Shot_Object_Detection_and_Segmentation_CVPR_2021_paper.html) | [arxiv](http://arxiv.org/abs/2006.07502) | [github](https://github.com/ubc-vision/UniT) -->

<!-- ![](https://raw.githubusercontent.com/bighuang624/pic-repo/master/CVPR2021-unified-knowledge-transfer-for-any-shot-object-detection-and-segmentation-figure2.png) -->

<!-- CVPR2021-unified-knowledge-transfer-for-any-shot-object-detection-and-segmentation -->


<!-- ### Anti-Aliasing Semantic Reconstruction for Few-Shot Semantic Segmentation

CVPR 2021 | [link](https://openaccess.thecvf.com/content/CVPR2021/html/Liu_Anti-Aliasing_Semantic_Reconstruction_for_Few-Shot_Semantic_Segmentation_CVPR_2021_paper.html) | [github（代码不完整）](https://github.com/Bibkiller/ASR) -->

<!-- ### Scale-Aware Graph Neural Network for Few-Shot Semantic Segmentation

CVPR 2021 | [link](https://openaccess.thecvf.com/content/CVPR2021/html/Xie_Scale-Aware_Graph_Neural_Network_for_Few-Shot_Semantic_Segmentation_CVPR_2021_paper.html) | 代码未开源 -->


<!-- ### Rich Embedding Features for One-Shot Semantic Segmentation

TNNLS 2021 | [link](https://ieeexplore.ieee.org/abstract/document/9463398) | 代码未开源

方法看示意图基本就了解得十有八九了。没源码，就不细看了。 -->




<!-- ### Hypercorrelation Squeeze for Few-Shot Segmenation

ICCV 2021 | [arxiv](http://arxiv.org/abs/2104.01538) | [github](https://github.com/juhongm999/hsnet) | [知乎解读](https://zhuanlan.zhihu.com/p/452427807)

### Learning Meta-class Memory for Few-Shot Semantic Segmentation

ICCV 2021 | [pdf](https://openaccess.thecvf.com/content/ICCV2021/papers/Wu_Learning_Meta-Class_Memory_for_Few-Shot_Semantic_Segmentation_ICCV_2021_paper.pdf) | [arxiv](http://arxiv.org/abs/2108.02958) | [github](https://github.com/wu-zhonghua/MM-Net) 

### Few-Shot Semantic Segmentation with Cyclic Memory Network

ICCV 2021 | [pdf](https://openaccess.thecvf.com/content/ICCV2021/papers/Xie_Few-Shot_Semantic_Segmentation_With_Cyclic_Memory_Network_ICCV_2021_paper.pdf) | 代码未开源 -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [ ['$', '$'] ],
        displayMath: [ ['$$', '$$']]}
});
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=default"></script>]]></content>
      <categories>
        <category>论文阅读笔记</category>
      </categories>
      <tags>
        <tag>few-shot segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络复习笔记</title>
    <url>/blog/computer-network-notes/</url>
    <content><![CDATA[<h2 id="计算机网络与因特网"><a href="#计算机网络与因特网" class="headerlink" title="计算机网络与因特网"></a>计算机网络与因特网</h2><p>一个<strong>协议</strong>定义了在两个或多个通信实体之间交换报文的格式与次序，以及报文发送/接收或其他事件所采取的动作。</p>
<h3 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h3><p><strong>因特网协议栈（Internet protocol stack）</strong>自顶向下：</p>
<ol>
<li><strong>应用层</strong>：网络应用程序及应用层协议存留的地方。</li>
</ol>
<ul>
<li>常见应用层协议：HTTP、DNS、FTP、SMTP、DHCP</li>
<li>位于应用层的分组信息称为<strong>报文（message）</strong></li>
</ul>
<ol start="2">
<li><strong>运输层</strong>：负责在<strong>应用程序</strong>端点之间传送应用层报文。</li>
</ol>
<ul>
<li>常见运输层协议：TCP、UDP</li>
<li>位于应用层的分组信息称为<strong>报文段（segment）</strong></li>
</ul>
<ol start="3">
<li><strong>网络层</strong>：负责在<strong>主机</strong>间传送网络层的分组。</li>
</ol>
<ul>
<li>常见网络层协议：IP</li>
<li>位于网络层的分组信息称为<strong>数据报（datagram）</strong></li>
</ul>
<ol start="4">
<li><strong>链路层</strong>：负责将整个帧从一个网络元素移动到临近的网络元素。</li>
</ol>
<ul>
<li>链路层的例子包括以太网，WiFi</li>
<li>由于分组从源到目的地传送通常要经过几条链路，所以可能被途径不同的链路层协议处理</li>
<li>位于链路层的分组信息称为<strong>帧（frame）</strong> </li>
</ul>
<ol start="5">
<li><strong>物理层</strong>：将帧中的每个比特从一个结点移动到下一结点。</li>
</ol>
<ul>
<li>与链路的实际传输媒介相关。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/426df589-6f97-4622-b74d-4a81fcb1da8e.png"></p>
<p>ISO-OSI 模型：</p>
<ol>
<li>应用层</li>
<li>表示层：使通信的应用协议能够解释交换数据的含义，提供数据压缩、数据解密、数据描述等服务；</li>
<li>会话层：提供数据交换的定界和同步功能，包括建立检查点和恢复方案的方法；</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
<li>物理层</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/ac106e7e-489a-4082-abd9-dabebe48394c.jpg"></p>
<span id="more"></span>

<h3 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h3><p>几种因特网的接入方式：</p>
<ul>
<li>家庭接入：DSL（数字用户线，Digital Subscriber）、电缆、FTTH（光纤到户，Fiber To The Home）、拨号和卫星</li>
<li>企业（和家庭）接入：以太网和 WiFi</li>
<li>广域无线接入：3G 和 LTE</li>
</ul>
<h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p><strong>网络核心</strong>：由连接因特网端系统的<strong>分组交换机和链路</strong>构成的网络。</p>
<p>通过网络链路和交换机<strong>移动数据</strong>的两种基本方法：</p>
<ol>
<li><strong>分组交换（packet switching）</strong></li>
<li><strong>电路交换（circuit switching）</strong></li>
</ol>
<h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>将长报文分成较小的数据块（称为分组），在源和目的地之间，每个分组都通过通信链路和<strong>分组交换机（packet switch）</strong>传送。</p>
<p>分组交换机主要有两类：</p>
<ul>
<li><strong>路由器（router）</strong>：常用于网络核心中，网络中大于几千台主机时使用<ul>
<li>使用<strong>网络层</strong>地址转发分组，是第三层的分组交换机；</li>
<li>优点：分组不会通过路由器循环；防火墙保护</li>
<li>缺点：不是即插即用的；对每个分组处理时间更长</li>
</ul>
</li>
<li><strong>链路层交换机（link-layer switch）</strong>：常用于接入网中，网络中小于几百台主机时使用<ul>
<li>使用 <strong>MAC</strong> 地址转发分组，是第二层的分组交换机；</li>
<li>优点：即插即用；相对高的分组过滤和转发速率</li>
<li>缺点：大型交换网络生成可观的 ARP 流量和处理量；对广播风暴不提供任何保护措施</li>
</ul>
</li>
</ul>
<p><strong>存储转发传输（store-and-forward transmission）</strong>：两种分组交换机能够开始向输出链路传输该分组的第一个比特之前，都必须接收到整个分组。因此存在一定的存储转发时延。设分组为 L 比特，链路传输速率为 R 比特/秒，则每条链路的存储转发时延为 L/R 秒。</p>
<h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>每台主机都与一台交换机直连，当两台主机通信时，该网络在两台主机之间创建一条专用的<strong>端到端连接（end-to-end connection，又称电路）</strong>。</p>
<p>端系统通信会话期间需要预留资源（缓存，链路传输速率）。端到端连接的实现方式包括频分复用和时分复用。</p>
<h4 id="分组交换与电路交换的对比"><a href="#分组交换与电路交换的对比" class="headerlink" title="分组交换与电路交换的对比"></a>分组交换与电路交换的对比</h4><ul>
<li>电路交换不考虑需求，而预先分配了传输链路的使用，使得已分配而并不需要的链路时间未被使用，对线路的利用率很低；</li>
<li>分组交换按需分配链路使用。</li>
</ul>
<p>趋势朝着分组交换方向发展。</p>
<h3 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h3><p><strong>结点总时延 = 处理时延 + 排队时延 + 传输时延 + 传播时延</strong></p>
<ul>
<li><strong>节点处理时延（nodal processing delay）</strong>：检查分组首部和决定该分组导向何处所需时间（可能包括检查比特级差错）；</li>
<li><strong>排队时延（queuing delay）</strong>：分组在队列中等待传输的时间；</li>
<li><strong>传输时延（transmission delay）</strong>：路由器将分组推出所需时间；</li>
<li><strong>传播时延（propagation delay）</strong>：分组从一台路由器向另一台路由器传播所需时间。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/3939369b-3a4a-48a0-b9eb-3efae26dd400.png"></p>
<ul>
<li><p>丢包（packet lost）：当排队队列满时，由于没有地方进行缓存，路由器将丢弃该分组。丢弃的分组可能重传，也可能不传。</p>
</li>
<li><p>吞吐量（throughput）：</p>
<ul>
<li>瞬时吞吐量（instantaneous throughput）：主机接受文件的速率（bps）</li>
<li>平均吞吐量（average throughput）：主机在某个时间区间接受文件的平均速率（bps）</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="非重点知识"><a href="#非重点知识" class="headerlink" title="非重点知识"></a>非重点知识</h3><p>因特网为应用程序提供了两个<em>运输层</em>协议：</p>
<ul>
<li>TCP：面向连接、可靠数据传输、有拥塞控制机制；</li>
<li>UDP：不提供不必要服务、无连接、不可靠、没有拥塞控制机制。</li>
</ul>
<p>套接字（Socket）：同一台主机内应用层与运输层之间的接口。也称为应用程序编程接口（API）。</p>
<p>往返时间（Round-Trip Time，RTT）：一个短分组从客户到服务器然后再返回客户所花费的时间。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>HTTP（超文本传输协议，HyperText Transfer Protocol）</strong>：</p>
<ul>
<li>定义了 Web 客户端向 Web 服务器请求 Web 页面的方式；</li>
<li>使用 TCP 作为支撑运输层协议 =&gt; 连接建立后可以通过套接字访问</li>
<li>无状态协议（stateless protocol）：不保存关于客户机的任何信息</li>
</ul>
<p>HTTP 默认使用持久连接，但 HTTP 客户和服务器也能配置成使用非持久连接。</p>
<ul>
<li><strong>非持久连接（non-persisitent connection）</strong>：当客户机/服务器交互运行于 TCP 协议上时，每个请求/响应对是经<strong>一个单独的</strong> TCP 连接发送；</li>
<li><strong>持久连接（persistent connection）</strong>：当客户机/服务器交互运行于 TCP 协议上时，所有请求/响应对是经<strong>相同的</strong> TCP 连接发送。</li>
</ul>
<h4 id="HTTP-1-0-vs-HTTP-1-1"><a href="#HTTP-1-0-vs-HTTP-1-1" class="headerlink" title="HTTP 1.0 vs HTTP 1.1"></a>HTTP 1.0 vs HTTP 1.1</h4><ul>
<li><strong>请求方法的增加</strong>：HTTP 1.0 只有 GET、POST、HEAD 三个请求方法；HTTP 1.1 新增了 PUT、DELETE、OPTIONS、CONNECT、TRACE。</li>
<li><strong>HTTP 1.0 使用非持久连接</strong>，需要为每一个请求的对象建立和维护一个连接，<strong>给 Web 服务器造成较大负担，且有额外时延</strong>；<strong>HTTP 1.1 使用持久连接</strong>，通过请求头中的“Connection: Keep-Alive”实现。</li>
<li>HTTP 1.1 还有一些性能改善措施，例如支持请求流水线，100（Continue）响应码，Host 请求头字段等。</li>
</ul>
<!--##### 报文格式

略-->

<h4 id="HTTP-请求页面过程"><a href="#HTTP-请求页面过程" class="headerlink" title="HTTP 请求页面过程"></a>HTTP 请求页面过程</h4><ol>
<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>
<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ol>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie 技术的四个组件：</p>
<ol>
<li>在 HTTP 响应报文中的一个 cookie 首部行；</li>
<li>在 HTTP 请求报文中的一个 cookie 首部行；</li>
<li>用户浏览器管理的 cookie 文件；</li>
<li>位于 Web 站点的一个后端数据库。</li>
</ol>
<h4 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h4><p>Web 缓存器/代理服务器：代表初始 Web 服务器来满足 HTTP 请求的网络实体。</p>
<p>优点：</p>
<ul>
<li>减少对客户请求的响应时间；</li>
<li>减少一个机构的接入链路到因特网的通信量。</li>
</ul>
<p>条件 GET：</p>
<ul>
<li>目的：防止缓存器中的对象副本不是最新；</li>
<li>判别方法：请求报文使用 GET 方法，且包含一个“If-Modified-Since:”首部行。</li>
</ul>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p><strong>FTP（文件传输协议，File Transfer Protocol）</strong>：客户端通过 FTP 向一台远程主机上传文件或从远程主机下载文件。</p>
<p>FTP 和 HTTP 比较：</p>
<ul>
<li>相同点：都是文件传输协议，都运行在 TCP 上；</li>
<li>不同点：<ol>
<li>FTP 是<strong>带外传送的（out-of-band）</strong>，它使用两个并行 TCP 连接来传输文件，一个是<strong>控制连接（control connection）</strong>，一个是<strong>数据连接（data connection）</strong>；HTTP 是<strong>带内的（in-band）</strong>，在同一个连接中发送请求和响应首部行。</li>
<li>FTP 服务器必须在整个会话间保存用户状态信息，而 HTTP 不保存客户机的任何信息。 </li>
</ol>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><strong>DNS（域名系统，Domain Name System）</strong>：主要任务是负责将用户提供主机名解析为 IP 地址。其他提供的服务有：</p>
<ul>
<li>主机别名（host aliasing）；</li>
<li>邮件服务器别名（mail server aliasing）；</li>
<li>负载分配（load distribution）。</li>
</ul>
<p>DNS 通常由其他应用层协议使用，包括 HTTP、SMTP 和 FTP。DNS 运行在 UDP 上，使用 53 号端口。</p>
<p>DNS <strong>解释域名过程</strong>的简单描述：</p>
<ol>
<li>应用程序调用 DNS 客户端，并指明需要被转换的主机名；</li>
<li>用户主机上的 DNS 向网络中发送一个 DNS 查询报文；</li>
<li>经过若干毫秒到若干秒的时延后，用户主机上的 DNS 接收到一个提供所希望映射的 DNS 报文，并传递到调用 DNS 的应用程序。</li>
</ol>
<p>DNS 既是一个允许主机查询分布式数据库的应用层协议，也是一个由分层的 DNS 服务器实现的分布式数据库。DNS 的层次结构包含根 DNS 服务器，顶级域（TLD）DNS 服务器，权威 DNS 服务器。DNS 不适用于集中式设计的原因包括：</p>
<ol>
<li>单点故障：如果 DNS 服务器崩溃，整个因特网随之瘫痪；</li>
<li>通信容量：整个 DNS 服务器不得不处理所有的 DNS 查询；</li>
<li>远距离的集中式数据库：距离 DNS 服务器远的主机的查询将产生严重的延迟；</li>
<li>维护：集中式的数据库非常庞大，难以维护。</li>
</ol>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p><strong>SMTP（简单邮件传输协议，Simple Mail Transfer Protocol）</strong>是因特网电子邮件应用的核心，用于从发送方的邮件服务器发送报文到接收方的邮件服务器。</p>
<p>SMTP 和 HTTP 比较：</p>
<ul>
<li>相同点：都用于从一台主机向另一台主机传送文件，都使用持续连接；</li>
<li>不同点：<ol>
<li>SMTP 是一个<strong>推协议（push protocol）</strong>，即发送邮件服务器把文件推向接收邮件服务器；而 HTTP 是一个<strong>拉协议（pull protocol）</strong>。</li>
<li>SMTP 要求每个报文使用 7-bit ASCII 码格式，HTTP 数据则不受这种限制。</li>
<li>处理既有文本又有图像的文档时，SMTP 把所有报文对象放在一个报文之中，而 HTTP 把每个对象封装到独立的响应报文中。</li>
</ol>
</li>
</ul>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p><strong>DHCP（动态主机配置协议，Dynamic Host Configuration Protocol）</strong>提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。</p>
<p>工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层协议：</p>
<ul>
<li>为运行在不同主机上的应用进程之间提供了逻辑通信；</li>
<li>在端系统中实现（而非路由器）；</li>
<li>UDP 和 TCP 最基本的责任是，将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。TCP 还附加提供可靠数据传输、拥塞控制等服务。</li>
</ul>
<h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h3><p><strong>多路分解（demultiplexing）</strong>：将运输层报文段中的数据交付到正确的套接字的工作。</p>
<p><strong>多路复用（multiplexing）</strong>：从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作。</p>
<p>UDP 套接字：由包含目的 IP 地址和目的端口号的二元组标识。</p>
<p>TCP 套接字：由包含源 IP 地址、源端口号、目的 IP 地址、目的端口号的四元组标识。</p>
<p>对于两个具有相同目的 IP 地址和目的端口号，但具有不同源 IP 地址或源端口号的报文段，UDP 报文段将通过<strong>相同的目的套接字</strong>被定向到<strong>相同的目的进程</strong>；TCP 报文段将被定向到两个<strong>不同的</strong>套接字。</p>
<h3 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h3><p>特点：</p>
<ul>
<li>尽力而为：报文段可能无序到达或丢失；</li>
<li>无连接：发送报文段前没有握手。</li>
</ul>
<p>选择使用 UDP 构建应用的原因：</p>
<ol>
<li>应用层能更好地控制要发送的数据和发送时间（相对的，TCP 有一个拥塞控制机制）；</li>
<li>无需连接建立（不会引入建立连接的时延）；</li>
<li>无连接状态：不用维护连接状态或跟踪参数，可以支持更多活跃客户；</li>
<li>分组首部开销小：TCP 报文段有 20 字节的首部开销，而 UDP 只有 8 字节。</li>
</ol>
<h4 id="UDP-差错检测——检验和"><a href="#UDP-差错检测——检验和" class="headerlink" title="UDP 差错检测——检验和"></a>UDP 差错检测——检验和</h4><p><strong>UDP 检验和（checksum）</strong>提供<strong>差错检测</strong>功能，以检测报文段运输时的比特改变，但不提供差错恢复。</p>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/checksum.png" alt="checksum.png"></p>
<p>发送方：</p>
<ol>
<li>对报文段中 3 个 16 比特字求和；</li>
<li>求和遇到的溢出被回卷（左边溢出的 1 加到最右边）；</li>
<li>对和进行反码运算，结果放在检验和字段。</li>
</ol>
<p>接收方：全部的 4 个 16 比特字（包括检验和）加在一起，若没有差错，接收方处该和将是 1111 1111 1111 1111。</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>可靠数据传输的实现在运输层、链路层以及应用层。</p>
<p><strong>可靠数据传输协议（reliable data transfer protocol）</strong>的演变思路：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5265289-0b392823b3635f5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>为了解决发送方利用率极低的问题，停等操作 =&gt; 流水线操作（允许发送方发送多个分组而无需等待确认）。解决<strong>流水线操作的差错恢复</strong>的两种方法：<strong>回退 N 步（Go-Back-N，GBN）</strong>、<strong>选择性重传（Selective Repeat，SR）</strong>。</p>
<h4 id="回退-N-步协议（GBN）"><a href="#回退-N-步协议（GBN）" class="headerlink" title="回退 N 步协议（GBN）"></a>回退 N 步协议（GBN）</h4><p>允许发送方发送多个分组，但流水线中未确认的分组数不能超过某个最大允许数 N。</p>
<p>GBN 协议也被称为滑动窗口协议（sliding-window protocol），N 被称为窗口长度。</p>
<p><strong>GBN 发送方</strong>必须响应三种类型的事件：</p>
<ul>
<li>上层的调用</li>
<li>收到一个 ACK：累计确认，表明正确接收到序号 n 及之前的分组</li>
<li>超时事件：出现超时，发送方重传所有已发送但还未被确认过的分组</li>
</ul>
<p><strong>GBN 接收方</strong>：</p>
<ul>
<li>正确、按序接收到分组 n，则为其发送一个 ACK；否则丢弃该分组，并为最近按序接收的分组重新发送 ACK。</li>
<li>丢弃所有失序分组。</li>
</ul>
<p><strong>优点</strong>：不需要缓存任何失序分组。</p>
<p><strong>缺点</strong>：对该分组的重传也许会丢失或出错，甚至因此需要更多重传。</p>
<h4 id="选择性重传协议（SR）"><a href="#选择性重传协议（SR）" class="headerlink" title="选择性重传协议（SR）"></a>选择性重传协议（SR）</h4><p>通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组，来避免不必要的重传。</p>
<p><strong>SR 接收方</strong>：确认一个正确接收的分组而不管是否按序。<strong>失序的分组将被缓存</strong>，直到所有序号更小的分组都被收到为止，这时将一批分组按序交付给上层。</p>
<p>困境：序号范围有限时，接收方可能因窗口太大而无法分辨是一个新分组还是一次重传。 =&gt; 窗口大小须小于等于序号空间大小的一半。</p>
<h3 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h3><h4 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h4><ul>
<li>全双工服务：TCP 连接是双向的</li>
<li><strong>最大报文段长度（MSS，Maximum Segment Size）</strong>：运输层概念，指 TCP 可从缓存中取出并放入报文段中的数据量，通常根据最初确定的由本地发送主机发送的<strong>最大链路层帧长度（即最大传输单元，MTU）</strong>来设置。</li>
</ul>
<h5 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构"></a>报文段结构</h5><p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png"></p>
<ul>
<li><strong>序号</strong>：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li><strong>确认号</strong>：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li>
<li><strong>确认 ACK</strong>：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>
<li><strong>同步 SYN</strong>：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li>
<li><strong>终止 FIN</strong>：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong>：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
</ul>
<!--#### 往返时延估计与超时

略-->

<h4 id="可靠数据传输-1"><a href="#可靠数据传输-1" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><p>TCP 在 IP 不可靠的尽力而为服务之上创建了一种<strong>可靠数据传输服务</strong>，确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余和按序的数据流。</p>
<p>TCP 发送方 3 个与发送和重传有关的主要事件：</p>
<ol>
<li>从上层应用接收数据；</li>
<li>定时器超时；</li>
<li>收到 ACK 报文。</li>
</ol>
<p><strong>快速重传!<strong>：TCP 使用</strong>冗余 ACK</strong>（再次确认某个报文段的 ACK），而非否定确认。一旦收到 3 个冗余 ACK，TCP 就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。</p>
<p>TCP 的差错恢复机制是 GBN 协议和 SR 协议的混合体。</p>
<h4 id="流量控制（flow-control）"><a href="#流量控制（flow-control）" class="headerlink" title="流量控制（flow control）"></a>流量控制（flow control）</h4><p>TCP 流量控制的<strong>目的</strong>：消除<strong>接收方</strong>缓存溢出的可能性。</p>
<p>TCP 流量控制的<strong>实现</strong>：发送方维护一个称为<strong>接收窗口（receive window）</strong>的变量，通过发给发送方报文段的接收窗口字段，通知发送方该接收方还有多少可用的缓存空间。</p>
<h4 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png"></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p>原因：第三次握手是为了防止失效的连接请求到达服务器，导致服务器错误打开连接。</p>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg"></p>
<ul>
<li>A 发送连接释放报文段，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放请求报文段，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL 时间后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p>原因：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<h4 id="拥塞控制（congestion-control）"><a href="#拥塞控制（congestion-control）" class="headerlink" title="拥塞控制（congestion control）"></a>拥塞控制（congestion control）</h4><p>TCP 拥塞控制的<strong>目的</strong>：消除<strong>路由器</strong>缓存溢出导致的丢包和重传，以及缓存队列造成的排队时延。</p>
<p>流量控制为了让接收方来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<h5 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h5><p>根据<strong>网络层是否为运输层拥塞控制提供了显式帮助</strong>，区分两种拥塞控制方法：</p>
<ul>
<li><strong>端到端拥塞控制</strong>：没有显式支持，通过对网络行为观察来推断是否拥塞（TCP 采用）；</li>
<li><strong>网络辅助的拥塞控制</strong>：网络层构件（路由器）向发送方提供反馈信息。拥塞信息可以通过<strong>专门的阻塞分组</strong>或者<strong>分组中的字段</strong>从网络反馈到发送方。</li>
</ul>
<h5 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h5><p>TCP 让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。</p>
<p>问题：</p>
<ol>
<li>如何限制发送流量速率？答：发送方维护变量<strong>拥塞窗口（cwnd）</strong>，LastByteSent - LastByteAcked &lt;= min{cwnd, rwnd}。通过调节 cwnd 的值，发送方能调整它向连接发送数据的速率；</li>
<li>如何感知拥塞？答：超时或收到 3 个冗余 ACK；</li>
<li>感知到拥塞时，采用何种算法去改变发送速率？答：(1) 一个丢包意味着拥塞，因此降低发送方速率；(2) 当对先前未确认报文段的确认到达时，能够增加发送方的速率；(3) <strong>带宽探测</strong>：增加速率以响应到达的 ACK，除非出现丢包，此时才减小传输速率。</li>
</ol>
<p><strong>TCP 拥塞控制算法（TCP congestion control algorithm）</strong>包括三个主要部分：</p>
<ol>
<li><strong>慢启动</strong>（强制）<!--：开始时 cwnd=1 MSS，发送方只能发送一个报文。收到确认后，cwnd 和发送速率就翻番。设置一个阈值 **ssthresh**，cwnd >= ssthresh 时，进入**拥塞避免**。若出现**超时**，则令 ssthresh = cwnd/2，然后重新执行**慢启动**-->；</li>
<li><strong>拥塞避免</strong>（强制）<!--：进入此状态时，cwnd /= 2。每次收到确认只将 cwnd 的值增加 1 MSS-->；</li>
<li><strong>快速恢复</strong>（推荐）<!--：对于引起进入快速恢复状态的缺失报文段，对收到的每个冗余 ACK，cwnd += 1 MSS。最终，当丢失报文段的一个 ACK 到达时，TCP 进入**拥塞避免**。若出现**超时**，则令 ssthresh = cwnd/2，然后执行慢启动。若出现**丢包**-->；</li>
</ol>
<p><img src="https://raw.githubusercontent.com/bighuang624/pic-repo/master/TCP-congestion-control-algorithm.jpg"></p>
<p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/910f613f-514f-4534-87dd-9b4699d59d31.png"></p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层的作用是将在主机间传送分组，因此需要两种重要的网络层功能：</p>
<ul>
<li><strong>转发（forwarding）</strong>：当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适当的输出链路；</li>
<li><strong>路由选择（routing）</strong>：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。</li>
</ul>
<p>因特网的网络层提供<strong>尽力而为服务（best-effort service）</strong>，有三个主要组件：</p>
<ul>
<li>IP 协议</li>
<li>路由选择协议</li>
<li>ICMP 协议（互联网控制报文协议）：用于主机和路由器沟通网络层的信息。最典型的用途是差错报告。</li>
</ul>
<h3 id="虚电路与数据报网络"><a href="#虚电路与数据报网络" class="headerlink" title="虚电路与数据报网络"></a>虚电路与数据报网络</h3><ul>
<li><strong>虚电路（Virtual-Circuit，VC）网络</strong>：仅在网络层提供<strong>连接</strong>服务的计算机网络。由路由器维持连接状态信息。</li>
<li><strong>数据报网络</strong>：仅在网络层提供<strong>无连接</strong>服务的计算机网络。每当一个端系统要发送分组，它就为该分组加上目的端系统的地址，然后将分组推进网络中。</li>
</ul>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul>
<li>主要作用：将数据报从入链路转发到出链路；</li>
<li>路由器具有截断的协议栈，即没有网络层以上的部分；</li>
<li>每台路由器具有一张<strong>转发表（forwarding table）</strong>，指示分组对应的输出端口；</li>
<li>路由器的四个<strong>组成部分</strong>：输入端口 + 交换结构 + 输出端口 + 路由选择处理器；</li>
<li>每个输入端口存放一份转发表副本的原因：转发决策能在每个输入端口本地做出，无须调用中央路由选择处理器，因此避免了集中式处理的瓶颈。</li>
</ul>
<h3 id="IPv4-vs-IPv6"><a href="#IPv4-vs-IPv6" class="headerlink" title="IPv4 vs IPv6"></a>IPv4 vs IPv6</h3><h4 id="IPv4-数据报格式"><a href="#IPv4-数据报格式" class="headerlink" title="IPv4 数据报格式"></a>IPv4 数据报格式</h4><p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg"></p>
<ul>
<li><strong>版本</strong>：有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong>：占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong>：用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong>：包括首部长度和数据部分长度。</li>
<li><strong>标识</strong>：在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>标志</strong>：发生分片时，最后一个片此位设为 0，其他所有片此位设为 1。</li>
<li><strong>片偏移</strong>：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png"></p>
<ul>
<li><strong>生存时间</strong>：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong>：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong>：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>源和目的 IP 地址</strong>。</li>
<li><strong>选项</strong>：允许 IP 首部被扩展。因为复杂，在 IPv6 首部已去掉。</li>
</ul>
<h4 id="IPv4-编址"><a href="#IPv4-编址" class="headerlink" title="IPv4 编址"></a>IPv4 编址</h4><p><strong>接口（interface）</strong>：主机和物理链路之间的边界。一个 IP 地址技术上是与一个接口相关联的。</p>
<p><strong>子网（subnet）</strong>：分开主机和路由器的每个接口，产生几个隔离的网络岛，这些<strong>子网</strong>使用接口连接。</p>
<p>IP 编址为子网分配一个地址：223.1.1.0/24，其中的 /24 记法称为<strong>子网掩码（network mask）</strong>，指示了 32 比特中的最左侧 24 比特定义了子网地址。</p>
<p><strong>因特网的地址分配策略</strong>是<strong>无类别域间路由选择（Classless Interdomain Routing, CIDR）</strong>，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p><strong>动态主机配置协议（Dynamic Host Configuration Protocol, DHCP）</strong>，又被称为即插即用协议（plug-and-play protocol）。利用 DHCP，主机可以<strong>自动获取 IP 地址</strong>。除了为主机分配地址外，DHCP 还允许一台主机获取其他信息，如它的子网掩码，默认网关，本地 DNS 服务器地址等。DHCP 协议的 4 个步骤：</p>
<ol>
<li>DHCP 服务器发现</li>
<li>DHCP 服务器提供</li>
<li>DHCP 请求</li>
<li>DHCP ACK</li>
</ol>
<!--网络地址转换（Network Address Translation, NAT）

UPnP（通用即插即用）：允许主机发现并配置临近 NAT 协议-->

<!--寻址（大氛围 -> 小范围 -> 节点）*-->

<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6 引入的变化：</p>
<ul>
<li><strong>扩大的地址容量</strong>：IP 地址长度从 32 比特增加到 128 比特；</li>
<li><strong>简化高效的 40 字节定长首部</strong>；</li>
<li><strong>流标签与优先级</strong>。</li>
</ul>
<p>IPv6 中不包含的 IPv4 字段：</p>
<ul>
<li>分片/重新组装：IPv6 不允许在中间路由器上进行分片与重新组装，只能在源与目的地上执行；</li>
<li>首部检验和：运输层和链路层协议已执行了检验操作；</li>
<li>选项。</li>
</ul>
<p>从 IPv4 到 IPv6 的迁移：</p>
<ul>
<li>双栈（dual-stack）：使用该方法的 IPv6 结点还具有完整的 IPv4 实现；</li>
<li>建隧道（tunneling）：将两台 IPv6 路由器之间的中间 IPv4 路由器集合称为一个隧道。借助于隧道，在隧道发送端的 IPv6 结点可将整个 IPv6 数据报放到一个 IPv4 数据报的有效载荷字段中。</li>
</ul>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><ul>
<li>目的：给定一组路由器以及连接路由器的链路，找到一条源路由器到目的路由器的好路径。</li>
<li>分类方式：<ul>
<li>全局式 vs 分散式：全局式要求以所有结点之间的连通性及所有链路费用为输入，而分散式中每个结点仅有与之相连链路的费用知识；</li>
<li>静态 vs 动态：动态算法对网络变化有较大反应；</li>
<li>负载敏感 vs 负载迟钝：负载敏感算法中链路费用动态变化以反映底层链路的当前拥塞水平。当今的因特网路由选择协议（RIP、OSPF 和 BGP）都是负载迟钝的。</li>
</ul>
</li>
</ul>
<h4 id="链路状态路由选择算法（LS）"><a href="#链路状态路由选择算法（LS）" class="headerlink" title="链路状态路由选择算法（LS）"></a>链路状态路由选择算法（LS）</h4><ul>
<li>迭代、全局式</li>
<li>根据 <strong>Dijkstra</strong> 算法实现</li>
<li>最差情况 O(n^2)，用堆可控制在 O(nlogn)</li>
<li>可能的问题：振荡 =&gt; 解决方案：并非所有路由器都同时运行 LS 算法</li>
</ul>
<h4 id="距离向量路由选择算法（DV）"><a href="#距离向量路由选择算法（DV）" class="headerlink" title="距离向量路由选择算法（DV）"></a>距离向量路由选择算法（DV）</h4><ul>
<li>迭代、异步、分布式</li>
<li>根据 <strong>Bellman-Ford</strong> 方程实现</li>
<li>对于结点 x：<ul>
<li>知道 x 到直接相连邻居 v 的费用</li>
<li>保存每个邻居的距离向量 Dv = [Dv(y); y 为每个结点]</li>
<li>保存结点 x 自己的距离向量 Dx = [Dx(y); y 为每个结点]</li>
</ul>
</li>
<li><strong>迭代</strong>：每个结点等待来自任何邻居的更新，当接收到一个更新时计算它的新距离向量，并向它的邻居发布其新距离向量（最终会收敛）</li>
<li>问题：当某链路费用增加时，可能发生<strong>无穷计数</strong>问题 =&gt; <strong>毒性逆转（poisoned reverse）</strong>技术：如果 z 通过 y 路由选择到目的地 x，则 z 将告诉 y Dz(x) 无穷大</li>
</ul>
<h4 id="层次路由选择"><a href="#层次路由选择" class="headerlink" title="层次路由选择"></a>层次路由选择</h4><p>前两种算法将网络只看作一个互联路由器的集合，忽视了规模带来的复杂度和管理自治的需要。由此引入<strong>自治系统（Autonomous System, AS）</strong>：</p>
<ul>
<li>由一组通常处于相同管理控制下的路由器组成</li>
<li>在同一 AS 中的路由器运行同样的路由选择算法，且拥有彼此的信息</li>
<li>为了互联 AS，每个 AS 内有一台或多台<strong>网关路由器（gateway router）</strong>，负责向在本 AS 之外的目的地转发分组</li>
</ul>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议!"></a>路由选择协议!</h3><p>互联网使用的路由选择协议都是<strong>自适应</strong>的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li><strong>AS 内部</strong>路由选择协议：RIP（路由选择信息协议）、OSPF（开放最短路优先）</li>
<li><strong>AS 间</strong>路由选择协议：BGP（边界网关协议）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CyC2018/Interview-Notebook/master/pics/276c31df-3b28-4ac2-b006-1e80fc86a64f.jpg"></p>
<h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><p><strong>RIP（路由选择信息协议）</strong>是一种分布式的基于<strong>距离向量（DV）</strong>的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本 AS 中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>算法过程：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li>
<li>若原来的<strong>路由选择表</strong>中没有目的网络 N，则把该项目添加到路由选择表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由选择表中的项目；否则：若收到的项目中的距离 d 小于路由选择表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>优点：实现简单，开销小</p>
<p>缺点：能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p><strong>OSPF（开放最短路优先）</strong>路由选择协议基于<strong>链路状态（LS）</strong>。路由器向本 AS 内所有路由器广播信息（洪泛法），信息包括与哪些相邻路由器相连以及链路的度量。当链路状态发生变化或者周期到达时，路由器才会发送信息。</p>
<p>优点：</p>
<ul>
<li>更新收敛快</li>
<li>安全</li>
<li>允许使用多条相同费用的路径</li>
<li>对单播与多播路由选择的综合支持</li>
<li>支持在单个路由选择域内的层次结构</li>
</ul>
<h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>AS 之间的路由选择很困难，主要是因为互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</p>
<p><strong>BGP（边界网关协议）</strong>只能寻找一条比较好的路由，而不是最佳路由。它的手段如下：</p>
<ol>
<li>从相邻 AS 处获得子网可达性信息；</li>
<li>向本 AS 内部的所有路由器传播这些可达性信息；</li>
<li>基于可达性信息和 AS 策略，决定到达子网的好路由。</li>
</ol>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><p>两种不同类型的链路层信道：</p>
<ul>
<li><strong>点对点链路（point-to-point link）</strong>：由链路一端的单个发送方和链路另一端的单个接收方组成；</li>
<li><strong>广播链路（broadcast link）</strong>：多个发送和接收结点都连接到相同的、单一的、共享的广播信道上。</li>
</ul>
<p>链路层提供的服务：</p>
<ul>
<li><strong>成帧（framing）</strong>：将数据报封装成链路层帧；</li>
<li><strong>链路接入（link access）</strong>：媒介访问控制（Medium Access Control，MAC）协议用于协调多个结点的帧传输；</li>
<li><strong>可靠交付（reliable delivery）</strong></li>
<li><strong>差错检测和纠正（error detection and correction）</strong></li>
</ul>
<h3 id="差错检测与纠正技术"><a href="#差错检测与纠正技术" class="headerlink" title="差错检测与纠正技术"></a>差错检测与纠正技术</h3><p>3 种技术：</p>
<ul>
<li><p><strong>奇偶校验（Parity Checking）</strong>：用于描述差错检测与纠正的基本思想。单个奇偶校验位原理是附加一个校验 bit，使其和数据 bit 中总有偶数个 1。因为无法处理偶数个 bit 差错的情况，因此可以使用二维奇偶校验，根据行和列来识别实际发生差错的 bit 并纠正。</p>
</li>
<li><p><strong>检验和方法（Checksum）</strong>：常用于运输层。因特网检验和是数据的 3 个 16 bit 字求得的和的反码。接收方对接收的数据（包括检验和）的和取反码，检测其是否全部为 1。</p>
</li>
<li><p><strong>循环冗余检测（Cyclic Redundancy Check，CRC）</strong>：常用于适配器中的链路层。</p>
<ol>
<li>发送方和接收方首先必须协商一个 r+1 比特模式，称为<strong>生成多项式（generator）</strong>G（最高位为 1）；</li>
<li>对于 d 比特数据段 D，发送方附加 r 比特 R；</li>
<li>d+r 比特用模 2 算数恰好能被 G 整除。</li>
</ol>
</li>
</ul>
<p>接收方检测和纠正错误的能力被称为<strong>前向纠错（Forward Error Correction，FEC）</strong>。</p>
<h3 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h3><p>广播链路的<strong>多路访问问题（multiple access problem）</strong>：如何协调多个发送和接收结点对一个共享广播信道的访问。 =&gt; <strong>多路访问协议</strong></p>
<p><strong>碰撞（collide）</strong>：结点同时接收到多个帧。碰撞帧的信号纠缠在一起，以至于涉及这次碰撞的所有帧都丢失了。</p>
<p>任何多路访问协议能被划分为 3 种类型之一：</p>
<ul>
<li><strong>信道划分协议（channel partitioning protocol）</strong><ul>
<li>时分多路复用（TDM）：优点是消除了碰撞且公平；缺点是限速，且需等待轮次。</li>
<li>频分多路复用（FDM）：优缺点同上。</li>
<li>码分多址（CDMA）：每个结点使用被分配的唯一编码来对它发送的数据进行编码。不同的结点能够同时传输，并且抗干扰。</li>
</ul>
</li>
<li><strong>随机接入协议（random access protocol）</strong>：有碰撞时，涉及碰撞的每个结点反复重发（重发前等待一个随机时延）<ul>
<li>时隙 ALOHA：时间被划分为时隙（传输一帧的时间）。结点只在时隙起点开始传输帧。如果有碰撞，该结点在时隙结束前检测到这次碰撞，并以概率 p 在后续的每个时隙中重传直到无碰撞传输。</li>
<li>纯 ALOHA：非时隙，完全分散</li>
<li>载波侦听多路访问（CSMA）</li>
<li><strong>具有碰撞检测的载波侦听多路访问（CSMA/CD）</strong></li>
</ul>
</li>
<li><strong>轮流协议（taking-turns protocol）</strong><ul>
<li><strong>轮询协议（polling protocol）</strong>：结点之一被指定为主结点，以循环的方式轮询每个结点，告诉其能传输的帧。高效，但引入了轮询时延，且主结点不够健壮。</li>
<li><strong>令牌传递协议（token-passing protocol）</strong>：固定次序传递令牌（一个小的特殊帧），收到令牌的结点仅当有帧要发送时持有令牌，否则转发。没有主结点，缺点是一个结点的故障使整个信道崩溃，并且有结点忘记释放时需要调用恢复步骤。</li>
</ul>
</li>
</ul>
<p><strong>载波侦听（carrier sensing）</strong>：一个结点在传输前先听信道，如果信道上有其他帧则等待。</p>
<p><strong>碰撞检测（collision detection）</strong>：一个传输结点在传输时一直在侦听此信道，如果检测到另一个结点正在传输干扰帧，则停止传输，随机等待一段时间。</p>
<h3 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h3><h4 id="链路层编址"><a href="#链路层编址" class="headerlink" title="链路层编址"></a>链路层编址</h4><p><strong>MAC 地址</strong>是节点（主机或路由器）的适配器具有的链路层地址，长度为 6 字节，具有扁平结构。</p>
<p><strong>地址解析协议（ARP，Address Resolution Protocol）</strong>将 IP 地址转换为 MAC 地址。ARP 可看作跨越链路层和网络层两边的协议，并且是即插即用的，无需系统管理员配置。</p>
<p>发送方用 ARP 解析并在子网之内发送的工作流程：</p>
<ol>
<li>构造 ARP 分组，包括发送、接收 IP 地址和自己的 MAC 地址；</li>
<li>让适配器在链路层帧中封装 ARP 分组，在子网中广播；</li>
<li>每个适配器把帧中的 ARP 分组传递给 ARP 模块进行比对；</li>
<li>匹配的节点给查询主机发送响应 ARP 分组；</li>
<li>查询主机更新 ARP 表。</li>
</ol>
<h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h4><ul>
<li>以太网是目前为止最流行的<strong>有线局域网</strong>。</li>
<li>以太网技术向网络层提供无连接、不可靠服务。</li>
<li>CSMA/CD：以太网的多路访问协议</li>
</ul>
<h4 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h4><ul>
<li>交换机的任务：接收入链路层帧并将它们转发到出链路</li>
<li>交换机的功能：<ul>
<li><strong>过滤（filtering）</strong>：决定一个帧应该转发到某个接口还是被丢弃</li>
<li><strong>转发（forwarding）</strong>：决定一个帧应该被导向哪个接口</li>
</ul>
</li>
<li>交换机的功能通过<strong>交换机表（switch table）</strong>完成：<ul>
<li>表项包含一个 MAC 地址，通向该 MAC 地址的交换机接口和表项放置在表中的时间（非过期时间）；</li>
<li>如果没有对于目的地址的表项，交换机广播该帧；</li>
<li>交换机表动态、自治建立，这是通过<strong>自学习（self-learning）</strong>实现。</li>
</ul>
</li>
<li><strong>自学习（self-learning）</strong>：对于在每个接口接收到的每个<strong>入帧</strong>，存储：<ol>
<li>该帧<strong>源地址</strong>字段中的 MAC 地址；</li>
<li>该帧到达的接口；</li>
<li>当前时间。</li>
</ol>
</li>
</ul>
<h4 id="VLAN（虚拟局域网）"><a href="#VLAN（虚拟局域网）" class="headerlink" title="VLAN（虚拟局域网）"></a>VLAN（虚拟局域网）</h4><p><strong>VLAN（虚拟局域网，Virtual Local Network）</strong>：端口被网络管理员划分为组，每组构成一个 VLAN</p>
<p><strong>支持 VLAN 的交换机</strong>：</p>
<ul>
<li>允许经一个单一的物理局域网基础设施定义多个虚拟局域网，在一个 VLAN 内的主机彼此通信，仿佛它们与交换机连接；</li>
<li>问题：VLAN 隔离：流量无法在 VLAN 中交换；</li>
<li>解决方案：VLAN 交换机的一个端口与一台外部路由器相连，并将该端口配置为属于两个 VLAN（即视为通过路由器转发跨越）。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>主要参考机械工业出版社《计算机网络自顶向下方法（第 6 版）》。</p>
<p>其他参考资料：</p>
<ul>
<li><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md">Interview-Notebook/计算机网络.md at master · CyC2018/Interview-Notebook</a></li>
<li><a href="https://blog.csdn.net/bian_qing_quan11/article/details/72912373">HTTP1.0、HTTP1.1与HTTPS - CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>学科补完计划</category>
      </categories>
      <tags>
        <tag>学科复习笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle Titanic 生存预测--特征工程</title>
    <url>/blog/kaggle-titanic-1/</url>
    <content><![CDATA[<p>注册著名的数据科学竞赛平台 Kaggle 四个多月了，当初是为了要一份数据集，而一直没有参加比赛。这个寒假终于按耐不住，决定拿入门级的 Titanic: Machine Learning from Disaster 打响革命第一枪。</p>
<p>Titanic 生存预测比赛是一个二分类问题。题目提供了一份乘客名单，包含了乘客的名字、性别、年龄、船票等级等信息，以及是否成功获救的标记，最终需要提交一份对测试集中的乘客是否成功获救的 csv 文件。</p>
<p>经过了四次提交，最后我的 Public Score 暂时定格在 0.80861，这个成绩目前在前 7%。这篇博文主要简述一下我所做的尝试和改进，并对最后一次换用 XGBoost 所得到的最好成绩的代码进行一个详细的说明，也是对相似题目处理流程的一个总结。</p>
<p><img src="/images/Titanic-public-score.jpg" alt="Titanic-public-score"></p>
<span id="more"></span>

<h2 id="过程简述"><a href="#过程简述" class="headerlink" title="过程简述"></a>过程简述</h2><h3 id="第一次提交"><a href="#第一次提交" class="headerlink" title="第一次提交"></a>第一次提交</h3><p>在探索数据后，我决定选用以下特征进行预测<code>&#39;Pclass&#39;, &#39;Sex&#39;, &#39;Age&#39;, &#39;Embarked&#39;, &#39;SibSp&#39;, &#39;Parch&#39;, &#39;Fare&#39;</code>。其中 Age、Embarked 和 Fare 有缺失，考虑使用出现频率最高的值来填充 Embarked 特征（类别型）的缺失值，使用平均值来填充 Age 和 Fare 特征（数值型）的缺失值。而类别特征不能直接作为输入，因此采用 DictVectorizer 对特征抽取和特征向量化。</p>
<p>最后使用 RandomForest 分类器来进行预测。Public Score 为 0.73205。</p>
<h3 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h3><p>Fare 只有一个缺失，而 Age 存在 86 个缺失值。因此，直接使用平均值来填充 Age 的缺失值可能对预测结果影响较大。我将 Age 从选取的有效特征中剔除，其他不变，Public Score 提高到 0.75598。</p>
<h3 id="第三次提交"><a href="#第三次提交" class="headerlink" title="第三次提交"></a>第三次提交</h3><p>在对别人分享的 kernel 进行学习后，这次我做了比较详细的特征工程（具体操作在下一节），并且进行了 sklearn 中常用分类器效果的比较，最终选用了 SVC 分类器。本次的 Public Score 提高到 0.79904。</p>
<h2 id="代码详述"><a href="#代码详述" class="headerlink" title="代码详述"></a>代码详述</h2><p>这里针对最后一次提交对应的代码进行一个说明总结。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> re <span class="keyword">as</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&#x27;../input/train.csv&#x27;</span>, header=<span class="number">0</span>, dtype=&#123;<span class="string">&#x27;Age&#x27;</span>: np.float64&#125;)</span><br><span class="line">test = pd.read_csv(<span class="string">&#x27;../input/test.csv&#x27;</span>, header=<span class="number">0</span>, dtype=&#123;<span class="string">&#x27;Age&#x27;</span>: np.float64&#125;)</span><br><span class="line">full_data = [train, test]</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>info</code>方法来大致地了解训练集和测试集：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(train.info())</span><br><span class="line"><span class="built_in">print</span>(test.info())</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 891 entries, 0 to 890</span><br><span class="line">Data columns (total 12 columns):</span><br><span class="line">PassengerId    891 non-null int64</span><br><span class="line">Survived       891 non-null int64</span><br><span class="line">Pclass         891 non-null int64</span><br><span class="line">Name           891 non-null object</span><br><span class="line">Sex            891 non-null object</span><br><span class="line">Age            714 non-null float64</span><br><span class="line">SibSp          891 non-null int64</span><br><span class="line">Parch          891 non-null int64</span><br><span class="line">Ticket         891 non-null object</span><br><span class="line">Fare           891 non-null float64</span><br><span class="line">Cabin          204 non-null object</span><br><span class="line">Embarked       889 non-null object</span><br><span class="line">dtypes: float64(2), int64(5), object(5)</span><br><span class="line">memory usage: 83.6+ KB</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 418 entries, 0 to 417</span><br><span class="line">Data columns (total 11 columns):</span><br><span class="line">PassengerId    418 non-null int64</span><br><span class="line">Pclass         418 non-null int64</span><br><span class="line">Name           418 non-null object</span><br><span class="line">Sex            418 non-null object</span><br><span class="line">Age            332 non-null float64</span><br><span class="line">SibSp          418 non-null int64</span><br><span class="line">Parch          418 non-null int64</span><br><span class="line">Ticket         418 non-null object</span><br><span class="line">Fare           417 non-null float64</span><br><span class="line">Cabin          91 non-null object</span><br><span class="line">Embarked       418 non-null object</span><br><span class="line">dtypes: float64(2), int64(4), object(5)</span><br><span class="line">memory usage: 36.0+ KB</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<h3 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h3><h4 id="Pclass"><a href="#Pclass" class="headerlink" title="Pclass"></a>Pclass</h4><p>Pclass 特征没有缺失值，因此可以通过<code>groupby</code>函数来计算船舱每一档的生还率：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;Pclass&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;Pclass&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>可以看到结果显示船舱档位和生还率还是有较大联系的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   Pclass  Survived</span><br><span class="line">0       1  0.629630</span><br><span class="line">1       2  0.472826</span><br><span class="line">2       3  0.242363</span><br></pre></td></tr></table></figure>

<h4 id="Sex"><a href="#Sex" class="headerlink" title="Sex"></a>Sex</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;Sex&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>可以看到女性的生还率更高：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      Sex  Survived</span><br><span class="line">0  female  0.742038</span><br><span class="line">1    male  0.188908</span><br></pre></td></tr></table></figure>

<h4 id="SibSp-and-Parch"><a href="#SibSp-and-Parch" class="headerlink" title="SibSp and Parch"></a>SibSp and Parch</h4><p>这两个特征是船上表亲和直亲数量。通过这两个特征可以创造一个新的特征 - Family Size：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    dataset[<span class="string">&#x27;FamilySize&#x27;</span>] = dataset[<span class="string">&#x27;SibSp&#x27;</span>] + dataset[<span class="string">&#x27;Parch&#x27;</span>] + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;FamilySize&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;FamilySize&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>可以看到生还率和家庭成员数不是单纯的线性关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   FamilySize  Survived</span><br><span class="line">0           1  0.303538</span><br><span class="line">1           2  0.552795</span><br><span class="line">2           3  0.578431</span><br><span class="line">3           4  0.724138</span><br><span class="line">4           5  0.200000</span><br><span class="line">5           6  0.136364</span><br><span class="line">6           7  0.333333</span><br><span class="line">7           8  0.000000</span><br><span class="line">8          11  0.000000</span><br></pre></td></tr></table></figure>

<p>我们可以再创建一个新特征 IsAlone，用来表示是否是单独出行：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    dataset[<span class="string">&#x27;IsAlone&#x27;</span>] = <span class="number">0</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">&#x27;FamilySize&#x27;</span>] == <span class="number">1</span>, <span class="string">&#x27;IsAlone&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;IsAlone&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;IsAlone&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   IsAlone  Survived</span><br><span class="line">0        0  0.505650</span><br><span class="line">1        1  0.303538</span><br></pre></td></tr></table></figure>

<p>现在特征值对结果的影响就比较明显了。</p>
<h4 id="Embarked"><a href="#Embarked" class="headerlink" title="Embarked"></a>Embarked</h4><p>注意 Embarked 特征有极少的缺失值，对于类别特征，可以考虑用最频繁的特征值进行填充：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train[<span class="string">&#x27;Embarked&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure>

<p>可以看到，最频繁的特征值为<code>S</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S    644</span><br><span class="line">C    168</span><br><span class="line">Q     77</span><br><span class="line">Name: Embarked, dtype: int64</span><br></pre></td></tr></table></figure>

<p>因此，我们用<code>S</code>对缺失值进行填充：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    dataset[<span class="string">&#x27;Embarked&#x27;</span>] = dataset[<span class="string">&#x27;Embarked&#x27;</span>].fillna(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;Embarked&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;Embarked&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>结果如下。可以看到明显的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  Embarked  Survived</span><br><span class="line">0        C  0.553571</span><br><span class="line">1        Q  0.389610</span><br><span class="line">2        S  0.339009</span><br></pre></td></tr></table></figure>

<h4 id="Fare"><a href="#Fare" class="headerlink" title="Fare"></a>Fare</h4><p>测试集中 Fare 特征有一个缺失值。对于数值特征，可以用中位数（或者平均值）填充缺失值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    dataset[<span class="string">&#x27;Fare&#x27;</span>] = dataset[<span class="string">&#x27;Fare&#x27;</span>].fillna(train[<span class="string">&#x27;Fare&#x27;</span>].median())</span><br></pre></td></tr></table></figure>

<p>因为每个 Fare 的值对应的样本数量太少，因此我们考虑划分区间。这里，我根据每个区间的样本数量将样本划分为四个区间，形成新特征 CategoricalFare：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train[<span class="string">&#x27;CategoricalFare&#x27;</span>] = pd.qcut(train[<span class="string">&#x27;Fare&#x27;</span>], <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;CategoricalFare&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;CategoricalFare&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   CategoricalFare  Survived</span><br><span class="line">0   (-0.001, 7.91]  0.197309</span><br><span class="line">1   (7.91, 14.454]  0.303571</span><br><span class="line">2   (14.454, 31.0]  0.454955</span><br><span class="line">3  (31.0, 512.329]  0.581081</span><br></pre></td></tr></table></figure>

<h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p>之前提到过，Age 特征的缺失值太多，不能简单的用平均值或者中位数进行填充。这里，我们不再简单的舍弃 Age 特征，而是换用不同的填充思路 - <strong>根据已有数据的平均值和标准差随机生成填充数</strong>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    age_avg = dataset[<span class="string">&#x27;Age&#x27;</span>].mean()</span><br><span class="line">    age_std = dataset[<span class="string">&#x27;Age&#x27;</span>].std()</span><br><span class="line">    age_null_count = dataset[<span class="string">&#x27;Age&#x27;</span>].isnull().<span class="built_in">sum</span>()</span><br><span class="line">    </span><br><span class="line">    age_null_random_list = np.random.randint(age_avg - age_std, age_avg + age_std, size=age_null_count)</span><br><span class="line">    dataset[<span class="string">&#x27;Age&#x27;</span>][np.isnan(dataset[<span class="string">&#x27;Age&#x27;</span>])] = age_null_random_list</span><br><span class="line">    dataset[<span class="string">&#x27;Age&#x27;</span>] = dataset[<span class="string">&#x27;Age&#x27;</span>].astype(<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>

<p>同样，将数据划分为区间。这里我按等区间跨度划分，生成新特征 CategoricalAge：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train[<span class="string">&#x27;CategoricalAge&#x27;</span>] = pd.cut(train[<span class="string">&#x27;Age&#x27;</span>], <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;CategoricalAge&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;CategoricalAge&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  CategoricalAge  Survived</span><br><span class="line">0  (-0.08, 16.0]  0.504274</span><br><span class="line">1   (16.0, 32.0]  0.345372</span><br><span class="line">2   (32.0, 48.0]  0.394422</span><br><span class="line">3   (48.0, 64.0]  0.434783</span><br><span class="line">4   (64.0, 80.0]  0.090909</span><br></pre></td></tr></table></figure>

<p>也有别的填充思路，例如用<code>Sex, Title, Pclass</code>三个特征构建随机森林模型，来生成填充值。</p>
<h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>姓名是我们一开始忽略掉的特征。实际上，通过人名前的头衔也可以进行分析：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_title</span>(<span class="params">name</span>):</span></span><br><span class="line">    title_search = re.search(<span class="string">&#x27; ([A-Za-z]+)\.&#x27;</span>, name)</span><br><span class="line">    <span class="keyword">if</span> title_search:</span><br><span class="line">        <span class="keyword">return</span> title_search.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Name&#x27;</span>].apply(get_title)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(pd.crosstab(train[<span class="string">&#x27;Title&#x27;</span>], train[<span class="string">&#x27;Sex&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sex       female  male</span><br><span class="line">Title                 </span><br><span class="line">Capt           0     1</span><br><span class="line">Col            0     2</span><br><span class="line">Countess       1     0</span><br><span class="line">Don            0     1</span><br><span class="line">Dr             1     6</span><br><span class="line">Jonkheer       0     1</span><br><span class="line">Lady           1     0</span><br><span class="line">Major          0     2</span><br><span class="line">Master         0    40</span><br><span class="line">Miss         182     0</span><br><span class="line">Mlle           2     0</span><br><span class="line">Mme            1     0</span><br><span class="line">Mr             0   517</span><br><span class="line">Mrs          125     0</span><br><span class="line">Ms             1     0</span><br><span class="line">Rev            0     6</span><br><span class="line">Sir            0     1</span><br></pre></td></tr></table></figure>

<p>由于存在一些次数较少的头衔，我们将头衔分类，把部分含义相近的头衔归在一起：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Title&#x27;</span>].replace([<span class="string">&#x27;Lady&#x27;</span>, <span class="string">&#x27;Countess&#x27;</span>, <span class="string">&#x27;Capt&#x27;</span>, <span class="string">&#x27;Col&#x27;</span>, <span class="string">&#x27;Sir&#x27;</span>, <span class="string">&#x27;Don&#x27;</span>, <span class="string">&#x27;Dr&#x27;</span>, <span class="string">&#x27;Major&#x27;</span>, <span class="string">&#x27;Rev&#x27;</span>, <span class="string">&#x27;Jonkheer&#x27;</span>, <span class="string">&#x27;Dona&#x27;</span>], <span class="string">&#x27;Rare&#x27;</span>)</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Title&#x27;</span>].replace(<span class="string">&#x27;Mlle&#x27;</span>, <span class="string">&#x27;Miss&#x27;</span>)</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Title&#x27;</span>].replace(<span class="string">&#x27;Ms&#x27;</span>, <span class="string">&#x27;Miss&#x27;</span>)</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Title&#x27;</span>].replace(<span class="string">&#x27;Mme&#x27;</span>, <span class="string">&#x27;Mrs&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(train[[<span class="string">&#x27;Title&#x27;</span>, <span class="string">&#x27;Survived&#x27;</span>]].groupby([<span class="string">&#x27;Title&#x27;</span>], as_index=<span class="literal">False</span>).mean())</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Title  Survived</span><br><span class="line">0  Master  0.575000</span><br><span class="line">1    Miss  0.702703</span><br><span class="line">2      Mr  0.156673</span><br><span class="line">3     Mrs  0.793651</span><br><span class="line">4    Rare  0.347826</span><br></pre></td></tr></table></figure>

<h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><p>sklearn 要求数据都是数值型的，因此要进行数据的清理和转换。也可以用各种包内现成的算法，例如<code>pd.get_dummies()</code>。这里我们就简单的自己动手来将数据映射为数值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据映射为数值</span></span><br><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> full_data:</span><br><span class="line">    <span class="comment"># Mapping Sex</span></span><br><span class="line">    dataset[<span class="string">&#x27;Sex&#x27;</span>] = dataset[<span class="string">&#x27;Sex&#x27;</span>].<span class="built_in">map</span>( &#123;<span class="string">&#x27;female&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;male&#x27;</span>: <span class="number">1</span>&#125; ).astype(<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Mapping titles</span></span><br><span class="line">    title_mapping = &#123;<span class="string">&quot;Mr&quot;</span>: <span class="number">1</span>, <span class="string">&quot;Miss&quot;</span>: <span class="number">2</span>, <span class="string">&quot;Mrs&quot;</span>: <span class="number">3</span>, <span class="string">&quot;Master&quot;</span>: <span class="number">4</span>, <span class="string">&quot;Rare&quot;</span>: <span class="number">5</span>&#125;</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Title&#x27;</span>].<span class="built_in">map</span>(title_mapping)</span><br><span class="line">    dataset[<span class="string">&#x27;Title&#x27;</span>] = dataset[<span class="string">&#x27;Title&#x27;</span>].fillna(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Mapping Embarked</span></span><br><span class="line">    dataset[<span class="string">&#x27;Embarked&#x27;</span>] = dataset[<span class="string">&#x27;Embarked&#x27;</span>].<span class="built_in">map</span>( &#123;<span class="string">&#x27;S&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Q&#x27;</span>: <span class="number">2</span>&#125; ).astype(<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Mapping Fare</span></span><br><span class="line">    dataset.loc[ dataset[<span class="string">&#x27;Fare&#x27;</span>] &lt;= <span class="number">7.91</span>, <span class="string">&#x27;Fare&#x27;</span>] 						        = <span class="number">0</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">&#x27;Fare&#x27;</span>] &gt; <span class="number">7.91</span>) &amp; (dataset[<span class="string">&#x27;Fare&#x27;</span>] &lt;= <span class="number">14.454</span>), <span class="string">&#x27;Fare&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">&#x27;Fare&#x27;</span>] &gt; <span class="number">14.454</span>) &amp; (dataset[<span class="string">&#x27;Fare&#x27;</span>] &lt;= <span class="number">31</span>), <span class="string">&#x27;Fare&#x27;</span>]   = <span class="number">2</span></span><br><span class="line">    dataset.loc[ dataset[<span class="string">&#x27;Fare&#x27;</span>] &gt; <span class="number">31</span>, <span class="string">&#x27;Fare&#x27;</span>] 							        = <span class="number">3</span></span><br><span class="line">    dataset[<span class="string">&#x27;Fare&#x27;</span>] = dataset[<span class="string">&#x27;Fare&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Mapping Age</span></span><br><span class="line">    dataset.loc[ dataset[<span class="string">&#x27;Age&#x27;</span>] &lt;= <span class="number">16</span>, <span class="string">&#x27;Age&#x27;</span>] 					       = <span class="number">0</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">16</span>) &amp; (dataset[<span class="string">&#x27;Age&#x27;</span>] &lt;= <span class="number">32</span>), <span class="string">&#x27;Age&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">32</span>) &amp; (dataset[<span class="string">&#x27;Age&#x27;</span>] &lt;= <span class="number">48</span>), <span class="string">&#x27;Age&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">48</span>) &amp; (dataset[<span class="string">&#x27;Age&#x27;</span>] &lt;= <span class="number">64</span>), <span class="string">&#x27;Age&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    dataset.loc[ dataset[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">64</span>, <span class="string">&#x27;Age&#x27;</span>]                           = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="特征选取"><a href="#特征选取" class="headerlink" title="特征选取"></a>特征选取</h3><p>我们将一些无用的特征去掉，只保留部分原始特征和我们生成的新特征：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Feature Selection</span></span><br><span class="line">drop_elements = [<span class="string">&#x27;PassengerId&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Ticket&#x27;</span>, <span class="string">&#x27;Cabin&#x27;</span>, <span class="string">&#x27;SibSp&#x27;</span>, <span class="string">&#x27;Parch&#x27;</span>, <span class="string">&#x27;FamilySize&#x27;</span>]</span><br><span class="line">train = train.drop(drop_elements, axis = <span class="number">1</span>)</span><br><span class="line">train = train.drop([<span class="string">&#x27;CategoricalAge&#x27;</span>, <span class="string">&#x27;CategoricalFare&#x27;</span>], axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">test  = test.drop(drop_elements, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (train.head(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">train = train.values</span><br><span class="line">test  = test.values</span><br></pre></td></tr></table></figure>

<p>打印的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   Survived  Pclass  Sex  Age  Fare  Embarked  IsAlone  Title</span><br><span class="line">0         0       3    1    1     0         0        0      1</span><br><span class="line">1         1       1    0    2     3         1        0      3</span><br><span class="line">2         1       3    0    1     1         0        1      2</span><br><span class="line">3         1       1    0    2     3         0        0      3</span><br><span class="line">4         0       3    1    2     1         0        1      1</span><br><span class="line">5         0       3    1    1     1         2        1      1</span><br><span class="line">6         0       1    1    3     3         0        1      1</span><br><span class="line">7         0       3    1    0     2         0        0      4</span><br><span class="line">8         1       3    0    1     1         0        0      3</span><br><span class="line">9         1       2    0    0     2         1        0      3</span><br></pre></td></tr></table></figure>

<h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p>首先生成训练集的特征和标记：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">X = train[<span class="number">0</span>::, <span class="number">1</span>::]</span><br><span class="line">y = train[<span class="number">0</span>::, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>引入并初始化 xgboost：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line">xgbc = XGBClassifier()</span><br></pre></td></tr></table></figure>

<p>我们先使用 5 折交叉验证来看一看 xgboost 算法的预测效果如何：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment"># sklearn.cross_validation 好像已经废除，使用 from sklearn.model_selection import cross_val_score</span></span><br><span class="line"></span><br><span class="line">cross_val_score(xgbc, X, y, cv=<span class="number">5</span>).mean()    <span class="comment"># 使用 5 折交叉验证</span></span><br></pre></td></tr></table></figure>

<p>结果为 0.80595516611715701，还不错。之后就可以正式的训练和预测了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">xgbc.fit(X, y)</span><br><span class="line">xgbc_y_predict = xgbc.predict(test)</span><br><span class="line"></span><br><span class="line">test_data = pd.read_csv(<span class="string">&#x27;../input/test.csv&#x27;</span>, header=<span class="number">0</span>, dtype=&#123;<span class="string">&#x27;Age&#x27;</span>: np.float64&#125;)</span><br><span class="line">xgbc_submission = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;PassengerId&#x27;</span>: test_data[<span class="string">&#x27;PassengerId&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Survived&#x27;</span>: xgbc_y_predict</span><br><span class="line">&#125;)</span><br><span class="line">xgbc_submission.to_csv(<span class="string">&#x27;xgbc_submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="分类器比较"><a href="#分类器比较" class="headerlink" title="分类器比较"></a>分类器比较</h3><p>尽管这一次我直接选用了 XGBoost，但是我还是想把第三次提交时所用的分类器比较代码贴一下。首先是引入所有参与比较的分类器（全部是 sklearn 包中的），以及用于可视化的 matplotlib 和 seaborn。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedShuffleSplit</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, log_loss</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn.discriminant_analysis <span class="keyword">import</span> LinearDiscriminantAnalysis, QuadraticDiscriminantAnalysis</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br></pre></td></tr></table></figure>

<p>初始化各分类器，并使用数据集划分函数 StratifiedShuffleSplit：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">classifiers = [</span><br><span class="line">    KNeighborsClassifier(<span class="number">3</span>),</span><br><span class="line">    SVC(probability=<span class="literal">True</span>),</span><br><span class="line">    DecisionTreeClassifier(),</span><br><span class="line">    RandomForestClassifier(),</span><br><span class="line">    AdaBoostClassifier(),</span><br><span class="line">    GradientBoostingClassifier(),</span><br><span class="line">    GaussianNB(),</span><br><span class="line">    LinearDiscriminantAnalysis(),</span><br><span class="line">    QuadraticDiscriminantAnalysis(),</span><br><span class="line">    LogisticRegression()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">log_cols = [<span class="string">&#x27;Classifier&#x27;</span>, <span class="string">&#x27;Accuracy&#x27;</span>]</span><br><span class="line">log = pd.DataFrame(columns=log_cols)</span><br><span class="line"></span><br><span class="line">sss = StratifiedShuffleSplit(n_splits=<span class="number">10</span>, test_size=<span class="number">0.1</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">X = train[<span class="number">0</span>::, <span class="number">1</span>::]</span><br><span class="line">y = train[<span class="number">0</span>::, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">acc_dict = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>分别计算各分类器的准确率：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> sss.split(X, y):</span><br><span class="line">    X_train, X_test = X[train_index], X[test_index]</span><br><span class="line">    y_train, y_test = y[train_index], y[test_index]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> clf <span class="keyword">in</span> classifiers:</span><br><span class="line">        name = clf.__class__.__name__</span><br><span class="line">        clf.fit(X_train, y_train)</span><br><span class="line">        train_predictions = clf.predict(X_test)</span><br><span class="line">        acc = accuracy_score(y_test, train_predictions)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> acc_dict:</span><br><span class="line">            acc_dict[name] += acc</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            acc_dict[name] = acc</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> clf <span class="keyword">in</span> acc_dict:</span><br><span class="line">    acc_dict[clf] = acc_dict[clf] / <span class="number">10.0</span></span><br><span class="line">    log_entry = pd.DataFrame([[clf, acc_dict[clf]]], columns=log_cols)</span><br><span class="line">    log = log.append(log_entry)</span><br><span class="line">    </span><br><span class="line">plt.xlabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Classifier Accuracy&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sns.set_color_codes(<span class="string">&#x27;muted&#x27;</span>)</span><br><span class="line">sns.barplot(x=<span class="string">&#x27;Accuracy&#x27;</span>, y=<span class="string">&#x27;Classifier&#x27;</span>, data=log, color=<span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这里的指标其实有更好的选择，因为当训练集中大量例子属于某一个类时，分类器可能通过简单地全部预测为较大类来达到更高的准确率。用 F1 Score，即精确率和召回率的调和平均数会更为科学。</p>
<p>比较结果如图：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAg8AAAEWCAYAAADhFHRsAAAABHNCSVQICAgIfAhkiAAAAAlwSFlz%0AAAALEgAACxIB0t1+/AAAIABJREFUeJzs3Xu8plPdx/HPdhzMGDUk800GiYzDGEPxyFkiREiIiETk%0AiYeoPOPQ4VGUHCtyCskhx6FQIclpxmkQiXH6qpwZhzGM/fyx1ua223v2fc/svefg+3695rX3va51%0ArbWua8/rdf2u31rXfbW1t7cTERER0aw5ZvQAIiIiYtaS4CEiIiJakuAhIiIiWpLgISIiIlqS4CEi%0AIiJakuAhIiIiWpLgISJmOZIOk3R2H7Z/r6R16+9tkk6X9LykWyV9UtIDfdV3xKxgrhk9gIiIrkja%0AAdgfWA6YCNwJfN/2X/q6b9vDGz6uBWwEfMj2K7Vs2d7uU9JhwKHAJ2zf0tvtR/SmZB4iYqYjaX/g%0Ap8APgEWBDwMnAlvMgOEsATzSEDhMM0ld3rBJagN2Bp6rP/tNzazkWhAtSeYhImYqkgYDRwC72r6o%0AYdOY+q+rfS4APgnMB9wF7GX73rptU+BoYHHgJeAY20dLWhg4g5JZeAu4F1jH9luSHgF2pwQOJwJz%0AS3oZ+DFwLXC27Q/V9ocCxwNrAy/X9o+r2w4DVgAmUQKf/YFfdnEInwQWq30eJ2k/25Mbju8rdd8P%0AAY8DX7R9u6TFgWPr/nMA59rep/b7EdtfrPsPAyYAc9t+U9J1wI3AusBIYEVJnwS+Wft4Gvih7V80%0AjOGzwOHAUnX73sAg4GDbqzbU27+ex8929beK2UOizYiY2awBDAAubmGf3wHLAB8AbgfOadh2KvBV%0A24MoF/I/1fL/AZ4AFqFkN74NvOv7+m2fCuwJ3GR7oO1DG7fXO/bLKQGLgA2Ab0jauKHaZ4ELgYU6%0AjavRl2o759fPmzf0sS1wGCUjsSAlCHlW0pyUYOpRYFjt/zfdtN+VnYA9KAHAo8BTwGa1j12BYySN%0ArGNYHfgVcGA9jrWBR4DLgCUlfaxTu79qYRwxC0rmISJmNkOAZ2y/2ewOtk/r+L3edT8vabDtF4E3%0AgOUl3WX7eeD5WvUNyt3+Erb/AdwwDWNdDVjE9hH188OSTgG+AFxVy26yfUn9/bXODUiaH9gW2Nn2%0AG5IupAQKv61Vdgd+ZPu2+vkfdb81gKHAgQ3nqpX1IGd0ZGeqKxp+v17S1ZSMxu3AbsBptq+p290w%0A/vOALwLfkTScEsh0mSGK2UcyDxExs3kWWLi79QGdSZpT0pGSHpL0EuWOGGDh+nNrYFPgUUnX14su%0AwFGUC/HVkh6WdPA0jHUJYKikFzr+UTIYizbUebyHNrYC3gSurJ/PATaRtEj9vDjwUBf7LQ482kqQ%0A1cm7xiVpE0k3S3quHsemvHMOuxsDwJnADnXdxk7A+bZfn8YxxSwiwUNEzGxuAl4Htmyy/g6UqYEN%0AgcGUO1+ANgDbt9X59w8Al1CnBmxPtP0/tpeirkeQtEGLY30cmGB7oYZ/g2xv2lCnp1cXfwkYCDwm%0A6V/ABcDc9bg6+li6m74/3E2Q9Qowf8PnD3ZR5+1xSZqXkuk4GljU9kKUYKathzFg+2ZgMiVLsQNw%0AVlf1YvaSaYuImKnYflHSaOBESW8CV1OmGDYE1rP9zU67DKIEG89SLpg/6NggaR7KlMCY2u5LlMWR%0ASNoMuJ9yR/0iMKVjWwtuBSZKOgg4jnIR/RgwX8M0Q7ckdayT2AS4u2HTNyhTF8dSFlj+RNJfKFMI%0AS1POx63AP4EjJR1ax7+q7Rspj7UeJOnD9di+1cNQ5gHmpSyEfFPSJsCngHvq9lMpGZoxlAWjiwGD%0AbN9ft/8KOAF4oz8epY0ZL5mHiJjp2P4x5emCQygXtMeBfSiZg85+RVnwZ+A+4OZO23cCHqmBw57A%0AjrV8GeAPlCckbgJOsn1ti+OcQllkOILyNMMzlIv94Cab2Am40/bVtv/V8Y8SiKwkaQXbFwDfB35N%0A+b6LS4D31743Bz4CPEZZ/LldHdc1wHmUgGQcPaxBsD0R2JeSlXmekkG4rGH7rdRFlJRg5HrKlE2H%0AsyiLUfvsi7ti5tLW3t5TRi0iIqJ7kuajPK0x0vaDM3o80feSeYiIiOm1F3BbAof3jqx5iIiIaVa/%0AUKuN5he4xmwg0xYRERHRkkxbREREREsybRGzpYUXXrh92LBhM3oYERGzlHHjxj3T3t6+SE/1EjzE%0AbGnYsGGMHTt2Rg8jImKW0tbW9mgz9TJtERERES1J5iFmSxOenMgOo1v6vp+IiJnOr49Yb0YPoUvJ%0APERERERLEjxERERESxI8REREREsSPERERERLEjw0QdLLDb9vKunvkpaQdJikVyV9oKu6U2nvSkkL%0A9VDnOkmjuijfRdIJrR5DMyQdIOl+SXdKuk3SzlMbyzT2MUrScfX3eSX9ofa3naRfSlq+N/qJiIi+%0Ak6ctWiBpA8qrcje2/agkKK/g/R/goGbbsb1p34xw6iS1AW223+pi257ARsDqtl+StCCwVW+PwfZY%0AoOMLGFapZSPq5/NaaUvSnPW1xBER0Y8SPDRJ0trAKcCmth9q2HQasIukH9p+rtM+XwT2BeYBbgG+%0AZntKfZHMKNvPSPpf4IvA08DjwDjbR9cmtpV0ErAQsJvtG2r54pKuAwScbfvw2t/+wJdrnV/a/qmk%0AYcBVtf9VgU0lHQ6MAtqB02wfA3wbWNf2SwD155ldnIefAasB8wEX2j60lh8JbAG8CVxt+wBJ2wKH%0AAlOAF22vLWld4IA6zrOBRSTdCWwNnAocYHuspE8BhwPzAg8Bu9p+uZ678yiBzo+A33T194qIiL6T%0AaYvmzAtcAmxp+/5O216mBBD/3Vgo6WPAdsB/1TvrKcCOneqsRrlorgxsQrmgN5rL9urANygX4Q6r%0A1/1WogQYoyStCuwKfBz4BPAVSavU+ssAJ9keDiwMyPYKtlcETq9ZhkG2H27iXHzH9qja9zqSVpI0%0AhJKlGG57JeB7te5oSpZmZUpg8TbbTwG7AzfYHtEYkElaGDgE2ND2SEqmYv+G3Z+1PdL2uwIHSXtI%0AGitp7ORJE5s4lIiImBbJPDTnDeCvwG50ChKq44A7JR3dULYB5U7/tjq9MR/wVKf9/gu41PYkYJKk%0Ayzttv6j+HAcMayi/xvazAJIuAtaiZBEutv1KQ/kngcuAR23fXPd9GFhK0vHAFcDVwMCeTkCDz0va%0Ag/J/ZzFgeeA+YBJwqqQxwJha90bgDEnnNxxLMz5R272xnrt5gJsatnc5vWH7ZOBkgCFDl83rYiMi%0A+kgyD815C/g8sLqkb3feaPsF4NfA3g3FbcCZ9a56hO1lbR/WYr+v159TeHeg1/nC2NOF8pWGsT5P%0AyXRcB+xJmd54CXhZ0lJTa0TSkpQphw1qhuEKYIDtNynZkAuBzYDf1772pGQQFgfG1QxFM9ooAVLH%0AuVve9m5dHU9ERPS/BA9Nsv0q8BlgR0m7dVHlJ8BXeeci/0dgm44nMSS9X9ISnfa5Edhc0gBJAykX%0A3mZsVNubD9iytnMDsKWk+SUtQJlGuKHzjnVKYA7bv6Vc2EfWTf8HnFinMJA0sONpiwYLUi7cL0pa%0AlDLVQh37YNtXAvtRghMkLW37FtujKWs6Fm/y+G4G/kvSR2o7C0j6aJP7RkREH0vw0IK6IPLTwCGS%0AOs/hPwNcTFkfge37KBfnqyXdDVxDSfM37nMbZVrhbuB3wHjgxSaGcivw27rfb22PtX07cEbddgsl%0Ao3BHF/sKuK4uUjwb+FYt/xlwLWWa5R5K4PGupzJs3wXcAdxPybTcWDcNAsbU4/wL76xPOErS+Nre%0AX4G7mjg2bD8N7AKcW9u8CViumX0jIqLvtbW3Z2p4RpI0sD5FMD/wZ2CPGgjEdBgydNn2jXf/+Ywe%0ARkTEdOnvF2O1tbWNa29v7/F7fbJgcsY7uX4x0gDKGokEDhERMVNL8DCD2d5hRo8hIiKiFVnzEBER%0AES1J5iFmS0sOHdTvc4UREe8VyTxERERESxI8REREREsSPERERERLsuYhZksTnpzIDqOvndHDiIjo%0AV/211iuZh4iIiGhJgoeIiIhoSYKHiIiIaEmCh4iIiGhJgoeIiIhoSZ62iH4n6TvADsAUymu/LwYG%0A2P5WQ50RwLm2PyZpIPBjYEPgBWAicJDtW/p98BERkcxD9C9JawCbASNtr0QJCK4FtutU9QvAufX3%0AXwLPAcvYXhXYFVi4f0YcERGdJfMQ/W0x4BnbrwPYfgb4s6TnJX28IZvweWBjSUsDHwd2tP1W3WcC%0AMGEGjD0iIkjmIfrf1cDikv4u6SRJ69TycynZBiR9AnjO9oPAcOBO21N6aljSHpLGSho7edLEvhp/%0ARMR7XoKH6Fe2XwZWBfYAngbOk7QLcB6wjaQ5ePeURSttn2x7lO1R8wwY1IujjoiIRgkeot/ZnmL7%0AOtuHAvsAW9t+nDIVsQ6wNSWYALgXWFnSnDNmtBER0VmCh+hXkpaVtExD0Qjg0fr7ucAxwMO2nwCw%0A/RAwFjhcUlttY5ikz/TjsCMiokEWTEZ/GwgcL2kh4E3gH5QpDIALgOOAr3faZ3fKo5r/kPQa8Axw%0AYP8MNyIiOkvwEP3K9jhgzW62PQPM3UX5S8BX+nhoERHRpExbREREREsSPERERERLEjxERERES7Lm%0AIWZLSw4dxK+PWG9GDyMiYraUzENERES0JMFDREREtCTBQ0RERLQkax5itjThyYnsMPraGT2MiIh+%0A1V9rvZJ5iIiIiJYkeIiIiIiWJHiIiIiIliR4iIiIiJYkeIiIiIiW5GkLQNIUYDzljY5vAr8CjrH9%0A1jS0dQTwZ9t/6Gb7nsCrtn/VYrsbAz+sHz8CGHgNuNv2zq2Os4v2F6S89np94AXgJeCbwB3AM7YX%0Amt4+aj97Ay/YPkfS8sC5wFvANsAZtj/ZG/1ERETfSfBQvGZ7BICkDwC/BhYEDm21Iduje9j+82kZ%0AoO2rgKvqGK8DDrA9tnM9SXPZfnMaujgN+BvwEdvtkpYGPjotY50a2yc2fPwccK7tI+vnpgMHSW1A%0A27QEeBERMX0SPHRi+ylJewC3STqMMrVzJLAuMC9wou1fAEg6CPgi5c75d7YPlnQGMMb2hZKOBLag%0AZDOutn1AbfNl20dLGgH8HJgfeAj4su3na3BwC7AesBCwm+0buhuzpN2BzYDBdSwbSDqYcnEeAFxo%0A+4ha90vA3sA8wF+BfYBlgBHA52231/PwEPCQpLka+lkQuKSOaS7g27bHSBoEnA8MBeYEDqvHfxTw%0AmXr8v7N9kKTvAc8AD9e+p0jaEPg0DRmOrsYv6SPAZZRsyCrARpQMTERE9KMED12w/bCkOYEPAJ8F%0AXrS9mqR5gRslXQ0sV7d93Parkt7f2IakIcBWwHL1Tr6rtP+vgK/bvr5OdxwKfKNum8v26pI2reUb%0A9jDsVYARNfjYFPgw8HGgDbhS0pqUqYitgDVtvynpZOALwCTgjibu4l8DtrT9Us3Q3AiMATYFHrG9%0AST32wZIWreXDuzp+25dJWp0SMPy0U5DS3fifopz3nbvJuuwB7AEweVJ7D4cSERHTKsFDzz4FrCRp%0Am/p5MOVOfUPgdNuvAth+rtN+L1IuyqdKGkO5yL5N0mBgIdvX16IzgQsaqlxUf44DhjUxzqttP98w%0A5k0od+gAAylTEAsBqwFjJQHMBzwO3NtE+1Au5EdKWouS4Vhc0sLA3bX8SOBy2zdKerXWOUXSFXQ6%0A/h50N/6ngIe6ChwAbJ8MnAwwZOiyiR4iIvpIgocuSFoKmEK5WLVRsgNXdaqz8dTaqHf2qwMbUBYD%0A7kNZjNis1+vPKTT3d3ql4fc24Hu2T22sIGk/4DTb/9upfFlghKQ5esg+7EwJnkbW43sCGGD7b5JG%0AUTINR0r6ne0f1LKNgG2BvShBQTO6G/9HOh1nRETMAHlUsxNJi1DWIZxQ5/+vAvaSNHfd/lFJCwDX%0AALtKmr+Wd562GAgMtn0lsB+wcuN22y8Cz0vqWCS4E3A9veMqYLc6TiR9qGYI/gB8vv6OpCGSPmz7%0AAcrTJqPrQkQkLSlpk07tDgaeqoHDRoBqXVHWcZxFeWJjZF0HsaDtMfX4V+mF8UdExEwgmYdiPkl3%0A8s6jmmcBP6nbfkmZNri9Xlifpsz7/74ueBwraTJwJfDthjYHAZdKGkC5k96/i36/BPy8BiAPA7v2%0AxsHYvlLScsDNdXpiIrCD7fGSDgf+IGkO4A1gT+Cx2vdPgH9Ieq0e5wGdmj4LuFzSeOBW4MFavjIl%0A4/AWMLm2ORi4qK4TmaOb429p/C2ehoiI6CNt7e2ZGo7Zz5Chy7ZvvPs0PRUbETHLmt63ara1tY1r%0Ab28f1VO9TFtERERESxI8REREREuy5iFmS0sOHTTd6buIiOhaMg8RERHRkgQPERER0ZIEDxEREdGS%0ABA8RERHRkiyYjNnShCcnssPoa2f0MCIi+k1/LhJP5iEiIiJakuAhIiIiWpLgISIiIlqS4CEiIiJa%0A8p5ZMClpCuW103MBE4CdbL/QC+0OA8bYXqEX2joDWAd4sRadZvu46W23m77WBSbb/mtD2c7AN4F2%0AyttFz7F9dB3XGNsX9kK/Q4HjbG9TP58LDAdOB94H/Nn2H6a3n4iI6DvvmeABeM32CABJZwJ7A9+f%0AsUPq0oHTcpGWNKftKS3ssi7wMvDXuv8mwDeAT9l+sr5Ke+dWx9ET208CHYHDB4HVbH9kWtqSNJft%0AN3tzfBER0bP3UvDQ6CZgJQBJA4FLKXe9cwOH2L60ZhR+B/wFWBMw8Fnbr0laFTittnV1R6OSBgA/%0AA0ZR7tz3t32tpF2ALYEFgGWAo4F5gJ2A14FNbT/X3WAlbQ98G2gDrrB9UC1/GfgFsCGwt6TXgJ8A%0AA4FngF1s/1PSvsCedUz3AQfXz1MkfRH4OvAt4IB6ccf268ApXYxlNLA5MB8l8Piq7fbOfdj+gqR1%0AgGPrru3A2sAQ3snUXF2a1J11DLvVbRfWc9zVsVwH3AmsBZwL/Li78xYREX3jPbfmQdKcwAbAZbVo%0AErCV7ZHAesCPJbXVbcsAJ9oeDrwAbF3LTwe+bnvlTs3vDbTbXhHYHjizBhQAKwCfA1ajZDxetb0K%0AJZBpvMM/StKd9d+KNc3/Q2B9YASwmqQta90FgFvqOG4Bjge2sd0R3HRkVg4GVrG9ErCn7UeAnwPH%0A2B5h+4Y6vnFNnMITbK9WL/7zAZt11UctOwDYu2Z8Pgm81qmtLYCHGsYAgKS5p3IsAPPYHmX7XYGD%0ApD0kjZU0dvKkiU0cSkRETIv3UuZhvnqHK+BvwDW1vA34gaS1gbfq9kXrtgm276y/jwOGSVoIWMj2%0An2v5WcAm9fe1KBc9bN8v6VHgo3XbtbYnAhMlvQhcXsvHU7Mg1bumLSR9FrjO9tP18zmUO/hLgCnA%0Ab2vVZSkBwDWSAOYE/lm33Q2cI+mSut/0WE/SN4H5gfcD99Zj6aqPG4Gf1DFfZPuJOraeTO1YAM7r%0AaifbJwMnAwwZumx7i8cVERFNei8FD6/ZHiFpfuAqSpbgOGBHYBFgVdtvSHoE6MgWvN6w/xTKnfa0%0AamzrrYbPbzHtf4dJDesc2oB7ba/RRb3PUAKOzYHvSFqxizr3AqsCf+qus5pFOQkYZftxSYfxzrn6%0Ajz5sHynpCmBT4EZJG1MyPT2Z2rEAvNJEGxER0Ufec9MWtl8F9gX+R9JcwGDgqRo4rAcs0cP+LwAv%0ASFqrFu3YsPmGjs+SPgp8GHhgOod8K7COpIXrlMv2wPVd1HsAWETSGrX/uSUNlzQHsLjta4GDKMc7%0AEJgIDGrY//8oUyYfrPvPI2n3Tn10BArP1LUiHQsfu+xD0tK2x9v+IXAbsFyTx9zlsTS5b0RE9LH3%0AXPAAYPsOSpp9e+AcYJSk8ZS1B/c30cSuwIl1GqStofwkYI7a1nmURX6vd9VAC2P9J2U9wbXAXcA4%0A25d2UW8y5WL+Q0l3URYVrklJ+Z9dx3QH5THJFyhTDVvVtRWftH0lcALwB0n3ArcDC3bq4wXKIsp7%0AKNmb2+qm7vr4hqR7JN0NvEFZgNrMMXd3LBERMRNoa2/P1HDMfoYMXbZ9491/PqOHERHRb3rjxVht%0AbW3j2tvbR/VU7z2ZeYiIiIhpl+AhIiIiWpLgISIiIlryXnpUM95Dlhw6qFfm/yIi4j8l8xAREREt%0ASfAQERERLUnwEBERES3pMXiQNKekZr44KSIiIt4DelwwaXuKpAckfdj2Y/0xqIjpNeHJieww+toZ%0APYyIiH7R3wvEm33a4n3AvZJupeGlRLa36JNRRURExEyr2eDhf/t0FBERETHLaGrBpO3rgUeAuevv%0At1FenBQRERHvMU0FD5K+AlwI/KKjCLikrwYVERERM69mpy32BlYHbgGw/aCkD/TZqGZhkrYELgY+%0AZvs/nlKRdAYwxvaFU2njDGAd4EVgAHCu7cN7eYx/t31fQ9kBwO7AJMrrs4+3/StJ1wEH2B7bC/2O%0AAna2va+keYErgIWB/wM2An7SOKaIiJg5Nfs9D6/bntzxQdJcQN7l3bXtgb/Un9PjQNsjgBHAlyQt%0AOd0je8eWwPIdHyTtSbl4r1773ABo68X+ALA91va+9eMqtWyE7fNs795K4CBpzt4eX0RENKfZzMP1%0Akr4NzCdpI+BrwOV9N6xZk6SBwFrAepTzc6ikNuB4ysX5caAxCBsNbA7MB/wV+KrtzkHZgPrzlbrP%0ABsDRlL/dbcBetl+fSvmRwBbAm8DVwEX18zqSDgG2Br4NrGv7JYD688wuju9nwGp1vBfaPrSWv6sP%0A2wdI2hY4FJgCvGh7bUnrAgcAXwbOBhaRdGcdw6nUDIekTwGHA/MCDwG72n5Z0iPAefVc/gj4zdT/%0AIhER0ReazTwcDDwNjAe+ClwJHNJXg5qFfRb4ve2/A89KWhXYCliWcqe/M7BmQ/0TbK9mewXKBXmz%0Ahm1H1QvrE8BvbD8laQBwBrCd7RUpgcJeUykfUvsfbnsl4Hu2/wpcxjuZjaeBQbYfbuL4vmN7FLAS%0AJfhYqas+at3RwMa2V6YEFm+z/RRliuSGmnl4qGObpIUp/7c2tD0SGAvs37D7s7ZH2v6PwEHSHpLG%0ASho7edLEJg4nIiKmRVOZB9tvAafUf9G97YFj6++/qZ/noqxZmAI8KelPDfXXk/RNYH7g/cC9vJPR%0AOdD2hTWb8UdJa1KyDxNqcAIlO7A3cG035SdQ1jCcKmkMMGY6j+/zkvaox7QYJSC6r5s+bgTOkHQ+%0AJdvRrE/Udm+UBDAPcFPD9vO629H2ycDJAEOGLptptYiIPjLV4EHS+bY/L2k8XaxxqHeaAUh6P7A+%0AsKKkdmBOyjm7uJv6A4CTgFG2H5d0GO9MUbytpuuvo0yHXNXKmGy/KWl1yhqGbYB96hgb67wk6WVJ%0AS00t+1DXXBwArGb7+bqoc0B3fdjeU9LHgc8A42oWphltwDW2u1sz8ko35RER0U96mrb4Rv25GWVu%0AvvO/eMc2wFm2l7A9zPbiwATgWWC7+o6QxSjrIeCdQOGZml3YpqtG6+LUj1Pm/h8Ahkn6SN28E3B9%0Ad+W13cG2rwT2A1au2ycCgxq6+T/gREkL1j4HStq501AWpFy4X5S0KLBJR92u+pC0tO1bbI+mTI0s%0A3tMJrG4G/qvjWCQtIOmjTe4bERH9oKdpizHASMpc+U79MJ5Z2fbADzuV/Rb4GPAgJb3/GDUFb/sF%0ASacA9wD/oixybHRUXdA4D/BH4CLb7ZJ2BS6oQcVtwM/rwsj/KKdMhVxasxxtvLN24DfAKZL2pQQt%0APwMGArdJeoPyqOaPGwdj+y5JdwD3UxZ+3lg3Deqmj6MkLVPL/gjcRXn8dKpsPy1pF+Dc+jgnlDUQ%0Af+9+r4iI6E9t7e3dTw1Lugf4AfBd4MDO2223Mpcd0W+GDF22fePdfz6jhxER0S9668VYbW1t49rb%0A20f1VK+nzMOewI7AQvznNEU7rS2Ei4iIiNnAVIMH238B/iJprO1T+2lMERERMRPr6WmL9W3/CXhe%0A0uc6b8+0RURExHtPT9MW6wB/ousnKzJtETOtJYcO6rU5wIiIeLeepi0OrT937Z/hRERExMyuqW+Y%0AlPTfwOmU7wc4hfL45sG2r+7DsUVERMRMqNl3W3y5vizpU8AQypcQHdlno4qIiIiZVrNv1ex4PfOm%0AwK9s31vfFhkxU5rw5ER2GH3tjB5GRES/6O81Xs1mHsZJupoSPFwlaRDwVt8NKyIiImZWzQYPu1Fe%0Ay72a7VeBuYEsooyIiHgPajZ4WAN4oL6P4YuUdw282HfDioiIiJlVs8HDz4BXJa0M/A/lDY+/6rNR%0ARURExEyr2eDhTdvtwGeBE2yfyLtf6RwRERHvEc0+bTFR0reALwJrS5qDsu6h30laFDgG+ATwPDAZ%0A+JHti6exvcOAl20fLekI4M+2/zAN7YwAhtq+sn7eBTgKMOVc/Q3Yua4ZmW5d9LcFsLztaXqEVtLc%0AlLenbk35Po/XgSNs/07SI8Ao28/0wrjfHqekRSivfZ8H2Bf4FrCD7Remt5+IiOg7zWYetqNcTHaz%0A/S/gQ5QLY7+qj4deQrnAL2V7VeALdTyN9ZoNit7F9uhpCRyqEZSnURqdZ3uE7eGUIGe7aWy7x/5s%0AXzatgUP1XWAxYAXbI4Et6YPsUqdxbgCMt72K7Rtsb9pK4CBpzt4eX0RE9Kypi2wNGH7S8PkxZsya%0Ah/WBybZ/3jCWR4Hj653+54CBwJySPgNcCryPcud/iO1LASR9B/gS8BTwODCulp8BjLF9oaRVKcc8%0AEHgG2MX2PyVdB9wCrEd5Vflu9fMRwHyS1gL+r3HQNZhZgJIpQdIw4DRgYeBpYFfbj02lfFvgUGAK%0AZaHqhl30Nx8lO7BPPY6XgFHAB4Fv1mOaAzihnsfHgTdqf1cCXwGWtP16Pa//Bs7v/AeQdAmwODAA%0AONb2yfUifmrtrx04zfYxkvalvNb9TeA+21+of6dRwC+BH9VjGEVZlPu3egzP1IW5+1KyErcAX7M9%0ARdLLwC/qOdgb+EvnMUZERN9qKvMg6ROSbpP0sqTJkqZImhFPWwwHbp/K9pHANrbXASYBW9W76PWA%0AH0tqq0G6+nUYAAAgAElEQVTBF3jnzn21zo3UFP7xta1VKRfY7zdUmcv26sA3gENtTwZG806m4bxa%0AbztJd1KmLt4PXF7LjwfOtL0ScA5wXA/lo4GNba8MbDGV/hotBqwFbMY73wb6OWAYsDzlW0LXqOUf%0AAR6r3yLaky/XczIK2FfSEMq5lO0VbK9I+SpzKI/3rlKPZ8/GRmzf2ekYXuvYJuljlCzNf9keQQma%0AdqybFwBusb1yfWU8DfvtIWmspLGTJ01s4lAiImJaNJveP4Fywb2ActHYGfhoXw2qWZJOpFwgJwMn%0AAtfYfq5ubgN+IGltyhdaCVgU+CRwccfaA0mXddH0ssAKwDWSAOYE/tmwveNtouMoF+PunFczAW11%0AfAdSLuRrUC7kAGdR7sCZSvmNwBmSzqf5N5leYvst4L66TgTKubqglv9L0rR8BeO+kraqvy8OLAM8%0AACwl6XjgCqDjnSd3A+fUbMUlLfSxAbAqcFs9//NRskRQAonfdrWT7ZOBkwGGDF22vYX+IiKiBc2u%0AecD2P4A5bU+xfTrw6b4bVrfupWQXOsa0N+VCs0gteqWh7o61fNV69/pvSqq9GW3AvfWOeITtFW1/%0AqmH76/XnFJoIwOqTKpcDazfZf+f996R8t8bilG/7HNLEbq83/N7TV4n/A/iwpAWnVknSupTpgjVq%0AFuQOYIDt54GVgesoGYZf1l0+QwmaRlICgVa+Dv3MhvO/rO3D6rZJtqc02U5ERPSBZoOHVyXNA9wp%0A6UeS9mth3970J2CApL0ayubvpu5g4Cnbb0haD1iilv8Z2FLSfPVrtjfvYt8HgEUkrQFlGkPS8B7G%0ANpGpLzBci/L9GAB/pWRyoAQ5N0ytXNLStm+xPZqyFmLxJvrryo3A1pLmqNmIdQFqFuZU4Nj6d0bS%0AInWtRaPBwPO2X5W0HOWJFyQtDMxh+7eUIGdkXV+xuO1rgYPqvgObHOcfgW0kfaC2/35JS/SwT0RE%0A9JNmA4CdKKn7fSh394tTHunrV/UOfktgHUkTJN0KnEm5OHV2DjBK0njKNMv9tY3bgfOAu4DfAbd1%0A0c9kYBvgh5LuAu4E1uxheNcCy0u6U1LHUxXb1c93A6tQnmgA+Dqway3fCfjvHsqPkjRe0j2UAOOu%0AbvrryW+BJ4D7gLMp60c61q4cQglM7qv9jKEsumz0e2AuSX+jTL/cXMsFXFfXd5xNeeRyTuDsev7v%0AAI5r9kkK2/fV8Vxdz8U1lDUcERExE2hrb8/U8HuJpIG2X65TH7dSFiX+a0aPq7cNGbps+8a7/7zn%0AihERs4HeeqtmW1vbuPb29lE91ZvqHHS9a+w2uqir6GPWMkbSQpRHIL87OwYOERHRt3pawPY5yhMK%0Aj3cqXxzIRWcWZHvdGT2GiIiYtfUUPBwDfKt+EdPb6qr8Y+h6sWFERETMxnoKHha1Pb5zoe3x9dsQ%0AI2ZKSw4d1GtzgBER8W49PW2x0FS2zdebA4mIiIhZQ0/Bw1hJX+lcKGl36vsgIiIi4r2lp2mLbwAX%0AS9qRd4KFUZSV+lt1u1dERETMtpr6nof6DY0r1I/32v5Tn44qYjrlex4iYlY1I9dr9cr3PHSoXzE8%0ALS9RioiIiNnMjHg/RURERMzCEjxERERESxI8REREREsSPERERERLmlowGbMOSYtSvjr8E8DzwGTg%0AR7Yv7sM+RwE72953Gvd/BBhne+v6eRtgM9u7SNoFOAowMDfwt9rXq70x9oiIaF0yD7MRSW3AJcCf%0AbS9le1XgC8CH+rJf22OnNXBosKqk5bvZdp7tEbaHU4Kh7aazr4iImA7JPMxe1gcm2377Cw7qS82O%0Ar+8iOQtYoG7ax/ZfJa0LHGB7MwBJJwBjbZ8h6UhgC+BN4GrbB0jaFjgUmAK8aHvtxjYkrQ4cCwwA%0AXgN2tf1AzSBsAcwPLA1cbPubDWP/MfAdYMfuDk7SXHX8z0/zGYqIiOmW4GH2Mhy4vZttTwEb2Z4k%0AaRngXMq3hXZJ0hDKt4guZ7tdUsd7TkYDG9t2Q1mj+4FP2n5T0obAD4Ct67YRwCrA68ADko633fG6%0A9/OBr0n6SBdtbidpLWAx4O/A5d2MeQ9gD4DJk3r+8rOIiJg2mbaYjUk6UdJdkm6jrBc4RdJ44AKg%0AuymCDi8Ck4BTJX0O6FhjcCNwRn3nyZxd7DcYuEDSPZS1F8Mbtv3R9ou2JwH3AUs0bJtCWdvwrS7a%0APM/2COCDwHjgwK4GbPtk26Nsj5pnwKAeDi8iIqZVgofZy73AyI4PtvcGNgAWAfYD/g2szDvvJ4Ey%0AJdH4/2BA3fdNYHXgQmAz4Pe1fE/gEGBxYFzNUDT6LnCt7RWAzTvaq15v+H0K/5n5OgtYu7b9H2y3%0AU7IOa3e1PSIi+keCh9nLn4ABkvZqKJu//hwM/NP2W8BOvJM1eBRYXtK8dRpiAwBJA4HBtq+kBB4r%0A1/Klbd9iezTwNP95oR9MeTICYJdWBm/7DUq2Yr+pVFsLeKiVdiMiondlzcNspK5N2BI4RtI3KRf3%0AV4CDKGshfitpZ0oW4ZW6z+OSzgfuASYAd9TmBgGXShoAtAH71/Kj6pqJNuCPwF3AOg3D+BFwpqRD%0AgCum4TBOpWQ2GnWseZgDeIIWg5KIiOhdTb1VM2JWk7dqRsSsalZ4q2amLSIiIqIlCR4iIiKiJVnz%0AELOlJYcOmqGpv4iI2VkyDxEREdGSBA8RERHRkgQPERER0ZIEDxEREdGSLJiM2dKEJyeyw+hrZ/Qw%0AIiKmy8y68DuZh4iIiGhJgoeIiIhoSYKHiIiIaEmCh4iIiGjJTB88SHq5i7I969sh+7rvRySNr//u%0Ak/S9+pZJJA2VdGEv9LGFpINb3OfK+vrsXiNpmKQduij/qSRLmq7/K/VcLjwN+/X6sUZExPSZJZ+2%0AsN2nr0uU1EZ55TTAerafkTQQOBn4BfAl208C20xnP3PZvgy4rJX9bG86Pf12YxiwA/DrjoIaMGwF%0APE557Xa/P77QR8caERHTYZYMHiQdBrxs+2hJ1wG3AOsBCwG72b5B0pzAkcC6wLzAibZ/UYOAS4H3%0AAXMDh9i+VNIw4Kra1qrAuy5atl+WtCfwuKT3AwsCY2yvIGk4cDowDyWbs7XtB2t25ACgHbjb9k6S%0AzgAmAasAN0q6Gxhle5+67bW67QPAl4GdgTWAW2zvUo//EWAUMBD4HfAXYE3AwGdtvybpK8AedUz/%0AAHay/Wrt46W6/weBb9q+sJ6rj0m6EzjT9jH13N0LnAdsTw0e6vn/MLBU/flT28fVbZcAiwMDgGNt%0An9zpb3cE8Jztn9bP3weeAs6v/SxI+X+5V/07dhzra7XOh4A5ge/aPo+IiOh3M/20RZPmsr068A3g%0A0Fq2G/Ci7dWA1YCvSFqScuHeyvZISsDx45ppAFgGOMn2cNuPdu7E9kvAhFqv0Z6UC+UIyoXuiRpQ%0AHAKsb3tl4L8b6n8IWNP2/l0cy/sowcJ+lIzEMcBwYEVJI7qovwwlMBoOvABsXcsvsr1a7ftv9Xx0%0AWAxYC9iMEjQAHAzcYHtEDRygBAznAhcDn5E0d0MbywEbA6sDhzZs+7LtVet52FfSkE7jPY0SEHVk%0ANr4AnE3JelxVz+HKwJ2d9vs08KTtlW2vAPy+84mQtIeksZLGTp40sYtTFRERvWF2CR4uqj/HUdLv%0AAJ8Cdq530rcAQygX2jbgB/WO/w+AgEXrPo/avrmHvtq6KLsJ+Lakg4AlbL8GrA9cYPsZANvPNdS/%0AwPaUbtq/3HY7MB74t+3xtt+iZACGdVF/gu2OC23j8a8g6QZJ44EdKQFIh0tsv2X7Pt459neRNA8l%0A+3JJDZpuoQQLHa6w/Xo9vqca2tlX0l3AzZQMxLsCLduPAM9KWoXyN7rD9rPAbcCuNauxou3OV//x%0AwEaSfijpk7Zf7Dxm2yfbHmV71DwDBnV1WBER0Qtml+Dh9fpzCu9MxbQBX6930iNsL2n7asqFdBFg%0A1XqX+29Kih3glal1ImkQ5eL898Zy278GtqCk1q+UtH4P451aPx3H8lbD7x2fu5pmaqzTePxnAPvY%0AXhE4nHeOsfM+XQVDUAKFhYDxdepgLUomott+Ja0LbAisUTMed3Tqt8MvgV2AXSmZCGz/GVibMvVy%0ARucFsbb/DoykBBHfkzS6m3FHREQfm12Ch65cBezVkU6X9FFJCwCDgadsvyFpPWCJZhqrayVOotyJ%0AP99p21LAw3Xe/1JgJeBPwLYdafu6TqI/DQL+WY9/xybqT6z7dNge2N32MNvDgCUpd/7zT6WNwcDz%0AdW3FcsAnuql3MWUaYjXK3wlJS1AyLadQgouRjTtIGgq8avts4KjO2yMiov/MCgsm55f0RMPnnzS5%0A3y8pWYLb65qGp4EtgXOAy2s6fyxwfw/tXFv3n4Ny0ftuF3U+D+wk6Q3gX8APbD9XFwNeL2kK5S58%0AlybH3hv+lzLV8HT92VMe/25gSp1yOJ9ycd+zY6PtVyT9Bdh8Km38HthT0t+AByhTF//B9mRJ1wIv%0ANEzfrAscWM/hy9R1EQ1WBI6S9BbwBrBXD8cTERF9pK29vX1GjyHeY+pCyduBbW0/2Bd9DBm6bPvG%0Au/fpE70REX2uv1+M1dbWNq69vX1UT/Vm52mLmAlJWp7y6Ogf+ypwiIiIvjUrTFvEbKQ+4bHUjB5H%0ARERMu2QeIiIioiXJPMRsacmhg/p9rjAi4r0imYeIiIhoSYKHiIiIaEmCh4iIiGhJ1jzEbGnCkxPZ%0AYXS/v0E8IqJfzai1Xck8REREREsSPERERERLEjxERERESxI8REREREsSPERERERL+jR4kPQhSZdK%0AelDSw5JOkDRvL7S7rqQxLe4zTNIODZ9HSTquh30ekTS+/rtP0vckDajbhkq6cNqO4F19bCHp4Bb3%0AuVLSQtPbd6c233V+Gsp/Ksn1TZjT0/4jkhaehv16/VgjImL69FnwIKkNuAi4xPYywDLAfMCP+rDP%0AqT16Ogx4++Joe6ztfZtodj3bKwKrU17o9Iu6/5O2t5mO4SJpLtuX2T6ylf1sb2r7henpuwvDaDg/%0A8Pars7cCHgfW6eX+mtJHxxoREdOhL7/nYX1gku3TAWxPkbQf8KikB4HlbO8DULMIR9u+TtLPgNUo%0AgcaFtg+tdT4N/BR4FfhLRyeSDgOWplzYH5P0LeAsYIFaZR/bfwWOBD4m6U7gTOAO4ADbm0kaCBwP%0AjALagcNt/7bxYGy/LGlP4HFJ7wcWBMbYXkHScOB0YB5KQLa17Qcl7QwcUNu82/ZOks4AJgGrADdK%0AuhsYZXufuu21uu0DwJeBnYE1gFts71KP+ZE61oHA7+r5WBMw8Fnbr0n6CrBHHdM/gJ1sv1r7eKnu%0A/0Hgm7Yv7Hx+bB8DrAvcC5wHbA9c23DOP1zP+YeBn9o+rm67BFgcGAAca/vkxvMo6QjgOds/rZ+/%0ADzwFnF/7WZDy/3Iv2zc0HOtrtc6HgDmB79o+j4iI6Hd9OW0xHBjXWGD7JeARph60fMf2KGAlYB1J%0AK9WpglOAzYFVKRe9RssDG9rennIh2sj2SGA7oGNq4mDgBtsj6oWx0f8CL9pe0fZKwJ+6Glgd/wRK%0AFqXRnpQL5QjKhe6JGlAcAqxve2XgvxvqfwhY0/b+XXTzPkqwsB9wGXAM5VyuKGlEF/WXAU60PRx4%0AAdi6ll9ke7Xa99+A3Rr2WQxYC9iMEjRA1+dne+Bc4GLgM5LmbmhjOWBjSkbm0IZtX7a9aj0P+0oa%0A0mm8p1ECoo7MxheAsylZj6vqOVwZuLPTfp8GnrS9su0VgN93PhGS9pA0VtLYyZMmdnGqIiKiN8yM%0ACyY/L+l2SmZgOCUwWA6YYPtB2+2Ui02jy2y/Vn+fGzhF0njggrp/TzYETuz4YPv5qdRt66LsJuDb%0Akg4ClqhjWR+4wPYztc3nGupfYHtKN+1fXo9xPPBv2+Ntv0XJAAzrov4E2x0X2nENdVaQdEM9DztS%0AzmWHS2y/Zfs+YNGuBiFpHmDTWvcl4BZKsNDhCtuv1+N7qqGdfSXdBdxMyUC8K9Cy/QjwrKRVgE8B%0Ad9h+FrgN2LVmNVa03fnqPx7YSNIPJX3S9oudx2z7ZNujbI+aZ8Cgrg4rIiJ6QV8GD/dRsgRvk7Qg%0AJWvwbKe+OxYhLklJ829QMwBXdGzrwSsNv+8H/Jty9zqKkrbvFZIGUS7Of28st/1rYAtKav1KSeu3%0AMN7OXq8/32r4veNzVxmbxjpTGuqcQZmyWRE4nHefx8Z9ugqGoAQKCwHj69TBWpRMRLf9SlqXEoit%0AUTMed9D13++XwC7ArpRMBLb/DKxNmXo5o075vM3234GRlCDie5JGdzPuiIjoY30ZPPwRmL/jIiBp%0ATuDHwAmU1P8ISXNIWpyS+oYy3/0K8KKkRYFNavn9wDBJS9fPjRexzgYD/6x36ztR5scBJgLd3Y5e%0AA+zd8UHS+zpXqOsiTqLciT/fadtSwMN13v9SypTLn4BtO9L2dZ1EfxoE/LNOJ+zYRP3O52d7YHfb%0Aw2wPA5ak3PnPP5U2BgPP17UVywGf6KbexZRpiNWAqwAkLUHJtJxCCS5GNu4gaSjwqu2zgaM6b4+I%0AiP7TZ8FDTb1vBWxTF0g+C7xl+/vAjZQA4j7KmoTb6z53Ue5W7wd+XethexJl8d8VdUrjqal0fRLw%0ApZo6X4537vLvBqZIuqsu3Gz0PeB9ku6p+zW+aeRaSfcAtwKPAV/tos/PA/fUxYYrAL+yfS/wfeD6%0A2uZPpjLmvvC/lKmGGynnsyeN5+c7lIv7FR0bbb9CWZi5+VTa+D0lA/E3ylqKm7uqZHsyZfHl+Q3T%0AN+sCd0m6g7JW5dhOu60I3FrP8aGUv1lERMwAbe3t7f3SkaQ1KYvvtrJ9e790GjOlulDydmBb2w/2%0ARR9Dhi7bvvHuP++LpiMiZhq9/VbNtra2ce3t7aN6qtdvr+Suj0su0V/9xcxJ0vLAGODivgocIiKi%0Ab/Vb8BABUJ/wWGpGjyMiIqbdzPioZkRERMzEknmI2dKSQwf1+lxgREQUyTxERERESxI8REREREsS%0APERERERLsuYhZksTnpzIDqOvndHDiIiYLjPr2q1kHiIiIqIlCR4iIiKiJQkeIiIioiUJHiIiIqIl%0ACR4iIiKiJQkeepGkl3uhjaGSLpzK9oUkfa3Z+rXOdZIeqK/bvk3SiOkdZ2+SdISkDWf0OCIiojkJ%0AHmYytp+0vc1UqiwEfK2F+h12tL0ycBJw1HQOEwBJvfKor+3Rtv/QG21FRETfy/c89DFJw4DTgIWB%0Ap4FdbT8maWngHGAB4FLgG7YH1vpjbK8gaThwOjAPJdDbGvgusLSkO4FrgBMb6s8J/BD4NPAWcIrt%0A4zsN6SbgwIbxfQo4HJgXeKiO72VJmwI/AV4BbgSWsr2ZpMOApSlvxnxM0heBI4F1axsn2v6FpMWA%0A84AFKf/P9gL+CpwKjALagdNsHyPpjHoMF0raADi67nMbsJft1yU9ApwJbA7MDWxr+/6W/yARETHd%0Aknnoe8cDZ9peiRIsHFfLjwWOtb0i8EQ3++5Z64ygXHCfAA4GHrI9wvaBnervAQwDRjT019mngUsA%0AJC0MHAJsaHskMBbYX9IA4BfAJrZXBRbp1MbydZ/tgd2AF22vBqwGfEXSksAOwFV17CsDdwIjANle%0AoR736Y2N1n7PALar2zuCjg7P1HH+DDig84FJ2kPSWEljJ0+a2MWhR0REb0jw0PfWAH5dfz8LWKuh%0A/IL6+68771TdBHxb0kHAErZf66GvDYFf2H4TwPZzDdvOkTQB+A4lWwHwCUogcGPNZHwJWAJYDnjY%0A9oRa79xO/VzWMJZPATvX/W8BhgDLULIGu9ZMxYq2JwIPA0tJOl7Sp4GXOrW7LDDB9t/r5zP/v707%0Aj5WrrMM4/r1lDVBFlgB92MNSy1Ism8GERWMAUVuUpbWCxY1FthBIJYp/iCYqoIAVCTRCEKWAgCtr%0AiOyCUKClbIKg0EcCUrSyiAgd/3jP1emly5wrM3MuPJ/kZmbOnDvnmdM7Pb953/ecF9i97fkrq9vZ%0AlCJpMbbPs72T7Z1WXnX0EndQRET8/9Jt0WC2fyrpLmA/4GpJh1MOwMMxlXLQPY3SGvIJYAC4oWpB%0A+K8OBlS+3HZ/ADjG9nVDV5K0e5X9QknftX2RpPHA3pRWlYOAz9Z4D/+qbt8gf7sREX2TlofuuwOY%0AXN2fCtxa3b+TMoaBtucXI2lzSgvA2ZRxEdsDLwJL+1p9A3D44EBGSWu1P2m7BZwCvF/S2CrDByRt%0AUa2/uqStgEcpLQSbVr968DLe33XAkZJWql5jq+p1NgGetX0+MBOYUHWTjLJ9BaW7ZMKQ13oU2HQw%0AD3AIcPMyth0REX2Q4uGttZqk+W0/JwDHUJrv51IOhsdV6x5PGV8wF9gCWLiE1zsImFd1CWwLXGR7%0AAaWbYZ6koWdNzASeAuZKmkMZd7CYqrvhDOAk238FpgGXVDl+B4yt1jkKuFbSbErBsqR8g9t8CLhX%0A0jzKWIkVKQMo50i6j1J8nAUIuKl6PxcDJw/J9ipwGHC5pAcogz7PXcp2IyKiTwZarVa/M7wjSVoN%0A+KftlqTJwBTbE/uda5CkNaqzLgYoYyQes/29fufq1Npjtm7t/fnUHRExsvV6Vs2BgYHZrVZrp+Wt%0Al37j/tkRmFEdnP9Ovb7/XviCpM9QThO9j9KiEBERkeKhX2zfSjmFsZGqVoYR09IQERG9kzEPERER%0AUUtaHuJtabMxo3veVxgR8U6RloeIiIioJWdbxNvSwMDAi5TrRjTSqFGj1lm0aNHz/c6xJMk2PMk2%0APE3OBs3O16Vsm7RaraFTErxJui3ibWnMmDGP2l7u6Ub9IumepuZLtuFJtuFpcjZodr5+Zku3RURE%0ARNSS4iEiIiJqSfEQb1fn9TvAcjQ5X7INT7INT5OzQbPz9S1bBkxGRERELWl5iIiIiFpSPEREREQt%0AOVUzRjRJ+1Cm+14BmGn7W0OeH6ie/wjwCjDN9r0NyTYWuACYAHzF9um9yNVhtqnAdGCAMiX7kbbn%0ANCjfROBUyrTtrwPH276tCdna1tuZMs39ZNs/a0I2SXsCvwCerBZdafvrTcjWlu9MYCXgedt7NCGb%0ApJOAqdXDFYH3AuvafqEB2d4NXAxsXGU73fYF3c6VlocYsSStQJkufF9gHDBF0rghq+0LbFn9fBH4%0AYYOyvQAcC/SsaKiR7UlgD9vbUQ7SPRuY1WG+G4HxtnegzEg7s0HZBtf7NnB9L3LVyQbcanuH6qdX%0AhcNys0laEzgH+LjtbYADm5LN9mmD+ww4Gbi5R4VDJ/+mXwIesj0e2BM4Q9LK3c6W4iFGsl2Ax20/%0AYfs1YBYwccg6E4GLbLds3wmsKWmDJmSz/Zztu4F/9yBP3Wx32P5b9fBOYMOG5XvJ9uBo79WBXo38%0A7uRvDuAY4ArguR7lqpOtHzrJ9ilKS8hTUD4fDcrWbgpwSU+SdZatBYyuWlnXoHwpeb3bwVI8xEgm%0A4Om2x/OrZXXX6YZ+bbcTdbN9Drimq4kW11E+SftLegT4DaX1oRHZJAnYnx61crVvms7+XXeTNFfS%0ANZK26U20jrJtBbxH0k2SZks6tEHZyorSasA+lMKwFzrJNoPSjfIX4AHgONuLuh0sxUNELJWkvSjF%0Aw/R+ZxnK9lW2xwKTKF0rTXEmML0X/4EPw73Axra3B74P/LzPedqtCOwI7AfsDZwiaav+RnqTjwG3%0A96LLooa9gfuBMcAOwAxJ7+r2RlM8xEhmYKO2xxtWy+qu0w392m4nOsomaXvKWIKJthf0KBvU3He2%0AbwE2l7ROt4PRWbadgFmS/gQcAJwjaVITstn+h+2XqvtXAys1aL/NB66z/bLt54FbgPENyTZoMr3r%0AsoDOsh1G6e5p2X6cMl5pbLeD5WyLGMnuBraUtBnlAzWZ0m/a7pfA0ZJmAbsCC20/05Bs/bLcbJI2%0ABq4EDrH9hwbm2wL4o+2WpAnAKkAvCpzlZrO9WVvOC4Ff2+7FN/xO9tv6wLPVftuF8gWyEfuNchbI%0ADEkrAitTPq/fa0i2wbMa9gA+3YNMdbI9BXwIuFXSesDWwBPdDpaWhxixbL8OHA1cBzwMXGb7QUlH%0ASDqiWu1qygfpceB84KimZJO0vqT5wAnAVyXN70VzY4f77WvA2pRvzfdLuqfbuWrm+yQwT9L9lNHo%0AB7cNoOx3tr7oMNsBlP02BzibchppI/ab7YeBa4G5wO8ppyXOa0K2yv7A9bZf7nammtlOpYxjeYBy%0AFtL0quWmq3J56oiIiKglLQ8RERFRS4qHiIiIqCXFQ0RERNSS4iEiIiJqSfEQERERtaR4iIhYBkmT%0AJLWqWVAjghQPERHLMwW4rbrtimr2xIgRI9d5iIhYCklrAI8CewG/sr11tXw65UqDi4BrbH+5uurl%0AucC6wBuUKaU3Ak60/dHq92YA99i+sLp89aXAh4HvAKMp08avTLmo2SG2X6muGngusHkV60jK5Ewv%0A2D6zet1vAs/ZPqub+yNiUFoeIiKWbiJwbXWJ7gWSdpS0b7V8V9vjKQd+gJ8AP6iW7QZ0chn0BbYn%0A2J5FmZ9g5+r3H6ZMSAblSpA3V8snAA8CPwIOBZA0inLZ4ovfgvcb0ZHMbRERsXRTgMFv87OqxwPA%0ABbZfAbD9gqTRgGxfVS17FaDMzr1Ml7bd31bSN4A1gTUolyQG+CBVoWD7DWAhsFDSAknvA9YD7uvx%0A5GXxDpfiISJiCSStRTlwbyepBawAtIDLa7zM6yzewrvqkOfb50m4EJhke46kacCey3ntmcA0YH1K%0AS0REz6TbIiJiyQ4Afmx7E9ub2t6IMt3xQuAwSatBKTJsvwjMH5x6W9Iq1fN/BsZVj9ekzH64NKOB%0AZyStBExtW34jZZwDklaoZncEuIoy9mFn/tdKEdETKR4iIpZsCuUA3e4KYAPKVO/3VLN6nlg9dwhw%0ArKS5wB3A+rafBi4D5lW39y1je6cAdwG3A4+0LT8O2KuaNXE2MA7A9mvAbykzLb4x3DcZMRw52yIi%0AYgwuslsAAABPSURBVASqBkreCxxo+7F+54l3lrQ8RESMMJLGUU7nvDGFQ/RDWh4iIiKilrQ8RERE%0ARC0pHiIiIqKWFA8RERFRS4qHiIiIqCXFQ0RERNTyHzshv6VbSSLWAAAAAElFTkSuQmCC%0A"></p>
<p>根据这幅图，第三次提交时我选用了效果相对较好的 SVC 分类器。</p>
<h3 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h3><h4 id="特征工程-1"><a href="#特征工程-1" class="headerlink" title="特征工程"></a>特征工程</h4><blockquote>
<p>特征工程的意义是找一个更好的空间去重构表达，把原始的数据对象映射到这个空间去表达，更便于你的应用。比如分类应用，最好是找到线性可分的空间。<br>    – <a href="https://www.zhihu.com/question/41659582">Stark Einstein</a></p>
</blockquote>
<h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><p>在上述代码中我们基本没有进行数据可视化，一是因为这次的数据还是比较容易去分析，不太需要数据可视化；二是我对 matplotlib、seaborn 的使用还不太熟练。</p>
<p>实际上，数据可视化是数据科学的核心技术之一。有效的数据可视化可以帮助深入地研究变量，因此通过数据可视化来对数据集和单独的特征进行了解应该成为机器学习项目的第一步。如果想要了解如何在这个项目中使用数据可视化进行分析，可以在最下面的参考资料中查看别人的方案；如果想全面的学习数据可视化，Kaggle 也提供了数据可视化的<a href="https://www.kaggle.com/learn/data-visualisation">课程</a>。</p>
<h4 id="关于缺失值"><a href="#关于缺失值" class="headerlink" title="关于缺失值"></a>关于缺失值</h4><p>不同的机器学习模型对缺失值的敏感度不同。实际上，xgboost 对缺失值有默认的处理方法。根据作者 Tianqi Chen 在论文中的介绍，xgboost 把缺失值当做稀疏矩阵来对待，本身的在节点分裂时不考虑的缺失值的数值。缺失值数据会被分到左子树和右子树分别计算损失，选择较优的那一个。如果训练中没有数据缺失，预测时出现了数据缺失，那么默认被分类到右子树。</p>
<p>根据知乎上<a href="https://www.zhihu.com/question/58230411">怎么理解决策树、xgboost能处理缺失值？而有的模型(svm)对缺失值比较敏感呢?</a>问题赞同数最高的回答，有一些经验法则可供参考：</p>
<ol>
<li>树模型对于缺失值的敏感度较低，大部分时候可以在数据有缺失时使用。</li>
<li>涉及到距离度量（distance measurement）时，如计算两个点之间的距离，缺失数据就变得比较重要。因为涉及到“距离”这个概念，那么缺失值处理不当就会导致效果很差，如 K 近邻算法（KNN）和支持向量机（SVM）。</li>
<li>线性模型的代价函数（loss function）往往涉及到距离（distance）的计算，计算预测值和真实值之间的差别，这容易导致对缺失值敏感。</li>
<li>神经网络的鲁棒性强，对于缺失数据不是非常敏感，但一般没有那么多数据可供使用。</li>
<li>贝叶斯模型对于缺失数据也比较稳定，数据量很小的时候首推贝叶斯模型。</li>
</ol>
<p>总结来看，对于有缺失值的数据在经过缺失值处理后：</p>
<ul>
<li>数据量很小，用朴素贝叶斯</li>
<li>数据量适中或者较大，用树模型，优先 xgboost</li>
<li>数据量较大，也可以用神经网络</li>
<li>避免使用距离度量相关的模型，如 KNN 和 SVM</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>亲自参加一次比赛才发觉 Kaggle 是好文明，像我这种菜鸡可以通过高质量的比赛了解到数据分析的很多基本流程和方法，收获的经验远不是书上例题所能比的。而且社区讨论里面个个都是人才，分享的经验技巧又干货满满，我超喜欢里面的。</p>
<p>这篇博文主要整理一开始所用的基本方法，以及通过特征工程实现的改良。下一步我打算试着去用模型集成去进一步提高预测准确率，并且进行总结。</p>
<p><strong>18.03.25 补充：</strong>尝试了模型集成，但是效果没有提升（反而降了），猜想是因为 xgboost 的效果已经足够好。系列的下篇搁置中…</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/31743196">Kaggle Titanic 生存预测 – 详细流程吐血梳理</a>：推荐阅读第四部分“变量转换”</li>
<li><a href="https://zhuanlan.zhihu.com/p/33733586">Kaggle Titanic 生存预测(Top1.4%)完整代码分享</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27550334">分分钟，杀入Kaggle TOP 5% 系列（1）</a></li>
<li><a href="https://www.kaggle.com/sinakhorami/titanic-best-working-classifier">Titanic best working Classifier | Kaggle</a></li>
</ul>
<p>最后推荐一下这个 kernel：<a href="https://www.kaggle.com/kanncaa1/data-sciencetutorial-for-beginners/notebook">Data ScienceTutorial for Beginners
</a>。包含了包括数据可视化、Python 基本语法、pandas 基本用法等 Kaggle 比赛所需要的基础知识。很全面，而且主要的数据集是精灵宝可梦数据，加分。</p>
]]></content>
      <categories>
        <category>机器学习笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
        <tag>Kaggle</tag>
        <tag>Titanic 生存预测</tag>
      </tags>
  </entry>
  <entry>
    <title>《利用Python进行数据分析》笔记</title>
    <url>/blog/python-for-data-analysis-notes/</url>
    <content><![CDATA[<p>《利用Python进行数据分析》是一本非常不错的 Cookbook。早在去年年底的时候我就一边看一边记录一遍敲代码，阅读完比较重要的章节，整理了这篇笔记。有时候有些 API 忘记了，就翻看查找，比直接看 pdf 要方便。现在为了查找更方便，将这篇笔记迁移到博客上来。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="Python-的优点"><a href="#Python-的优点" class="headerlink" title="Python 的优点"></a>Python 的优点</h3><ul>
<li>动态编程（解释型语言）</li>
<li>科学计算社区活跃，有不断改良的库</li>
<li>胶水语言，轻松集成 C、C++ 以及 Fortran 代码</li>
<li>同时适用于研究和原型构建及构件生产系统</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>运行速度慢</li>
<li>Python 有全局解释器锁（GIL），防止解释器同时执行多条 Python 字节码指令的机制。因此，多线程并行代码不能在单个 Python 进程中执行。</li>
</ul>
<h3 id="重要的-Python-库"><a href="#重要的-Python-库" class="headerlink" title="重要的 Python 库"></a>重要的 Python 库</h3><h4 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h4><p>科学计算基础包，提供快速的<strong>数组处理</strong>能力，并作为在算法之间传递数据的容器（<code>ndarray</code>）。</p>
<h4 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h4><p>一组专门解决<strong>科学计算</strong>中各种标准问题域的包的集合。</p>
<h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>针对<strong>数据分析和预处理</strong>，提供快速<strong>处理结构化数据</strong>的大量数据结构和函数。</p>
<h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><p>提供好用的交互式数据绘图环境，<strong>绘制交互式图表</strong>。</p>
<h4 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h4><p>一个增强的 Python shell，以提高编写、测试、调试 Python 代码的速度。主要用于<strong>交互式数据处理</strong>和<strong>利用 matplotlib 对数据进行可视化处理</strong>。</p>
<p>除开标准的基于终端的 IPython shell 外，还提供了：</p>
<ul>
<li>一个 HTML 笔记本；</li>
<li>一个基于 Qt 框架的 GUI 控制台；</li>
<li>用于交互式并行和分布式计算的基础架构。</li>
</ul>
<h3 id="引入惯例"><a href="#引入惯例" class="headerlink" title="引入惯例"></a>引入惯例</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<p><code>np.arange</code>引用的即是 NumPy 中的 arange 函数。在 Python 软件开发过程中，不建议直接引入类似 NumPy 这种大型库的全部内容（<code>from numpy import *</code>）。</p>
<h2 id="IPython：一种交互式计算和开发环境"><a href="#IPython：一种交互式计算和开发环境" class="headerlink" title="IPython：一种交互式计算和开发环境"></a>IPython：一种交互式计算和开发环境</h2><p>IPython 本身并没有提供任何的计算或数据分析功能，其设计目的是在交互式计算和软件开发这两个方面最大化地提高生产力。由于大部分的数据分析代码都含有<strong>探索式操作</strong>（试误法和迭代法），因此 IPython 将有助于提高工作效率。</p>
<h3 id="Tab-键自动完成"><a href="#Tab-键自动完成" class="headerlink" title="Tab 键自动完成"></a>Tab 键自动完成</h3><p>Tab 键自动完成功能不只可以用于搜索命名空间和自动完成对象和模块属性，还可以匹配路径（输入正斜杠<code>/</code>后）。</p>
<h3 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h3><p>在变量的前面或后面加上一个问号（<code>?</code>）可以显示有关该对象的一些通用信息，这叫做<strong>对象内省（object introspection）</strong>。</p>
<p>如果该对象是一个函数或实例方法，则其 docstring（如果有的话）也会被显示出来。使用<code>??</code>还将显示出该函数的源代码（如果可能的话）。</p>
<p>另外，<code>?</code>还可以用于<strong>搜索 IPython 命名空间</strong>，一些字符再配以通配符（<code>*</code>）即可显示出所有与该通配符表达式相匹配的名称：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br><span class="line">np.pkgload</span><br></pre></td></tr></table></figure>

<h3 id="run-命令"><a href="#run-命令" class="headerlink" title="%run 命令"></a>%run 命令</h3><p>在 IPython 环境中，可以通过 <strong><code>%run</code>命令将文件当作 Python 程序</strong>来运行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: %run ipython_script_test.py</span><br></pre></td></tr></table></figure>

<p>脚本是在一个空的命名空间中运行的（没有任何 import，也没有定义任何其他的变量），所以其行为应该跟在标准命令行环境中一样。</p>
<p>如果希望脚本能够访问在交互式 IPython 命名空间中定义的变量，应该使用<code>%run -i</code>。</p>
<h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><p>挑选一些不太熟又有些实用的：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl + A</td>
<td align="left">将光标移动到行首</td>
</tr>
<tr>
<td align="left">Ctrl + E</td>
<td align="left">将光标移动到行尾</td>
</tr>
<tr>
<td align="left">Ctrl + U</td>
<td align="left">删除从光标开始至行首的文本</td>
</tr>
<tr>
<td align="left">Ctrl + K</td>
<td align="left">删除从光标开始至行尾的文本</td>
</tr>
<tr>
<td align="left">Ctrl + L</td>
<td align="left">清屏</td>
</tr>
</tbody></table>
<h3 id="魔术命令（Magic-Command）"><a href="#魔术命令（Magic-Command）" class="headerlink" title="魔术命令（Magic Command）"></a>魔术命令（Magic Command）</h3><p><strong>魔术命令</strong>是以百分号<code>%</code>为前缀的命令，为常见任务提供便利，或者让用户轻松控制 IPython 系统的行为。</p>
<p>例如，通过<code>%timeit</code>这个魔术命令可以检测任意 Python 语句（如矩阵乘法）的执行时间（多次执行计算平均执行时间，用于评估执行时间非常小的代码）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a = np.random.randn(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: %timeit np.dot(a, a)</span><br><span class="line">The slowest run took <span class="number">2714.09</span> times longer than the fastest. This could mean that an intermediate result <span class="keyword">is</span> being cached.</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">41.9</span> µs per loop</span><br></pre></td></tr></table></figure>

<p>魔术命令可以看作运行于 IPython 系统中的命令行程序。它们大都还有一些“命令行选项”，使用<code>?</code>即可查看其选项。例如：<code>%reset?</code></p>
<p>魔术命令默认是可以不带百分号使用的，只要没有定义与其同名的变量即可。这个技术叫做 automagic，可以通过<code>%automagic</code>打开或关闭。</p>
<p>输入<code>%quickref</code>或<code>%magic</code>可以直接访问文档。</p>
<p>更多常用的 IPython 魔术命令可见原书 p58（pdf p69）。</p>
<h3 id="基于-Qt-的富-GUI-控制台"><a href="#基于-Qt-的富-GUI-控制台" class="headerlink" title="基于 Qt 的富 GUI 控制台"></a>基于 Qt 的富 GUI 控制台</h3><p>IPython 团队开发了一个基于 Qt 框架（目的是为终端应用程序提供诸如内嵌图片、多行编辑、语法高亮等富文本编辑功能）的 GUI 控制台。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipython qtconsole --pylab=inline</span><br></pre></td></tr></table></figure>

<h3 id="matplotlib-集成与-pylab-模式"><a href="#matplotlib-集成与-pylab-模式" class="headerlink" title="matplotlib 集成与 pylab 模式"></a>matplotlib 集成与 pylab 模式</h3><p>IPython 对各个 GUI 框架进行了专门的处理以使其能够和 shell 配合得天衣无缝。通常我们通过以下命令来在启动 IPython 时集成 matplotlib：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipython --pylab</span><br></pre></td></tr></table></figure>

<h3 id="交互式调试器"><a href="#交互式调试器" class="headerlink" title="交互式调试器"></a>交互式调试器</h3><p>IPython 紧密集成并加强了 Python 内置的 pdb 调试器。发生异常后马上输入<code>%debug</code>命令将会调用那个“事后”调试器，并直接跳转到引发异常的那个栈帧（stack frame）。</p>
<p>在这个调试器中，可以执行任意 Python 代码并查看各个栈帧中的一切对象和数据。默认是从最低级开始的（即错误发生的地方）。输入<code>u</code>和<code>d</code>即可在栈跟踪的各级别之间切换。</p>
<p>执行<code>%pdb</code>命令可以让 IPython 在出现异常之后自动调用调试器。</p>
<p>更多请查看原书 p67（pdf p78）。</p>
<h3 id="基本性能分析：-prun和-run-p"><a href="#基本性能分析：-prun和-run-p" class="headerlink" title="基本性能分析：%prun和%run -p"></a>基本性能分析：<code>%prun</code>和<code>%run -p</code></h3><p>代码的性能分析跟代码执行时间密切相关，但更关注耗费时间的位置。主要的 Python 性能分析工具是 <strong>cProfile 模块</strong>，它在执行一个程序或代码块时，会记录各函数所耗费的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m cProfile cprof_example.py</span><br></pre></td></tr></table></figure>

<p>这样执行输出的结果会按照函数名排列。通常会再用<code>-s</code>标记指定一个排序规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m cProfile -s cprof_example.py</span><br></pre></td></tr></table></figure>

<p>除命令行用法之外，cProfile 还可以编程的方式分析人意代码块的性能。<code>%prun</code>的格式跟 cProfile 差不多，但它分析的是 Python 语句而不是整个 .py 文件：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: %prun -l <span class="number">7</span> -s cumulative run_expriment()</span><br></pre></td></tr></table></figure>

<p>执行<code>%run -p -s cumulative cprof_example.py</code>也能达到上面那条系统命令行命令一样的效果，但无需退出 IPython。</p>
<p>关于逐行分析函数性能，查看原书 p74（pdf p85）。</p>
<h3 id="IPython-HTML-Notebook"><a href="#IPython-HTML-Notebook" class="headerlink" title="IPython HTML Notebook"></a>IPython HTML Notebook</h3><p>IPython Notebook 是一种基于 Web 技术的交互式计算文档格式。通过下面这条命令即可启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipython notebook --pylab=inline</span><br></pre></td></tr></table></figure>

<h2 id="NumPy-基础：数组和矢量计算"><a href="#NumPy-基础：数组和矢量计算" class="headerlink" title="NumPy 基础：数组和矢量计算"></a>NumPy 基础：数组和矢量计算</h2><p>NumPy 是高性能科学计算和数据分析的基础包，其部分功能如下：</p>
<ul>
<li>ndarray，一个具有矢量算数运算和复杂广播能力的快速且节省空间的多位数组。</li>
<li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li>
<li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li>
<li>线性代数、随机数生成以及傅立叶变换功能。</li>
<li>用于集成由 C、C++、Fortran 等语言编写的代码的工具。</li>
</ul>
<h3 id="ndarray：一种多维数组对象"><a href="#ndarray：一种多维数组对象" class="headerlink" title="ndarray：一种多维数组对象"></a>ndarray：一种多维数组对象</h3><p>ndarray 是一个通用的<strong>同构数据多维容器</strong>，也就是说，其中的所有元素必须是相同类型的。</p>
<h4 id="几种属性"><a href="#几种属性" class="headerlink" title="几种属性"></a>几种属性</h4><ul>
<li>array.ndim # 维度</li>
<li>array.shape # 行数和列数</li>
<li>array.size # 元素个数</li>
</ul>
<h3 id="创建-ndarray"><a href="#创建-ndarray" class="headerlink" title="创建 ndarray"></a>创建 ndarray</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">array</td>
<td align="left">将输入数据（列表、元组、数组和其他序列类型）转换为 ndarray。默认直接复制输入数据</td>
</tr>
<tr>
<td align="left">asarray</td>
<td align="left">将输入转换为 ndarray，如果输入本身就是一个 ndarray 就不进行复制</td>
</tr>
<tr>
<td align="left">arange</td>
<td align="left">类似于内置的 range，但返回一个 ndarray 而非列表</td>
</tr>
<tr>
<td align="left">ones</td>
<td align="left">根据指定的形状和 dtype 创建一个全 1 数组</td>
</tr>
<tr>
<td align="left">ones_like</td>
<td align="left">以另一个数组为参数，并根据其形状和 dtyoe 创建一个全 1 数组</td>
</tr>
<tr>
<td align="left">zeros、zeros_like</td>
<td align="left">类似于 ones 和 ones_like，产生全 0 数组</td>
</tr>
<tr>
<td align="left">empty、empty_like</td>
<td align="left">创建新数组，只分配内存空间但不填充任何值</td>
</tr>
<tr>
<td align="left">eye、identity</td>
<td align="left">创建一个正方的 N*N 单位矩阵（对角线为 1，其余为 0）</td>
</tr>
</tbody></table>
<h3 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h3><p>将一个标量值赋值给一个切片时，该值会自动传播到整个选区。跟列表最重要的区别在于，数组切片是原始数组的<strong>视图</strong>，这意味着数据不会被复制，<strong>视图上的任何修改都会直接反映到源数组上</strong>。如果想要得到 ndarray 切片的一份副本而非视图，就需要显式地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
<h3 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h3><p>跟算术运算一样，数组的比较运算（如<code>==</code>）也是矢量化的。因此有：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: names = np.array([<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>,<span class="string">&#x27;Will&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Will&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>,<span class="string">&#x27;Joe&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: names == <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">Out[<span class="number">63</span>]: array([ <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure>

<p>生成的布尔型数组可用于数组索引，并和切片、整数等混合使用。</p>
<p>要选择除某值以外的其他值，既可以使用不等于符号（<code>!=</code>），也可以通过负号（<code>-</code>）对条件进行否定。选取多个名字需要组合应用多个布尔条件，使用<code>&amp;</code>（和）、<code>|</code>（或）之类的布尔算术运算符即可。<strong>Python 关键字 and 和 or 在布尔型数组中无效</strong>。</p>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的<strong>副本</strong>。</p>
<h3 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h3><p><strong>花式索引（Fancy indexing）</strong>是一个 NumPy 术语，指利用整数数组进行索引。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">64</span>]: arr = np.empty((<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">65</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    ...:     arr[i] = i</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: arr</span><br><span class="line">Out[<span class="number">66</span>]:</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>,  <span class="number">7.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: arr[[<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>]]</span><br><span class="line">Out[<span class="number">67</span>]:</span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>,  <span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: arr[[-<span class="number">3</span>,-<span class="number">5</span>,-<span class="number">7</span>]]</span><br><span class="line">Out[<span class="number">68</span>]:</span><br><span class="line">array([[ <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<p>花式索引和切片不一样，它总是将数据复制到新数组中。</p>
<h3 id="数组转置和轴对换"><a href="#数组转置和轴对换" class="headerlink" title="数组转置和轴对换"></a>数组转置和轴对换</h3><p>简单的转置可以使用<code>.T</code>，其实就是进行轴对换：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: arr.T</span><br><span class="line">Out[<span class="number">71</span>]:</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">28</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">9</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">29</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">26</span>, <span class="number">30</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">27</span>, <span class="number">31</span>]])</span><br></pre></td></tr></table></figure>

<p>对于高维数组，<code>transpose</code>需要得到一个由轴编号组成的元祖才能对这些轴进行转置：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: arr</span><br><span class="line">Out[<span class="number">75</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line">Out[<span class="number">76</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>

<p>ndarray 还有一个<code>swapaxes</code>方法，需要接受一对轴编号：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: arr</span><br><span class="line">Out[<span class="number">77</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: arr.swapaxes(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">78</span>]:</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">4</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">15</span>]]])</span><br></pre></td></tr></table></figure>

<p>对于一维数组（序列），普通的转置操作可能无法对其进行转置，此时需要借助其他的函数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: A</span><br><span class="line">Out[<span class="number">10</span>]: array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: A.T</span><br><span class="line">Out[<span class="number">11</span>]: array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: A[np.newaxis,:]</span><br><span class="line">Out[<span class="number">13</span>]: array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: A[:,np.newaxis]</span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>],</span><br><span class="line">       [<span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<p>转置返回的都是源数据的<strong>视图</strong>（不会进行任何复制操作）。</p>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul>
<li><code>np.vstack((A, B))</code>：上下合并；</li>
<li><code>np.hstack((A, B))</code>：左右合并；</li>
<li><code>np.concatenate()</code>：合并操作针对多个矩阵或序列，用<code>np.concatenate()</code>会更加方便。可以用一个<code>axis</code>参数控制合并方向。</li>
</ul>
<h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><p><strong>通用函数（即 ufunc）</strong>是一种对 ndarray 中的数据执行元素级运算的函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: arr = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: np.sqrt(arr)</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">array([ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">1.41421356</span>,  <span class="number">1.73205081</span>,  <span class="number">2.</span>        ,</span><br><span class="line">        <span class="number">2.23606798</span>,  <span class="number">2.44948974</span>,  <span class="number">2.64575131</span>,  <span class="number">2.82842712</span>,  <span class="number">3.</span>        ])</span><br></pre></td></tr></table></figure>

<h4 id="一元-ufunc"><a href="#一元-ufunc" class="headerlink" title="一元 ufunc"></a>一元 ufunc</h4><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abs</td>
<td align="left">计算整数、浮点数或复数的绝对值</td>
</tr>
<tr>
<td align="left">fabs</td>
<td align="left">更快地计算非复数的绝对值</td>
</tr>
<tr>
<td align="left">sqrt</td>
<td align="left">计算个元素的平方根</td>
</tr>
<tr>
<td align="left">square</td>
<td align="left">计算各元素的平方</td>
</tr>
<tr>
<td align="left">exp</td>
<td align="left">计算各元素的指数 e ** x</td>
</tr>
<tr>
<td align="left">log、log10、log2、log1p</td>
<td align="left">分别为自然对数（底数为 e）、底数为 10 的 log、底数为 2 的 log、log(1 + x)</td>
</tr>
<tr>
<td align="left">sign</td>
<td align="left">计算各元素的正负号：1（正数）、0（零）、-1（负数）</td>
</tr>
<tr>
<td align="left">ceil</td>
<td align="left">计算各元素的 ceiling 值，即大于等于该值的最小整数</td>
</tr>
<tr>
<td align="left">floor</td>
<td align="left">计算各元素的 floor 值，即小于等于该值的最大整数</td>
</tr>
<tr>
<td align="left">rint</td>
<td align="left">将各元素四舍五入到最接近的整数，保留 dtype</td>
</tr>
<tr>
<td align="left">modf</td>
<td align="left">将数组的小数和整数部分以两个独立数组的形式返回</td>
</tr>
<tr>
<td align="left">logical_not</td>
<td align="left">计算各元素 not x 的真值。相当于 -arr</td>
</tr>
</tbody></table>
<h4 id="二元-ufunc"><a href="#二元-ufunc" class="headerlink" title="二元 ufunc"></a>二元 ufunc</h4><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">add</td>
<td align="left">将数组中对应的元素相加</td>
</tr>
<tr>
<td align="left">subtract</td>
<td align="left">从第一个数组中减去第二个数组中的元素</td>
</tr>
<tr>
<td align="left">multiply</td>
<td align="left">数组元素相乘</td>
</tr>
<tr>
<td align="left">divide、floor_divide</td>
<td align="left">除法或向下圆整除法（丢弃余数）</td>
</tr>
<tr>
<td align="left">power</td>
<td align="left">对第一个数组中的元素 A，根据第二个数组中的相应元素 B，计算 A ** B</td>
</tr>
<tr>
<td align="left">mod</td>
<td align="left">元素级的求模计算（除法的余数）</td>
</tr>
<tr>
<td align="left">greater、greater_equal、less、less_equal、equal、not_equal</td>
<td align="left">执行元素级的比较运算，最终产生布尔型数组</td>
</tr>
<tr>
<td align="left">logical_and、logical_or、logical_xor</td>
<td align="left">执行元素级的真值逻辑运算。相当于中缀运算符<code>&amp;</code>、`</td>
</tr>
</tbody></table>
<h3 id="利用数组进行数据处理"><a href="#利用数组进行数据处理" class="headerlink" title="利用数组进行数据处理"></a>利用数组进行数据处理</h3><p>NumPy 数组可以将许多种数据处理任务表述为简洁的数组表达式，使运算速度快上一两个数量级。这种做法通常被称为<strong>矢量化</strong>。</p>
<h4 id="将条件逻辑表述为数组运算"><a href="#将条件逻辑表述为数组运算" class="headerlink" title="将条件逻辑表述为数组运算"></a>将条件逻辑表述为数组运算</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: xarr = np.array([<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: yarr = np.array([<span class="number">2.1</span>, <span class="number">2.2</span>, <span class="number">2.3</span>, <span class="number">2.4</span>, <span class="number">2.5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: cond = np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: result = np.where(cond, xarr, yarr)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: result</span><br><span class="line">Out[<span class="number">18</span>]: array([ <span class="number">1.1</span>,  <span class="number">2.2</span>,  <span class="number">1.3</span>,  <span class="number">1.4</span>,  <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure>

<p><code>np.where</code>的第二个和第三个参数不必是数组，它们都可以是标量值。</p>
<h3 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h3><p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。<code>sum</code>、<code>mean</code>以及标准差<code>std</code>等聚合计算既可以当做数组的实例方法（<code>arr.mean()</code>）调用，也可以当做顶级 NumPy 函数使用（<code>np.mean(arr)</code>）。</p>
<p><code>mean</code>和<code>sum</code>这类的函数可以接受一个 axis 参数（用于计算该轴向上的统计值），最终结果是一个少一维的数组。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sum</td>
<td align="left">对数组中全部或某轴向的元素求和。零长度的数组的 sum 为 0</td>
</tr>
<tr>
<td align="left">mean</td>
<td align="left">算术平均数。零长度的数组的 mean 为 NaN</td>
</tr>
<tr>
<td align="left">std、var</td>
<td align="left">分别为标准差和方差，自由度可调（默认为 n）</td>
</tr>
<tr>
<td align="left">min、max</td>
<td align="left">最大值和最小值</td>
</tr>
<tr>
<td align="left">argmin、argmax</td>
<td align="left">分别为最大和最小元素的索引</td>
</tr>
<tr>
<td align="left">cumsum</td>
<td align="left">所有元素的累积和</td>
</tr>
<tr>
<td align="left">cumprod</td>
<td align="left">所有元素的累积值</td>
</tr>
</tbody></table>
<h3 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h3><ul>
<li><code>any</code>：用于测试数组中是否存在一个或多个 True；</li>
<li><code>all</code>：检查数组中所有值是否都是 True。</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>多维数组可以通过<code>sort()</code>在任何一个轴向上进行排序，只需将轴编号传入即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: arr</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">array([[-<span class="number">1.40298298</span>, -<span class="number">0.94302353</span>, -<span class="number">1.2592719</span> ,  <span class="number">1.15911978</span>],</span><br><span class="line">       [-<span class="number">0.53758748</span>,  <span class="number">1.44386652</span>, -<span class="number">1.8916146</span> ,  <span class="number">0.66364269</span>],</span><br><span class="line">       [-<span class="number">0.29874721</span>, -<span class="number">0.10316202</span>,  <span class="number">0.21261665</span>, -<span class="number">2.47289258</span>],</span><br><span class="line">       [-<span class="number">0.34280455</span>,  <span class="number">0.43060591</span>, -<span class="number">0.89851967</span>, -<span class="number">0.73198573</span>],</span><br><span class="line">       [-<span class="number">0.9066756</span> ,  <span class="number">1.28177992</span>,  <span class="number">0.35708335</span>,  <span class="number">0.2792639</span> ]])</span><br><span class="line">       </span><br><span class="line">In [<span class="number">7</span>]: arr.sort(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: arr</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">array([[-<span class="number">1.40298298</span>, -<span class="number">1.2592719</span> , -<span class="number">0.94302353</span>,  <span class="number">1.15911978</span>],</span><br><span class="line">       [-<span class="number">1.8916146</span> , -<span class="number">0.53758748</span>,  <span class="number">0.66364269</span>,  <span class="number">1.44386652</span>],</span><br><span class="line">       [-<span class="number">2.47289258</span>, -<span class="number">0.29874721</span>, -<span class="number">0.10316202</span>,  <span class="number">0.21261665</span>],</span><br><span class="line">       [-<span class="number">0.89851967</span>, -<span class="number">0.73198573</span>, -<span class="number">0.34280455</span>,  <span class="number">0.43060591</span>],</span><br><span class="line">       [-<span class="number">0.9066756</span> ,  <span class="number">0.2792639</span> ,  <span class="number">0.35708335</span>,  <span class="number">1.28177992</span>]])</span><br></pre></td></tr></table></figure>

<p>顶级方法<code>np.sort</code>返回的是数组的已排序副本，而就地排序则会修改数组本身。</p>
<h3 id="唯一化以及其他的集合逻辑"><a href="#唯一化以及其他的集合逻辑" class="headerlink" title="唯一化以及其他的集合逻辑"></a>唯一化以及其他的集合逻辑</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unique(x)</td>
<td align="left">计算 x 中的唯一元素，并返回有序结果</td>
</tr>
<tr>
<td align="left">intersect1d(x, y)</td>
<td align="left">计算 x 和 y 中的公共元素，并返回有序结果</td>
</tr>
<tr>
<td align="left">union1d(x, y)</td>
<td align="left">计算 x 和 y 的并集，并返回有序结果</td>
</tr>
<tr>
<td align="left">in1d(x, y)</td>
<td align="left">得到一个表示”x 的元素是否包含于 y“的布尔型数组</td>
</tr>
<tr>
<td align="left">setdiff1d(x, y)</td>
<td align="left">集合的差，即元素在 x 中且不在 y 中</td>
</tr>
<tr>
<td align="left">setxor1d(x, y)</td>
<td align="left">集合的异或，即存在于一个数组中但不同时存在于两个数组中的元素</td>
</tr>
</tbody></table>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>NumPy 提供了一个用于矩阵乘法的<code>dot</code>函数（既是一个数组方法也是 numpy 命名空间中的一个函数）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: x = np.array([[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],[<span class="number">4.</span>,<span class="number">5.</span>,<span class="number">6.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: y = np.array([[<span class="number">6.</span>, <span class="number">23.</span>], [-<span class="number">1</span>, <span class="number">7</span>], [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: x.dot(y)</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">array([[  <span class="number">28.</span>,   <span class="number">64.</span>],</span><br><span class="line">       [  <span class="number">67.</span>,  <span class="number">181.</span>]])</span><br></pre></td></tr></table></figure>

<p>numpy.linalg 中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。</p>
<h4 id="常用的-numpy-linalg-函数"><a href="#常用的-numpy-linalg-函数" class="headerlink" title="常用的 numpy.linalg 函数"></a>常用的 numpy.linalg 函数</h4><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">diag</td>
<td align="left">以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换为方阵（非对角线元素为 0）</td>
</tr>
<tr>
<td align="left">dot</td>
<td align="left">矩阵乘法</td>
</tr>
<tr>
<td align="left">trace</td>
<td align="left">计算对角线元素的和</td>
</tr>
<tr>
<td align="left">det</td>
<td align="left">计算矩阵行列式</td>
</tr>
<tr>
<td align="left">eig</td>
<td align="left">计算方阵的本征值和本征向量</td>
</tr>
<tr>
<td align="left">inv</td>
<td align="left">计算方阵的逆</td>
</tr>
<tr>
<td align="left">svd</td>
<td align="left">计算奇异值分解（SVD）</td>
</tr>
<tr>
<td align="left">solve</td>
<td align="left">解线性方程组 Ax = b，其中 A 为一个方阵</td>
</tr>
<tr>
<td align="left">lstsq</td>
<td align="left">计算 Ax = b 的最小二乘解</td>
</tr>
</tbody></table>
<h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>numpy.random 模块对 Python 内置的<code>random</code>进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如用<code>normal</code>来得到一个标准正态分布的多维数组：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: samples = np.random.normal(size=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: samples</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">array([[ <span class="number">0.58779653</span>,  <span class="number">0.69406318</span>,  <span class="number">0.28244585</span>,  <span class="number">0.25620597</span>],</span><br><span class="line">       [ <span class="number">0.95854832</span>,  <span class="number">0.55800493</span>,  <span class="number">0.17702977</span>, -<span class="number">0.06442143</span>],</span><br><span class="line">       [-<span class="number">1.60361823</span>, -<span class="number">0.00796763</span>, -<span class="number">0.48375863</span>, -<span class="number">1.59447872</span>],</span><br><span class="line">       [ <span class="number">0.80866648</span>, -<span class="number">1.75706417</span>,  <span class="number">0.03793649</span>,  <span class="number">0.18152227</span>]])</span><br></pre></td></tr></table></figure>

<h4 id="部分-numpy-random-函数"><a href="#部分-numpy-random-函数" class="headerlink" title="部分 numpy.random 函数"></a>部分 numpy.random 函数</h4><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">seed</td>
<td align="left">确定随机数生成器的种子</td>
</tr>
<tr>
<td align="left">permutation</td>
<td align="left">返回一个序列的随机排列或返回一个随机排列的范围</td>
</tr>
<tr>
<td align="left">shuffle</td>
<td align="left">对一个序列就地随机排列</td>
</tr>
<tr>
<td align="left">rand</td>
<td align="left">产生均匀分布的样本值</td>
</tr>
<tr>
<td align="left">randint</td>
<td align="left">从给定的上下限范围内随机选取整数</td>
</tr>
<tr>
<td align="left">randn</td>
<td align="left">产生正态分布（平均值为 0，标准差为 1）的样本值</td>
</tr>
<tr>
<td align="left">binomial</td>
<td align="left">产生二项分布的样本值</td>
</tr>
<tr>
<td align="left">normal</td>
<td align="left">产生正态（高斯）分布的样本值</td>
</tr>
<tr>
<td align="left">beta</td>
<td align="left">产生 Beta 分布的样本值</td>
</tr>
<tr>
<td align="left">chisquare</td>
<td align="left">产生卡方分布的样本值</td>
</tr>
<tr>
<td align="left">gamma</td>
<td align="left">产生 Gamma 分布的样本值</td>
</tr>
<tr>
<td align="left">uniform</td>
<td align="left">产生在 [0,1) 中均匀分布的样本值</td>
</tr>
</tbody></table>
<h2 id="pandas-入门"><a href="#pandas-入门" class="headerlink" title="pandas 入门"></a>pandas 入门</h2><p>pandas 基于 NumPy 构建，含有使数据分析工作变得更快更简单的高级数据结构和操作工具。</p>
<p>pandas 引入约定：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>

<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>Series 是一种<strong>类似于一维数组</strong>的对象，它由一组数据（各种 NumPy 数据类型）以及一组与之相关的数据标签（即索引）组成：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: obj = Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: obj</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">5</span></span><br><span class="line"><span class="number">3</span>    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>Series 的字符串表现形式为：索引在左边，值在右边。可以通过 Series 的 values 和 index 属性获取其数组表示形式和索引对象：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: obj.values</span><br><span class="line">Out[<span class="number">5</span>]: array([ <span class="number">4</span>,  <span class="number">7</span>, -<span class="number">5</span>,  <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: obj.index</span><br><span class="line">Out[<span class="number">6</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>在创建 Series 时可以指定各个数据点的索引：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: obj2 = Series([<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: obj2</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">d    <span class="number">4</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">b    <span class="number">3</span></span><br><span class="line">c    <span class="number">5</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: obj2.index</span><br><span class="line">Out[<span class="number">9</span>]: Index([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>与普通 NumPy 数组相比，可以通过索引来选取 Series 中的单个或一组值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: obj2[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: obj2[<span class="string">&#x27;d&#x27;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: obj2[[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]]</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">d    <span class="number">6</span></span><br><span class="line">a    <span class="number">2</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>NumPy 数组运算（根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引和值之间的链接。</p>
<p>还可以将 Series 看成一个<strong>定长的有序字典</strong>，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中。</p>
<p>如果数据被存放在一个 Python 字典中，也可以直接通过这个字典来创建 Series。可以只传入一个字典（结果 Series 中的索引（有序排列）就是原字典的键），也可以同时传入一个 index 参数，字典中与索引相匹配的值被放到相应的位置上，<strong>找不到的值则为 NaN</strong>（数据缺失）。pandas 的<code>isnull</code>和<code>notnull</code>函数可用于检测缺失数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: sdata = &#123;<span class="string">&#x27;hello&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;python&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;pandas&#x27;</span>: <span class="number">300</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: states = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;pandas&#x27;</span>, <span class="string">&#x27;numpy&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: obj3 = Series(sdata, index=states)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: obj3</span><br><span class="line">Out[<span class="number">16</span>]:</span><br><span class="line">hello     <span class="number">100.0</span></span><br><span class="line">pandas    <span class="number">300.0</span></span><br><span class="line">numpy       NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: pd.isnull(obj3)</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">hello     <span class="literal">False</span></span><br><span class="line">pandas    <span class="literal">False</span></span><br><span class="line">numpy      <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: obj3.isnull()</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">hello     <span class="literal">False</span></span><br><span class="line">pandas    <span class="literal">False</span></span><br><span class="line">numpy      <span class="literal">True</span></span><br><span class="line">dtype: <span class="built_in">bool</span></span><br></pre></td></tr></table></figure>

<p>Series 很重要的一个功能是：它在算数运算中会<strong>自动对齐不同索引的数据</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: obj4 = Series(sdata)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: obj4</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">hello     <span class="number">100</span></span><br><span class="line">pandas    <span class="number">300</span></span><br><span class="line">python    <span class="number">200</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">21</span>]:</span><br><span class="line">hello     <span class="number">200.0</span></span><br><span class="line">numpy       NaN</span><br><span class="line">pandas    <span class="number">600.0</span></span><br><span class="line">python      NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>Series 对象本身及其索引都带有一个 name 属性，该属性跟 pandas 其他的关键功能关系非常密切：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: obj4.name = <span class="string">&#x27;dict&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: obj4.index.name = <span class="string">&#x27;words&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: obj4</span><br><span class="line">Out[<span class="number">25</span>]:</span><br><span class="line">words</span><br><span class="line">hello     <span class="number">100</span></span><br><span class="line">pandas    <span class="number">300</span></span><br><span class="line">python    <span class="number">200</span></span><br><span class="line">Name: <span class="built_in">dict</span>, dtype: int64</span><br></pre></td></tr></table></figure>

<p>Series 的索引可以通过赋值的方式就地修改：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: obj4.index = [<span class="string">&#x27;bye&#x27;</span>, <span class="string">&#x27;little&#x27;</span>, <span class="string">&#x27;girl&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: obj4</span><br><span class="line">Out[<span class="number">27</span>]:</span><br><span class="line">bye       <span class="number">100</span></span><br><span class="line">little    <span class="number">300</span></span><br><span class="line">girl      <span class="number">200</span></span><br><span class="line">Name: <span class="built_in">dict</span>, dtype: int64</span><br></pre></td></tr></table></figure>

<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><p>DataFrame 是一个<strong>表格型</strong>的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型等）。DataFrame 既有行索引也有列索引，可以被看作由 Series 组成的字典（共用同一个索引）。</p>
<p>DataFrame 是以二维结构保存数据的，但可以被表示为<strong>层次化索引的表格型结构</strong>，这是 pandas 中许多高级数据处理功能的关键要素。</p>
<p>构建 DataFrame 的办法有很多，最常用的一种是直接传入一个由等长列表或 NumPy 数组组成的字典，DataFrame 会自动加上索引，且全部列会被有序排列：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;well&#x27;</span>, <span class="string">&#x27;good&#x27;</span>, <span class="string">&#x27;soso&#x27;</span>, <span class="string">&#x27;bad&#x27;</span>], <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>], <span class="string">&#x27;nums&#x27;</span>:</span><br><span class="line">   ...: [<span class="number">1.1</span>, <span class="number">2.3</span>, <span class="number">4.2</span>, <span class="number">5.4</span>]&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: frame = DataFrame(data)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: frame</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">   nums state  year</span><br><span class="line"><span class="number">0</span>   <span class="number">1.1</span>  well  <span class="number">2000</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2.3</span>  good  <span class="number">2001</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4.2</span>  soso  <span class="number">2002</span></span><br><span class="line"><span class="number">3</span>   <span class="number">5.4</span>   bad  <span class="number">2003</span></span><br></pre></td></tr></table></figure>

<p>如果指定了列序列，则 DataFrame 的列就会按照指定顺序进行排列。如果传入的列找不到，会和 Series 一样产生 NaN 值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: frames2 = DataFrame(data, columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;nums&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    ...: three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: frames2</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">       year state  nums debt</span><br><span class="line">one    <span class="number">2000</span>  well   <span class="number">1.1</span>  NaN</span><br><span class="line">two    <span class="number">2001</span>  good   <span class="number">2.3</span>  NaN</span><br><span class="line">three  <span class="number">2002</span>  soso   <span class="number">4.2</span>  NaN</span><br><span class="line">four   <span class="number">2003</span>   bad   <span class="number">5.4</span>  NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: frames2.columns</span><br><span class="line">Out[<span class="number">12</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;nums&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过类似字典标记的方式或属性的方式，可以将 DataFrame 的列获取为一个Series：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: frames2[<span class="string">&#x27;state&#x27;</span>] <span class="comment"># = frames2.state</span></span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">one      well</span><br><span class="line">two      good</span><br><span class="line">three    soso</span><br><span class="line">four      bad</span><br><span class="line">Name: state, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<p>行也可以通过位置或名称的方式进行获取，比如用索引字段<code>ix</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: frames2.ix[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line">Out[<span class="number">15</span>]:</span><br><span class="line">year     <span class="number">2000</span></span><br><span class="line">state    well</span><br><span class="line">nums      <span class="number">1.1</span></span><br><span class="line">debt      NaN</span><br><span class="line">Name: one, dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<p>列可以通过<strong>赋值</strong>的方式进行修改。将列表或数组赋值给某个列时，其长度必须跟 DataFrame 的长度相匹配。如果赋值的是一个 Series，就会精确匹配 DataFrame 的索引，所有的空位都将被填上缺失值。为不存在的列赋值会创建出一个新列。关键字 del 用于删除列：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: frames2[<span class="string">&#x27;eastern&#x27;</span>] = frames2.state == <span class="string">&#x27;Ohio&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: frames2</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">       year state  nums debt eastern</span><br><span class="line">one    <span class="number">2000</span>  well   <span class="number">1.1</span>  NaN   <span class="literal">False</span></span><br><span class="line">two    <span class="number">2001</span>  good   <span class="number">2.3</span>  NaN   <span class="literal">False</span></span><br><span class="line">three  <span class="number">2002</span>  soso   <span class="number">4.2</span>  NaN   <span class="literal">False</span></span><br><span class="line">four   <span class="number">2003</span>   bad   <span class="number">5.4</span>  NaN   <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: <span class="keyword">del</span> frames2[<span class="string">&#x27;eastern&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: frames2.columns</span><br><span class="line">Out[<span class="number">19</span>]: Index([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;nums&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，通过索引方式返回的列只是相应数据的<strong>视图</strong>而非副本。因此，对返回的 Series 所做的任何就地修改全都会反映到源 DataFrame 上。通过 Series 的 copy 方法即可显式地复制列。</p>
<p>另一种常见的数据类型是嵌套字典。将其传给 DataFrame，会被解释为：外层字典的键作为列，内层键则作为行索引：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: pop = &#123;<span class="string">&#x27;niboer&#x27;</span>: &#123;<span class="number">2024</span>: <span class="number">2.4</span>, <span class="number">2027</span>: <span class="number">4.3</span>&#125;, <span class="string">&#x27;huacun&#x27;</span>: &#123;<span class="number">2024</span>: <span class="number">1.4</span>, <span class="number">2025</span>:<span class="number">3.2</span>, <span class="number">2027</span>: <span class="number">6.4</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: frames = DataFrame(pop)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: frames</span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">      huacun  niboer</span><br><span class="line"><span class="number">2024</span>     <span class="number">1.4</span>     <span class="number">2.4</span></span><br><span class="line"><span class="number">2025</span>     <span class="number">3.2</span>     NaN</span><br><span class="line"><span class="number">2027</span>     <span class="number">6.4</span>     <span class="number">4.3</span></span><br></pre></td></tr></table></figure>

<p>也可以对该结果进行转置：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: frames.T</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line">        <span class="number">2024</span>  <span class="number">2025</span>  <span class="number">2027</span></span><br><span class="line">huacun   <span class="number">1.4</span>   <span class="number">3.2</span>   <span class="number">6.4</span></span><br><span class="line">niboer   <span class="number">2.4</span>   NaN   <span class="number">4.3</span></span><br></pre></td></tr></table></figure>

<p>如果 DataFrame 各列的数据类型不同，则值数组的数据类型就会选用能兼容所有列的数据类型。</p>
<h3 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h3><p>pandas 的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建 Series 或 DataFrame 时，所用到的任何数组或其他序列的标签都会被转换成一个 Index 对象：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: obj = Series(<span class="built_in">range</span>(<span class="number">3</span>), index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: index = obj.index</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: index</span><br><span class="line">Out[<span class="number">26</span>]: Index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: index[<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">27</span>]: Index([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], dtype=<span class="string">&#x27;object&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Index 对象是不可修改的。这种设计使 Index 对象在多个数据结构之间安全共享：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">31</span>]: index = pd.Index(np.arange(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: obj2 = Series([<span class="number">1.5</span>, -<span class="number">2.5</span>, <span class="number">0</span>], index=index)</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: obj2.index <span class="keyword">is</span> index</span><br><span class="line">Out[<span class="number">33</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>Index 的方法和属性见原书 p126（pdf p137）。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><h4 id="重新索引（reindex）"><a href="#重新索引（reindex）" class="headerlink" title="重新索引（reindex）"></a>重新索引（<code>reindex</code>）</h4><p>调用某个 **Series 的<code>reindex</code>**方法将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: obj = Series([<span class="number">4.5</span>, <span class="number">7.2</span>, -<span class="number">5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: obj = Series([<span class="number">4.5</span>, <span class="number">7.2</span>, -<span class="number">5.3</span>, <span class="number">3.6</span>], index=[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: obj</span><br><span class="line">Out[<span class="number">5</span>]:</span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: obj2 = obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: obj2</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    NaN</span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: obj.reindex([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。<code>method</code>选项即可到达此目的，例如使用<code>ffill</code>可以实现前向值填充（<code>bfill</code>实现向后插值）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: obj3 = Series([<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>], index=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: obj3.reindex(<span class="built_in">range</span>(<span class="number">6</span>), method=<span class="string">&#x27;ffill&#x27;</span>)</span><br><span class="line">Out[<span class="number">10</span>]:</span><br><span class="line"><span class="number">0</span>      blue</span><br><span class="line"><span class="number">1</span>      blue</span><br><span class="line"><span class="number">2</span>    purple</span><br><span class="line"><span class="number">3</span>    purple</span><br><span class="line"><span class="number">4</span>    yellow</span><br><span class="line"><span class="number">5</span>    yellow</span><br><span class="line">dtype: <span class="built_in">object</span></span><br></pre></td></tr></table></figure>

<p>对于 <strong>DataFrame</strong>，<code>reindex</code>可以修改（行）索引、列，或两个都修改。如果仅传入一个序列，则会重新索引行。使用<code>columns</code>关键字即可重新索引列。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: frame = DataFrame(np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>,<span class="number">3</span>)), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>],columns=[<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Texa</span></span><br><span class="line"><span class="string">    ...: s&#x27;</span>, <span class="string">&#x27;California&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: frame</span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">   Ohio  Texas  California</span><br><span class="line">a     <span class="number">0</span>      <span class="number">1</span>           <span class="number">2</span></span><br><span class="line">c     <span class="number">3</span>      <span class="number">4</span>           <span class="number">5</span></span><br><span class="line">d     <span class="number">6</span>      <span class="number">7</span>           <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: frame.reindex(columns=[<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">   Texas  California  Ohio</span><br><span class="line">a      <span class="number">1</span>           <span class="number">2</span>     <span class="number">0</span></span><br><span class="line">c      <span class="number">4</span>           <span class="number">5</span>     <span class="number">3</span></span><br><span class="line">d      <span class="number">7</span>           <span class="number">8</span>     <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>也可以同时对行和列进行重新索引，而插值则只能按行应用（即轴 0）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: frame.reindex(index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], method=<span class="string">&#x27;ffill&#x27;</span>, columns=[<span class="string">&#x27;Texas&#x27;</span>, <span class="string">&#x27;California&#x27;</span>, <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    ...: Ohio&#x27;</span>])</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">   Texas  California  Ohio</span><br><span class="line">a      <span class="number">1</span>           <span class="number">2</span>     <span class="number">0</span></span><br><span class="line">b      <span class="number">1</span>           <span class="number">2</span>     <span class="number">0</span></span><br><span class="line">c      <span class="number">4</span>           <span class="number">5</span>     <span class="number">3</span></span><br><span class="line">d      <span class="number">7</span>           <span class="number">8</span>     <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>利用<code>ix</code>的标签索引功能，重新索引任务可以变得更简洁。</p>
<p><code>reindex</code>函数的各参数及说明见原书 p129（pdf p140）。</p>
<h4 id="丢弃指定轴上的项"><a href="#丢弃指定轴上的项" class="headerlink" title="丢弃指定轴上的项"></a>丢弃指定轴上的项</h4><p>对于 Series，<code>drop</code>方法返回一个在指定轴上删除了指定值的新对象：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: obj = Series(np.arange(<span class="number">5.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: new_obj = obj.drop(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: new_obj</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: obj.drop([<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">4.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>对于 DataFrame，可以删除任意轴上的索引值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: frames</span><br><span class="line">Out[<span class="number">10</span>]:</span><br><span class="line">      huacun  niboer</span><br><span class="line"><span class="number">2024</span>     <span class="number">1.4</span>     <span class="number">2.4</span></span><br><span class="line"><span class="number">2025</span>     <span class="number">3.2</span>     NaN</span><br><span class="line"><span class="number">2027</span>     <span class="number">6.4</span>     <span class="number">4.3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: frames.drop([<span class="string">&#x27;huacun&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">      niboer</span><br><span class="line"><span class="number">2024</span>     <span class="number">2.4</span></span><br><span class="line"><span class="number">2025</span>     NaN</span><br><span class="line"><span class="number">2027</span>     <span class="number">4.3</span></span><br></pre></td></tr></table></figure>

<h4 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h4><p>Series 索引的工作方式类似于 NumPy 数组的索引，只不过不只是整数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: obj = Series(np.arange(<span class="number">4.</span>), index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: obj[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: obj[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: obj[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">d    <span class="number">3.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: obj[[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">a    <span class="number">0.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>利用标签的切片运算与普通的 Python 切片运算不同，其末端是<strong>包含的</strong>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: obj[<span class="string">&#x27;b&#x27;</span>:<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">b    <span class="number">1.0</span></span><br><span class="line">c    <span class="number">2.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>而对于 DataFrame，进行索引是在获取一个或多个<strong>列</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: data = DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)), index=[<span class="string">&#x27;Obio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New Yor</span></span><br><span class="line"><span class="string">    ...: k&#x27;</span>], columns=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: data[<span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">Obio         <span class="number">1</span></span><br><span class="line">Colorado     <span class="number">5</span></span><br><span class="line">Utah         <span class="number">9</span></span><br><span class="line">New York    <span class="number">13</span></span><br><span class="line">Name: two, dtype: int64</span><br></pre></td></tr></table></figure>

<p>想选取<strong>行</strong>有以下两种方式：</p>
<ul>
<li>通过切片或布尔型数组选取行：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: data[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Obio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: data[data[<span class="string">&#x27;three&#x27;</span>] &gt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过布尔型 DataFrame 进行索引：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: data &lt; <span class="number">5</span></span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">            one    two  three   four</span><br><span class="line">Obio       <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span>   <span class="literal">True</span></span><br><span class="line">Colorado   <span class="literal">True</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">Utah      <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line">New York  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span>  <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: data[data &lt; <span class="number">5</span>]</span><br><span class="line">Out[<span class="number">15</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Obio      <span class="number">0.0</span>  <span class="number">1.0</span>    <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line">Colorado  <span class="number">4.0</span>  NaN    NaN   NaN</span><br><span class="line">Utah      NaN  NaN    NaN   NaN</span><br><span class="line">New York  NaN  NaN    NaN   NaN</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: data[data &lt; <span class="number">5</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: data</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">          one  two  three  four</span><br><span class="line">Obio        <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>

<p>为了在 DataFrame 的行上进行标签索引，可以使用专门的索引字段<code>ix</code>，以通过 NumPy 式的标记法以及轴标签从 DataFrame 中选取行和列的子集。这也是一种重新索引的简单手段。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: data.ix[<span class="string">&#x27;Colorado&#x27;</span>, [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]]</span><br><span class="line">Out[<span class="number">18</span>]:</span><br><span class="line">two      <span class="number">5</span></span><br><span class="line">three    <span class="number">6</span></span><br><span class="line">Name: Colorado, dtype: int64</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: data.ix[[<span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">          four  one  two</span><br><span class="line">Colorado     <span class="number">7</span>    <span class="number">0</span>    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">11</span>    <span class="number">8</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: data.ix[<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">21</span>]:</span><br><span class="line">one       <span class="number">8</span></span><br><span class="line">two       <span class="number">9</span></span><br><span class="line">three    <span class="number">10</span></span><br><span class="line">four     <span class="number">11</span></span><br><span class="line">Name: Utah, dtype: int64</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: data.ix[:<span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line">Obio        <span class="number">0</span></span><br><span class="line">Colorado    <span class="number">5</span></span><br><span class="line">Utah        <span class="number">9</span></span><br><span class="line">Name: two, dtype: int64</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: data.ix[data.three &gt; <span class="number">5</span>, :<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">0</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>

<p>DataFrame 的索引选项见原书 p132（pdf p143）。</p>
<h4 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h4><p>pandas 最重要的一个功能是<strong>对不同索引的对象进行算数运算</strong>。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。自动的数据对齐操作在不重叠的索引处引入了 NaN 值。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: s1 = Series([<span class="number">7.3</span>, -<span class="number">2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: s2 = Series([-<span class="number">2.1</span>, <span class="number">3.6</span>, -<span class="number">1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: s1+s2</span><br><span class="line">Out[<span class="number">26</span>]:</span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>对于 DataFrame，对齐操作会同时发生在行和列上。</p>
<h5 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h5><p>在使用<code>add</code>或者<code>reindex</code>等方法时，可以通过<code>fill_value</code>参数指定一个填充值.</p>
<h5 id="DataFrame-和-Series-之间的运算"><a href="#DataFrame-和-Series-之间的运算" class="headerlink" title="DataFrame 和 Series 之间的运算"></a>DataFrame 和 Series 之间的运算</h5><p>默认情况下，DataFrame 和 Series 之间的算术运算会将 Series 的索引匹配到 DataFrame 的<strong>列</strong>，然后沿着行一直向下<strong>广播</strong>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: frame = DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>,<span class="number">3</span>)), columns=<span class="built_in">list</span>(<span class="string">&#x27;bde&#x27;</span>), index=[<span class="string">&#x27;Obio&#x27;</span>, <span class="string">&#x27;Colorado&#x27;</span>, <span class="string">&#x27;Utah&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: series = frame.ix[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: frame</span><br><span class="line">Out[<span class="number">29</span>]:</span><br><span class="line">            b     d     e</span><br><span class="line">Obio      <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Colorado  <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Utah      <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">New York  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: series</span><br><span class="line">Out[<span class="number">30</span>]:</span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Obio, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: frame - series</span><br><span class="line">Out[<span class="number">31</span>]:</span><br><span class="line">            b    d    e</span><br><span class="line">Obio      <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Colorado  <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Utah      <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">New York  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br></pre></td></tr></table></figure>

<p>如果某个索引值在 DataFrame 的列或 Series 的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集。</p>
<p>如果希望匹配行且在列上广播，则必须使用算数运算方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: series3 = frame[<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: series3</span><br><span class="line">Out[<span class="number">33</span>]:</span><br><span class="line">Obio         <span class="number">1.0</span></span><br><span class="line">Colorado     <span class="number">4.0</span></span><br><span class="line">Utah         <span class="number">7.0</span></span><br><span class="line">New York    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: frame.sub(series3, axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">35</span>]:</span><br><span class="line">            b    d    e</span><br><span class="line">Obio     -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Colorado -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Utah     -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">New York -<span class="number">1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>传入的轴号就是希望匹配的轴。</p>
<h4 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h4><p>NumPy 的<code>ufuncs</code>（元素级数组方法）也可以用于操作 pandas 对象：<code>np.abs(frame)</code>。</p>
<p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上，DataFrame 的<code>apply</code>方法即可实现此功能。通过<code>applymap</code>也可以使用元素级的 Python 函数（Series 有一个用于应用元素级函数的<code>map</code>方法）。</p>
<h4 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h4><p>要对行或列索引进行排序（字典顺序），可使用<code>sort_index</code>方法来返回一个已排序的新对象：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame, Series</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: obj = Series(<span class="built_in">range</span>(<span class="number">4</span>), index=[<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: obj</span><br><span class="line">Out[<span class="number">38</span>]:</span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: obj.sort_index()</span><br><span class="line">Out[<span class="number">39</span>]:</span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<!-- pdf p150 -->

<h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>pandas 使用浮点值 NaN 表示浮点和非浮点数组中的缺失数据，可以通过<code>np.nan</code>或者<code>None</code>得到。</p>
<h4 id="滤除缺失数据"><a href="#滤除缺失数据" class="headerlink" title="滤除缺失数据"></a>滤除缺失数据</h4><p>对于一个 Series，<code>dropna</code>函数返回一个仅含非空数据和索引值的 Series。</p>
<p>对于 DataFrame，<code>dropna</code>函数默认丢弃任何含有缺失值的行。传入<code>how=&#39;all&#39;</code>将只丢弃全为 NaN 的行。丢弃列则传入<code>axis=1</code>即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame, Series</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: data = Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: data.dropna()</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3.5</span></span><br><span class="line"><span class="number">4</span>    <span class="number">7.0</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: data = DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: data</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">2</span>  NaN  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: data.dropna(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">Empty DataFrame</span><br><span class="line">Columns: []</span><br><span class="line">Index: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: data.dropna()</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: data.dropna(how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1.0</span>  <span class="number">6.5</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line"><span class="number">3</span>  NaN  <span class="number">6.5</span>  <span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<h4 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h4><p>通过一个常数调用<code>fillna</code>将缺失值替换为常数值。而通过一个字典调用<code>fillna</code>可以实现对不同的列填充不同的值。<code>fillna</code>默认返回新对象。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: df = DataFrame(np.random.randn(<span class="number">7</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: df.loc[:<span class="number">4</span>, <span class="number">1</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: df.loc[:<span class="number">2</span>, <span class="number">2</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: df</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.048462</span>       NaN       NaN</span><br><span class="line"><span class="number">1</span> -<span class="number">1.114710</span>       NaN       NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">1.290745</span>       NaN       NaN</span><br><span class="line"><span class="number">3</span> -<span class="number">0.129481</span>       NaN -<span class="number">2.151261</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.030350</span>       NaN -<span class="number">1.330047</span></span><br><span class="line"><span class="number">5</span> -<span class="number">2.431158</span> -<span class="number">0.340187</span> -<span class="number">0.246772</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.478923</span>  <span class="number">0.232547</span>  <span class="number">1.959353</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: df.fillna(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.048462</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">1</span> -<span class="number">1.114710</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">2</span>  <span class="number">1.290745</span>  <span class="number">0.000000</span>  <span class="number">0.000000</span></span><br><span class="line"><span class="number">3</span> -<span class="number">0.129481</span>  <span class="number">0.000000</span> -<span class="number">2.151261</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.030350</span>  <span class="number">0.000000</span> -<span class="number">1.330047</span></span><br><span class="line"><span class="number">5</span> -<span class="number">2.431158</span> -<span class="number">0.340187</span> -<span class="number">0.246772</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.478923</span>  <span class="number">0.232547</span>  <span class="number">1.959353</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">3</span>: -<span class="number">1</span>&#125;)</span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">          <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span></span><br><span class="line"><span class="number">0</span> -<span class="number">0.048462</span>  <span class="number">0.500000</span>       NaN</span><br><span class="line"><span class="number">1</span> -<span class="number">1.114710</span>  <span class="number">0.500000</span>       NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">1.290745</span>  <span class="number">0.500000</span>       NaN</span><br><span class="line"><span class="number">3</span> -<span class="number">0.129481</span>  <span class="number">0.500000</span> -<span class="number">2.151261</span></span><br><span class="line"><span class="number">4</span> -<span class="number">1.030350</span>  <span class="number">0.500000</span> -<span class="number">1.330047</span></span><br><span class="line"><span class="number">5</span> -<span class="number">2.431158</span> -<span class="number">0.340187</span> -<span class="number">0.246772</span></span><br><span class="line"><span class="number">6</span> -<span class="number">1.478923</span>  <span class="number">0.232547</span>  <span class="number">1.959353</span></span><br></pre></td></tr></table></figure>

<h2 id="数据加载、存储与文件格式"><a href="#数据加载、存储与文件格式" class="headerlink" title="数据加载、存储与文件格式"></a>数据加载、存储与文件格式</h2><p>NumPy 提供了一个低级但异常高效的二进制数据加载和存储机制，包括对内存映射数组的支持等。</p>
<p>本章着重介绍 pandas 的输入输出对象。输入输出通常划分为几个大类：</p>
<ul>
<li>读取文本文件和其他更高效的磁盘存储格式；</li>
<li>加载数据库中的数据；</li>
<li>利用 Web API 操作网络资源。</li>
</ul>
<h3 id="读写文本格式的数据"><a href="#读写文本格式的数据" class="headerlink" title="读写文本格式的数据"></a>读写文本格式的数据</h3><p>pandas 提供了一些用于将表格型数据读取为 DataFrame 对象的函数，其中<code>read_csv</code>和<code>read_table</code>可能使用较多。</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">read_csv</td>
<td align="left">从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为逗号</td>
</tr>
<tr>
<td align="left">read_table</td>
<td align="left">从文件、URL、文件型对象中加载带分隔符的数据。默认分隔符为制表符（<code>\t</code>)，<strong>可以用</strong><code>sep</code><strong>参数指定分隔符</strong></td>
</tr>
<tr>
<td align="left">read_fwf</td>
<td align="left">读取定宽列格式数据（即没有分隔符）</td>
</tr>
<tr>
<td align="left">read_clipboard</td>
<td align="left">读取剪贴板中的数据，可以看作是 read_table 的剪贴板版。在将网页转换为表格时很有用</td>
</tr>
</tbody></table>
<p>在将文本数据转换为 DataFrame 时，用到了如下技术：</p>
<ul>
<li>索引：将一个或多个列当作返回的 DataFrame 处理，以及是否从文件、用户获取列名。</li>
<li><strong>类型推断</strong>和数据转换：包括用户定义值的转换、缺失值标记列表等。</li>
<li>日期解析：包括组合功能，比如将分散在多个列的日期时间信息组合成结果中的单个列。</li>
<li>迭代：支持对大文件进行逐块迭代。</li>
<li>不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西。</li>
</ul>
<p>读入一个以逗号分隔的 csv 文本文件：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: data = pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: data</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">   team  score</span><br><span class="line"><span class="number">0</span>     <span class="number">1</span>   <span class="number">45.6</span></span><br><span class="line"><span class="number">1</span>     <span class="number">2</span>   <span class="number">65.4</span></span><br><span class="line"><span class="number">2</span>     <span class="number">3</span>   <span class="number">67.7</span></span><br><span class="line"><span class="number">3</span>     <span class="number">4</span>   <span class="number">76.7</span></span><br><span class="line"><span class="number">4</span>     <span class="number">5</span>   <span class="number">56.3</span></span><br><span class="line"><span class="number">5</span>     <span class="number">6</span>   <span class="number">87.5</span></span><br><span class="line"><span class="number">6</span>     <span class="number">7</span>   <span class="number">45.6</span></span><br><span class="line"><span class="number">7</span>     <span class="number">8</span>   <span class="number">77.0</span></span><br><span class="line"><span class="number">8</span>     <span class="number">9</span>   <span class="number">54.6</span></span><br></pre></td></tr></table></figure>

<p>对于没有标题行的文件，可以让 pandas 为其分配默认的列名：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>, header=<span class="literal">None</span>)</span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">   <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">45.6</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">65.4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">67.7</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">76.7</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">56.3</span></span><br><span class="line"><span class="number">5</span>  <span class="number">6</span>  <span class="number">87.5</span></span><br><span class="line"><span class="number">6</span>  <span class="number">7</span>  <span class="number">45.6</span></span><br><span class="line"><span class="number">7</span>  <span class="number">8</span>  <span class="number">77.0</span></span><br><span class="line"><span class="number">8</span>  <span class="number">9</span>  <span class="number">54.6</span></span><br></pre></td></tr></table></figure>

<p>也可以自定义列名：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">Out[<span class="number">10</span>]:</span><br><span class="line">   a     b</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">45.6</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">65.4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">67.7</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">76.7</span></span><br><span class="line"><span class="number">4</span>  <span class="number">5</span>  <span class="number">56.3</span></span><br><span class="line"><span class="number">5</span>  <span class="number">6</span>  <span class="number">87.5</span></span><br><span class="line"><span class="number">6</span>  <span class="number">7</span>  <span class="number">45.6</span></span><br><span class="line"><span class="number">7</span>  <span class="number">8</span>  <span class="number">77.0</span></span><br><span class="line"><span class="number">8</span>  <span class="number">9</span>  <span class="number">54.6</span></span><br></pre></td></tr></table></figure>

<p>可以通过<code>index_col</code>参数来将某列指定为 DataFrame 的索引：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], index_col=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">      a</span><br><span class="line">b</span><br><span class="line"><span class="number">45.6</span>  <span class="number">1</span></span><br><span class="line"><span class="number">65.4</span>  <span class="number">2</span></span><br><span class="line"><span class="number">67.7</span>  <span class="number">3</span></span><br><span class="line"><span class="number">76.7</span>  <span class="number">4</span></span><br><span class="line"><span class="number">56.3</span>  <span class="number">5</span></span><br><span class="line"><span class="number">87.5</span>  <span class="number">6</span></span><br><span class="line"><span class="number">45.6</span>  <span class="number">7</span></span><br><span class="line"><span class="number">77.0</span>  <span class="number">8</span></span><br><span class="line"><span class="number">54.6</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>如果希望将多个列做成一个<strong>层次化索引</strong>，只需通过<code>index_col</code>参数传入由列编号或列名组成的列表即可。</p>
<p>对于用<strong>不固定的分隔符</strong>分隔字段的文本，可以通过<code>sep</code>参数传入一个正则表达式来作为<code>read_table</code>的分隔符。</p>
<p>可以通过<code>skiprows</code>跳过文件的某几行：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">   a     b</span><br><span class="line"><span class="number">0</span>  <span class="number">2</span>  <span class="number">65.4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">56.3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">6</span>  <span class="number">87.5</span></span><br><span class="line"><span class="number">3</span>  <span class="number">7</span>  <span class="number">45.6</span></span><br><span class="line"><span class="number">4</span>  <span class="number">8</span>  <span class="number">77.0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">9</span>  <span class="number">54.6</span></span><br></pre></td></tr></table></figure>

<p>更多的<code>read_csv</code>/<code>read_table</code>函数的参数选项见原书 p167（pdf p178）。</p>
<h4 id="逐块读取文本文件"><a href="#逐块读取文本文件" class="headerlink" title="逐块读取文本文件"></a>逐块读取文本文件</h4><p>在处理很大的文件时，或找出大文件中的参数集以便后续处理时，可以<strong>只读取几行</strong>（避免读取整个文件），通过<code>nrows</code>进行指定即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], nrows=<span class="number">4</span>)</span><br><span class="line">Out[<span class="number">13</span>]:</span><br><span class="line">   a     b</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">45.6</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">65.4</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">67.7</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span>  <span class="number">76.7</span></span><br></pre></td></tr></table></figure>

<p>也可以通过设置<code>chunksize</code>（行数）来<strong>逐块读取</strong>文件：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: chunker = pd.read_csv(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>, names=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], chunksize=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: chunker</span><br><span class="line">Out[<span class="number">23</span>]: &lt;pandas.io.parsers.TextFileReader at <span class="number">0x1134a7470</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>read_csv</code>所返回的这个 TextParser 对象使你可以根据 chunksize 对文件进行逐块迭代。比如将值计数聚合到 “a” 列中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">18</span>]: tot = Series([])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    ...:     tot = tot.add(piece[<span class="string">&#x27;a&#x27;</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">In [<span class="number">20</span>]: tot = tot.order(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>于是有：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: tot[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">22</span>]:</span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">1.0</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>

<p>TextParser 还有一个<code>get_chunk</code>方法，可以读取任意大小的块。</p>
<h4 id="将数据写出到文本格式"><a href="#将数据写出到文本格式" class="headerlink" title="将数据写出到文本格式"></a>将数据写出到文本格式</h4><p>利用 DataFrame（或 Series）的<code>to_csv</code>方法，可以将数据写到一个以逗号分隔的文件中。也可以通过<code>sep</code>参数指定使用其他分隔符，或者输出到<code>sys.stdout</code>来打印文本结果：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data.to_csv(sys.stdout, sep=<span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>缺失值在输出结果中会被表示为空字符串，可以通过<code>na_rep</code>参数指定其为别的标记值。</p>
<p>如果没有设置其他选项，则会写出行和列的标签，也可以将它们禁用：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>此外，也可以只按指定的顺序写出一部分的列：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, cols=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="手工处理分隔符格式"><a href="#手工处理分隔符格式" class="headerlink" title="手工处理分隔符格式"></a>手工处理分隔符格式</h4><p>对于含有畸形行的文件需要做一些额外处理。对于任何<strong>单字符分隔符文件</strong>，可以直接使用 python 内置的 csv 模块，将人意已打开的文件或文件型对象传给<code>csv.reader</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: <span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/huang/Desktop/score.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: reader = csv.reader(f)</span><br></pre></td></tr></table></figure>

<p>对这个 reader 进行迭代将会为每行产生一个列表（并移除了所有的引号）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">29</span>]: <span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">    ...:     <span class="built_in">print</span>(line)</span><br><span class="line">    ...:</span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;45.6&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;65.4&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;67.7&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;76.7&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;56.3&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;87.5&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;45.6&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;77&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;54.6&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h4 id="JSON-数据"><a href="#JSON-数据" class="headerlink" title="JSON 数据"></a>JSON 数据</h4><p>json 库是构建于 Python 标准库的。通过<code>json.loads</code>即可将 JSON 字符串转换为 Python 形式，而<code>json.dumps</code>则将 Python 对象转换为 JSON 格式（对象中所有的键都必须是字符串）。</p>
<h4 id="XML-和-HTML：Web-信息收集"><a href="#XML-和-HTML：Web-信息收集" class="headerlink" title="XML 和 HTML：Web 信息收集"></a>XML 和 HTML：Web 信息收集</h4><p>相关内容参见原书 p174（psf p185）。</p>
<h3 id="二进制数据格式"><a href="#二进制数据格式" class="headerlink" title="二进制数据格式"></a>二进制数据格式</h3><p>二进制格式的 I/O 高速且高效，但不宜人来阅读。相关内容参见原书 p179（psf p190）。</p>
<h3 id="使用-HTML-和-Web-API"><a href="#使用-HTML-和-Web-API" class="headerlink" title="使用 HTML 和 Web API"></a>使用 HTML 和 Web API</h3><p>通过 requests 包可以方位公共 API。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: url = <span class="string">&#x27;https://www.easy-mock.com/mock/5a1fb5a85bc39d4cf3b7a778/robot/ask&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: resp = requests.get(url)</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: resp</span><br><span class="line">Out[<span class="number">39</span>]: &lt;Response [<span class="number">200</span>]&gt;</span><br></pre></td></tr></table></figure>

<p>Response 对象的 text 属性含有 GET 请求的内容。许多 Web API 返回的都是 JSON 字符串，必须将其加载到一个 Python 对象中：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">40</span>]: data = json.loads(resp.text)</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: data.keys()</span><br><span class="line">Out[<span class="number">41</span>]: dict_keys([<span class="string">&#x27;answer&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><p>对于基于 SQL 的关系型数据库，以 SQLite 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sqlite3</span><br><span class="line">con = sqlite3.connect(&#x27;:memory:&#x27;)</span><br><span class="line">con.execute(query)</span><br><span class="line">con.commit()</span><br></pre></td></tr></table></figure>

<p>pandas 有一个可以简化数据规整操作过程<code>read_frame</code>函数（位于 pandas.io.sql 模块），只需要传入 select 语句和连接对象即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  pandas.io.sql <span class="keyword">as</span> sql</span><br><span class="line"></span><br><span class="line">sql.read_frame(<span class="string">&#x27;select * from test&#x27;</span>, con)</span><br></pre></td></tr></table></figure>

<h4 id="存取-MongoDB-中的数据"><a href="#存取-MongoDB-中的数据" class="headerlink" title="存取 MongoDB 中的数据"></a>存取 MongoDB 中的数据</h4><p>先在电脑上启动一个 MongoDB 实例，然后用 pymongo（MongoDB 的官方驱动器）通过默认端口进行连接：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">con = pymongo.Connection(<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br></pre></td></tr></table></figure>

<p>存储在 MongoDB 中的文档被组织在数据库的集合（collection）中。MongoDB 服务器的每个运行实例可以有多个数据库，而每个数据库又可以有多个集合。想保存之前通过 APi 获取的数据，首先访问响应集合：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">answers = con.db.answers</span><br></pre></td></tr></table></figure>

<p>然后可以通过<code>answers.save</code>将 Python 字典逐个存入 MongoDb 的相应集合中。</p>
<p>可以通过下列代码对集合进行查询：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cursor = answers.find(&#123;<span class="string">&#x27;answer&#x27;</span>: <span class="string">&#x27;提问已收到，正在寻找回答...&#x27;</span>, <span class="string">&#x27;id&#x27;</span>: <span class="number">1111</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>返回的游标是一个迭代器，可以为每个文档产生一个字典。可以将其转换为一个 DataFrame，并只获取部分字段：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = DataFrame(<span class="built_in">list</span>(cursor), columns=<span class="string">&#x27;answer&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数据规整化：清理、转换、合并、重塑"><a href="#数据规整化：清理、转换、合并、重塑" class="headerlink" title="数据规整化：清理、转换、合并、重塑"></a>数据规整化：清理、转换、合并、重塑</h2><p>pandas 和 Python 标准库提供了一组高级的、灵活的、高效的核心函数和算法，以轻松地将数据规整化为正确的形式。</p>
<h3 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h3><ul>
<li><code>pandas.merge</code>可根据一个或多个键将不同 DataFrame 中的行连接起来（相当于 SQL 中的连接操作）。</li>
<li><code>pandas.concat</code>可以沿一条轴将多个对象堆叠到一起。</li>
<li>实例方法<code>combine_first</code>可以将重复数据编连在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ul>
<h4 id="数据库风格的-DataFrame-合并"><a href="#数据库风格的-DataFrame-合并" class="headerlink" title="数据库风格的 DataFrame 合并"></a>数据库风格的 DataFrame 合并</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: df1 = DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: df2 = DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], <span class="string">&#x27;data2&#x27;</span>: <span class="built_in">range</span>(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: df1</span><br><span class="line">Out[<span class="number">4</span>]:</span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a</span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   b</span><br></pre></td></tr></table></figure>

<p>如果没有指定用哪个列进行连接，<code>merge</code>就会将重叠列的列名当作键。不过最好用<code>on</code>选项显式指定（如果两个对象的列名不同，也可以用<code>left_on</code>和<code>right_on</code>分别进行指定）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>merge</code>做的是**”inner”<strong>连接，结果中的键是</strong>交集<strong>。其他方式还有”left”、”right”以及”outer”。</strong>外连接求取的是键的并集**，组合了左连接和右连接的效果：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: pd.merge(df1, df2, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>    <span class="number">0.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">6.0</span>   b    <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">4.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">5.0</span>   a    <span class="number">0.0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">3.0</span>   c    NaN</span><br><span class="line"><span class="number">7</span>    NaN   d    <span class="number">2.0</span></span><br></pre></td></tr></table></figure>

<p>以上是<strong>多对一</strong>的合并。多对多的合并操作非常简单，无需额外的操作：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: df1 = DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: df2 = DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], <span class="string">&#x27;data1&#x27;</span>: <span class="built_in">range</span>(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">    data1_x key  data1_y</span><br><span class="line"><span class="number">0</span>         <span class="number">0</span>   b      <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>         <span class="number">0</span>   b      <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>         <span class="number">1</span>   b      <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>         <span class="number">1</span>   b      <span class="number">3.0</span></span><br><span class="line"><span class="number">4</span>         <span class="number">2</span>   a      <span class="number">0.0</span></span><br><span class="line"><span class="number">5</span>         <span class="number">2</span>   a      <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>         <span class="number">3</span>   c      NaN</span><br><span class="line"><span class="number">7</span>         <span class="number">4</span>   a      <span class="number">0.0</span></span><br><span class="line"><span class="number">8</span>         <span class="number">4</span>   a      <span class="number">2.0</span></span><br><span class="line"><span class="number">9</span>         <span class="number">5</span>   b      <span class="number">1.0</span></span><br><span class="line"><span class="number">10</span>        <span class="number">5</span>   b      <span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<p><strong>多对多连接产生的是行的笛卡尔积</strong>。由于左边的 DataFrame 有 3 个 “b” 行，右边有 2 个，所以最终结果中就有 6 个 “b” 行。连接方式只影响出现在结果中的键：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: pd.merge(df1, df2, on=<span class="string">&#x27;key&#x27;</span>, how=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">   data1_x key  data1_y</span><br><span class="line"><span class="number">0</span>        <span class="number">0</span>   b        <span class="number">1</span></span><br><span class="line"><span class="number">1</span>        <span class="number">0</span>   b        <span class="number">3</span></span><br><span class="line"><span class="number">2</span>        <span class="number">1</span>   b        <span class="number">1</span></span><br><span class="line"><span class="number">3</span>        <span class="number">1</span>   b        <span class="number">3</span></span><br><span class="line"><span class="number">4</span>        <span class="number">5</span>   b        <span class="number">1</span></span><br><span class="line"><span class="number">5</span>        <span class="number">5</span>   b        <span class="number">3</span></span><br><span class="line"><span class="number">6</span>        <span class="number">2</span>   a        <span class="number">0</span></span><br><span class="line"><span class="number">7</span>        <span class="number">2</span>   a        <span class="number">2</span></span><br><span class="line"><span class="number">8</span>        <span class="number">4</span>   a        <span class="number">0</span></span><br><span class="line"><span class="number">9</span>        <span class="number">4</span>   a        <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: left = DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">    ...:  <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>], </span><br><span class="line">    ...:  <span class="string">&#x27;lval&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: right = DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], </span><br><span class="line">    ...:  <span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>], </span><br><span class="line">    ...:  <span class="string">&#x27;lval&#x27;</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: pd.merge(left, right, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">Out[<span class="number">19</span>]:</span><br><span class="line">  key1 key2  lval_x  lval_y</span><br><span class="line"><span class="number">0</span>  foo  one     <span class="number">1.0</span>     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  foo  one     <span class="number">1.0</span>     <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  foo  two     <span class="number">2.0</span>     NaN</span><br><span class="line"><span class="number">3</span>  bar  one     <span class="number">3.0</span>     <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  bar  two     NaN     <span class="number">7.0</span></span><br></pre></td></tr></table></figure>

<p><strong>在进行列-列连接时，DataFrame 对象中的索引会被丢弃。</strong></p>
<p><code>merge</code>的<code>suffixes</code>选项可用于指定<strong>附加到</strong>左右两个 DataFrame 对象的重叠列名上的字符串：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>)</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">  key1 key2_x  lval_x key2_y  lval_y</span><br><span class="line"><span class="number">0</span>  foo    one       <span class="number">1</span>    one       <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo    one       <span class="number">1</span>    one       <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo    two       <span class="number">2</span>    one       <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo    two       <span class="number">2</span>    one       <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar    one       <span class="number">3</span>    one       <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar    one       <span class="number">3</span>    two       <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: pd.merge(left, right, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_left&#x27;</span>, <span class="string">&#x27;_right&#x27;</span>))</span><br><span class="line">Out[<span class="number">21</span>]:</span><br><span class="line">  key1 key2_left  lval_left key2_right  lval_right</span><br><span class="line"><span class="number">0</span>  foo       one          <span class="number">1</span>        one           <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  foo       one          <span class="number">1</span>        one           <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  foo       two          <span class="number">2</span>        one           <span class="number">4</span></span><br><span class="line"><span class="number">3</span>  foo       two          <span class="number">2</span>        one           <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  bar       one          <span class="number">3</span>        one           <span class="number">6</span></span><br><span class="line"><span class="number">5</span>  bar       one          <span class="number">3</span>        two           <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><code>merge</code>的<code>copy</code>选项默认为 True，以根据连接键对合并后的数据进行排序。有时在处理大数据集时，禁用该选项可获得更好的性能。</p>
<p>在 DataFrame 中的<strong>连接键位于其索引中</strong>时，可以传入<code>left_index=True</code>或<code>right_index=True</code>以说明：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: left1 = DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="string">&#x27;value&#x27;</span>: <span class="built_in">range</span>(<span class="number">6</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: right1 = DataFrame(&#123;<span class="string">&#x27;group_val&#x27;</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: right1</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">   group_val</span><br><span class="line">a        <span class="number">3.5</span></span><br><span class="line">b        <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: pd.merge(left1, right1, left_on=<span class="string">&#x27;key&#x27;</span>, right_index=<span class="literal">True</span>)</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">  key  value  group_val</span><br><span class="line"><span class="number">0</span>   a      <span class="number">0</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">2</span>   a      <span class="number">2</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">3</span>   a      <span class="number">3</span>        <span class="number">3.5</span></span><br><span class="line"><span class="number">1</span>   b      <span class="number">1</span>        <span class="number">7.0</span></span><br><span class="line"><span class="number">4</span>   b      <span class="number">4</span>        <span class="number">7.0</span></span><br></pre></td></tr></table></figure>

<h4 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h4><p>另一种数据合并预算也被称作连接（concatenation）、绑定（binding）或堆叠（stacking）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: s1 = Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: s2 = Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: s3 = Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: pd.concat([s1, s2, s3])</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">d    <span class="number">3</span></span><br><span class="line">e    <span class="number">4</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>concat</code>在<code>axis=0</code>上工作，最终产生一个新的 Series（<strong>纵向叠加</strong>）。如果传入<code>axis=1</code>（列），则结果就会变成一个 DataFrame（<strong>横向叠加</strong>）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: pd.concat([s1, s2, s3], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">12</span>]:</span><br><span class="line">     <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">a  <span class="number">0.0</span>  NaN  NaN</span><br><span class="line">b  <span class="number">1.0</span>  NaN  NaN</span><br><span class="line">c  NaN  <span class="number">2.0</span>  NaN</span><br><span class="line">d  NaN  <span class="number">3.0</span>  NaN</span><br><span class="line">e  NaN  <span class="number">4.0</span>  NaN</span><br><span class="line">f  NaN  NaN  <span class="number">5.0</span></span><br><span class="line">g  NaN  NaN  <span class="number">6.0</span></span><br></pre></td></tr></table></figure>

<!--p207：剩下的内容基本就属于 Cookbook 了，暂时不打算看了-->

<h2 id="绘图与可视化"><a href="#绘图与可视化" class="headerlink" title="绘图与可视化"></a>绘图与可视化</h2><p>Python 有许多可视化工具，例如 Chaco、mayavi 等。而作为 Python 领域中使用最广泛的绘图工具，matplotlib 是一个用于创建出版质量图表的桌面绘图包。</p>
<p>有多种方法使用 matplotlib，最常用的方式是 Pylab 模式的 IPython（<code>ipython --pylab</code>），这样会将 IPython 配置为使用用户所指定（一般为默认）的 matplotlib GUI 后端。</p>
<p>可以绘制一张简单的图标来测试一切是否准备就绪：<code>plot(np.arange(10))</code>。如果没有问题就会弹出新窗口，可以用鼠标或者输入<code>close()</code>将其关闭。</p>
<p>matplotlib API 函数都位于 matplotlib.pyplot 模块中，通常的引入约定是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<p>pandas 的绘图函数能够处理许多普通的绘图任务（书上介绍的相关函数可能比较老旧，需要学习官方文档），但如果需要自定义一些高级功能的话就必须学习 matplotlib API。推荐查阅 matplotlib 的示例库和文档进行学习。</p>
<h3 id="Figure-和-Subplot"><a href="#Figure-和-Subplot" class="headerlink" title="Figure 和 Subplot"></a>Figure 和 Subplot</h3><p><strong>matplotlib 的图像都位于 Figure 对象中</strong>。可以用<code>plt.figure()</code>创建一个新的 Figure：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: fig = plt.figure()</span><br></pre></td></tr></table></figure>

<p>会弹出一个新窗口，但是不能通过空 Figure 绘图，必须用<code>add_subplot</code>创建一个或多个 subplot：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>上面这一行代码的意思是，图像有 2 * 2 个 subplot，且当前选中的是 4 个 subplot 中的第一个（编号从 1 开始）。可以更改第三个参数来创建剩余的 subplot。</p>
<p>如果直接发出绘图命令（<code>plt.plot()</code>），matplotlib 会在最后一个用过的 subplot（如果没有则创建一个）上进行绘制。</p>
<p>由<code>fig.add_subplot</code>所返回的对象是 AxesSubplot 对象，直接调用它们的实例方法就可以在其他空着的 subplot 里画图：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: ax1.hist(randn(<span class="number">100</span>), bins=<span class="number">20</span>, color=<span class="string">&#x27;k&#x27;</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: ax3.scatter(np.arange(<span class="number">30</span>), np.arange(<span class="number">30</span>) + <span class="number">3</span> * randn(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>

<p>由于根据特定布局创建 Figure 和 subplot 是一件非常常见的任务，因此可以用更方便的<code>plt.subplots</code>创建一个 Figure，并返回一个含有已创建的 subplot 对象的 NumPy 数组：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">36</span>]: fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: axes</span><br></pre></td></tr></table></figure>

<p>之后可以通过和二维数组一样的索引方式来指定 subplot，例如<code>axes[0, 1]</code>。</p>
<p>关于 pyplot.subplots 的选项以及调整 subplot 周围的间距的更多内容参见原书 p235（pdf p246）。</p>
<h3 id="颜色、标记和线型"><a href="#颜色、标记和线型" class="headerlink" title="颜色、标记和线型"></a>颜色、标记和线型</h3><p>matplot 的 plot 函数接受一组 X 和 Y 坐标，还可以接受一个表示颜色和线型的字符串缩写。例如根据 x 和 y 绘制绿色虚线：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ax.plot(x, y, <span class="string">&#x27;g--&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这种写法会更明确：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ax.plot(x, y, linestyle=<span class="string">&#x27;--&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>常见的颜色都有一个缩写词，也可以通过指定 RGB 值的形式。</p>
<p>可以通过指定<code>marker=&#39;o&#39;</code>来给实际数据点加上标记（marker）：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">plot(randn(<span class="number">30</span>).cumsum(), color=<span class="string">&#x27;k&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">plt.plot(randn(<span class="number">30</span>).cumsum(), <span class="string">&#x27;ko--&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过<code>drawstyle</code>选项修改：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">47</span>]: fig.add_subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).plot(data, <span class="string">&#x27;k-&#x27;</span>, label=<span class="string">&#x27;Default&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: plt.plot(data, <span class="string">&#x27;k-&#x27;</span>, drawstyle=<span class="string">&#x27;steps-post&#x27;</span>, label=<span class="string">&#x27;steps-post&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="刻度、标签和图例"><a href="#刻度、标签和图例" class="headerlink" title="刻度、标签和图例"></a>刻度、标签和图例</h3><p>对于大多数的图表装饰项，其主要实现方式有二：</p>
<ul>
<li>使用过程型的 pyplot 接口；</li>
<li>使用更为面向对象的原生 matplotlib API。</li>
</ul>
<h4 id="设置标题、轴标签、刻度以及刻度标签"><a href="#设置标题、轴标签、刻度以及刻度标签" class="headerlink" title="设置标题、轴标签、刻度以及刻度标签"></a>设置标题、轴标签、刻度以及刻度标签</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: fig = plt.figure()</span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum())</span><br></pre></td></tr></table></figure>

<p>修改 X 轴的刻度时，<code>set_xticks</code>可以确定将刻度放在数据范围中的哪些位置：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">58</span>]: ticks = ax.set_xticks([<span class="number">0</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">750</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure>

<p>默认情况下，这些位置也就是刻度标签，但可以通过<code>set_xticklabels</code>将任何其他的值用作标签：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">59</span>]: labels = ax.set_xticklabels([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>], rotation=<span class="number">30</span>, fontsize=<span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>再用<code>set_xlabel</code>为 X 轴设置一个名称，并用<code>set_title</code>设置一个标题：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">61</span>]: ax.set_title(<span class="string">&#x27;My first matplotlib plot&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: ax.set_xlabels(<span class="string">&#x27;Stages&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="https://user-images.githubusercontent.com/18595460/34092191-3794f9a6-e3fd-11e7-824b-7da5a960fb03.png" alt="figure_1"></p>
<h4 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h4><p>图例（legend）是另一种用于标识图表元素的重要工具。添加图例最简单的是在添加 subplot 的时候传入 label 参数：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">67</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k&#x27;</span>, label=<span class="string">&#x27;one&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k--&#x27;</span>, label=<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: ax.plot(randn(<span class="number">1000</span>).cumsum(), <span class="string">&#x27;k.&#x27;</span>, label=<span class="string">&#x27;three&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果有不想添加图例的元素，不传入<code>label</code>或传入<code>label=&#39;_nolegend_&#39;</code>即可。</p>
<p>之后，可以调用<code>ax.legend()</code>和<code>plt.legend()</code>来自动创建图例：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ax.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="注解以及在-Subplot-上绘图"><a href="#注解以及在-Subplot-上绘图" class="headerlink" title="注解以及在 Subplot 上绘图"></a>注解以及在 Subplot 上绘图</h4><p>可以绘制一些自定义的注解（例如文本、箭头或其他图形等）。</p>
<p>文本：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">71</span>]: ax.text(<span class="number">10</span>, <span class="number">10</span>, <span class="string">&#x27;Hello world!&#x27;</span>, family=<span class="string">&#x27;monospace&#x27;</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>其他参见官方文档。</p>
<h3 id="将图表保存到文件"><a href="#将图表保存到文件" class="headerlink" title="将图表保存到文件"></a>将图表保存到文件</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: plt.savefig(<span class="string">&#x27;./Desktop/figpath.svg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>文件类型通过文件扩展名推断。</p>
<p>可以通过<code>dpi</code>控制每英寸点数分辨率，以及通过<code>bbox_inches</code>剪除当前图表周围的空白部分：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: plt.savefig(<span class="string">&#x27;./Desktop/figpath.png&#x27;</span>, dpi=<span class="number">400</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>更多 Figure.savefig 的选项见原书 p244（pdf p255）。</p>
<h3 id="matplotlib-配置"><a href="#matplotlib-配置" class="headerlink" title="matplotlib 配置"></a>matplotlib 配置</h3><p>几乎所有默认行为都能通过一组全局参数进行自定义。操作 matplotlib 配置系统的方式主要有两种，第一种是 Python 编程方式，即利用<code>rc</code>方法。</p>
<p><code>rc</code>的第一个参数是希望自定义的对象。最简单的办法是将这些选项写成一个字典：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: font_options = &#123;<span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;monospace&#x27;</span>,</span><br><span class="line">    ...:                 <span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">    ...:                 <span class="string">&#x27;size&#x27;</span>  : <span class="string">&#x27;small&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: plt.rc(<span class="string">&#x27;font&#x27;</span>, **font_options)</span><br></pre></td></tr></table></figure>

<p>要了解全部的自定义选项，请查阅 matplotlib 的配置文件 matplotlibrc（位于 matplotlib/mpl-data 目录）。如果对该文件进行了自定义，并将其放在你自己的 .matplotlibrc 目录中，则每次使用 matplotlib 时就会加载该文件。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>数据科学</tag>
        <tag>pandas</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
</search>
