<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/huang_full.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/huang_full.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/huang_full.ico">
  <link rel="mask-icon" href="/blog/huang_full.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;kyonhuang.top&quot;,&quot;root&quot;:&quot;&#x2F;blog&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;blog&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;blog&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/blog/js/config.js"></script>
<meta name="description" content="上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。 另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，">
<meta property="og:type" content="article">
<meta property="og:title" content="算法一篇通——动态规划">
<meta property="og:url" content="https://kyonhuang.top/blog/dynamic-programming/">
<meta property="og:site_name" content="Kyon Huang 的博客">
<meta property="og:description" content="上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。 另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-12-18T10:23:41.000Z">
<meta property="article:modified_time" content="2018-08-18T00:07:44.000Z">
<meta property="article:author" content="Kyon Huang">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="DP">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://kyonhuang.top/blog/dynamic-programming/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;kyonhuang.top&#x2F;blog&#x2F;dynamic-programming&#x2F;&quot;,&quot;path&quot;:&quot;dynamic-programming&#x2F;&quot;,&quot;title&quot;:&quot;算法一篇通——动态规划&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>算法一篇通——动态规划 | Kyon Huang 的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
<link rel="alternate" href="/blog/atom.xml" title="Kyon Huang 的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Kyon Huang 的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Github 连接不稳定，请科学上网以获取最佳访问效果</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-开源"><a href="/blog/opensource/" rel="section"><i class="fa fa-code fa-fw"></i>开源</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">概念理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8F%9C%E9%B8%9F%E7%BA%A7"><span class="nav-number">3.1.</span> <span class="nav-text">菜鸟级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%BA%A7"><span class="nav-number">3.2.</span> <span class="nav-text">普通级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%91%E6%88%98%E8%80%85%E7%BA%A7"><span class="nav-number">3.3.</span> <span class="nav-text">挑战者级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">具体实现方法总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">5.</span> <span class="nav-text">扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">最长非降子序列（LIS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">Dijkstra 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">6.</span> <span class="nav-text">结语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%BD%9C%E5%8F%82%E8%80%83"><span class="nav-number">7.1.</span> <span class="nav-text">写作参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83"><span class="nav-number">7.2.</span> <span class="nav-text">学习参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%8A%E5%A6%B9%E7%AF%87"><span class="nav-number">7.3.</span> <span class="nav-text">姊妹篇</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kyon Huang"
      src="/blog/images/profile.png">
  <p class="site-author-name" itemprop="name">Kyon Huang</p>
  <div class="site-description" itemprop="description">CS 土博在读</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">63</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">129</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://kyonhuang.top/blog/atom.xml" title="RSS → https:&#x2F;&#x2F;kyonhuang.top&#x2F;blog&#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://kyonhuang.top/" title="学术主页 → https:&#x2F;&#x2F;kyonhuang.top&#x2F;"><i class="fa fa-user-graduate fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/bighuang624" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bighuang624" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/huang-si-teng-67" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;huang-si-teng-67" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kyonhuang@qq.com" title="E-Mail → mailto:kyonhuang@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/bighuang624" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kyonhuang.top/blog/dynamic-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/profile.png">
      <meta itemprop="name" content="Kyon Huang">
      <meta itemprop="description" content="CS 土博在读">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kyon Huang 的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法一篇通——动态规划
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-12-18 18:23:41" itemprop="dateCreated datePublished" datetime="2017-12-18T18:23:41+08:00">2017-12-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-08-18 08:07:44" itemprop="dateModified" datetime="2018-08-18T08:07:44+08:00">2018-08-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blog/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">算法笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>上周四去参加了第一次校招实习考试。虽然原本只是和同学凑个热闹，但结果还是着实有点打击。算法题一点思路都没有，前端知识也基本忘干净了。回到学校反思了一下，感觉从成都回来后学习状态确实很差。</p>
<p>另外，感觉自己把自己就预先划分到保研的身份去了。之前一直认为机器学习和前端不可兼得，自己划死了高度。实际上，很多业界人士在前端、机器学习以及其他方向都有很高水平。前端是我的兴趣，机器学习是之后可能深入研究的领域，但是如果抱着只能二选一的心态去学习，只能说明自己不够勤奋。之后的学习目标首先是为读研打好稳固基石，然后也要涉及多方面的知识。</p>
<p>回到正题。这次实习考试的第一题在当时没有思路，出来后同学讨论说要用到动态规划思想。之前有听过几次这个词，但是没有去了解，恰逢这个机会（以及为之后的美赛做准备），查阅了很多资料。在此总结一下我对动态规划的了解，以及用几个例子来说明，希望能尽可能地把动态规划给弄通。</p>
<span id="more"></span>

<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><p><strong>动态规划（Dynamic programming）</strong>是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，常用于求解<strong>最优化问题（Optimization problem）</strong>。动态规划常常适用于有<strong>重叠子问题</strong>和<strong>最优子结构性质</strong>的问题，动态规划方法所耗时间往往远少于朴素解法。</p>
<p>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的，本质上它还是同一个问题，我们就称其为原问题的<strong>子问题</strong>。</p>
<p><strong>动态规划的核心</strong>是<strong>状态</strong>和<strong>状态转移方程</strong>：</p>
<ul>
<li><p><strong>状态</strong>：描述该问题的子问题的解，即根据子问题来定义状态。</p>
</li>
<li><p><strong>状态转移方程</strong>：状态和状态之间的关系式。大部分情况下，某个状态只与它前面出现的状态有关，而独立于后面的状态（<strong>无后效性</strong>）。</p>
</li>
</ul>
<p>能使用动态规划思想解决的问题都有最优子结构性质和重叠子问题：</p>
<ul>
<li><p><strong>最优子结构（Optimal substructure）</strong>性质：如果问题的最优解所包含的子问题的解也是最优的，而这些子问题可以独立求解，我们就称该问题具有最优子结构性质。其包含“<strong>全局最优解包含局部最优解</strong>”的思想。</p>
</li>
<li><p>重叠子问题：指在用<strong>递归</strong>算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的解题思路如下：</p>
<ol>
<li>将原问题分解为子问题；</li>
<li>确定状态：状态不是随便定义的，一般定义完就要找到状态转移方程；</li>
<li>确定一些初始状态（边界状态）的值；</li>
<li>确定状态转移方程。</li>
</ol>
<p>如果问题看起来是个动态规划问题，但是无法定义出状态，那么试着将问题规约到一个已知的 DP 问题。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>讲了这么多，让我们一起做几道题目来练练手！</p>
<h3 id="菜鸟级"><a href="#菜鸟级" class="headerlink" title="菜鸟级"></a>菜鸟级</h3><p>这里我选了 LeetCode 的第 70 题 Climbing Stairs。说来惭愧，我第一次做这个题的时候半天没做出来，还先跳过去了。</p>
<p>题目是这样的：假设你在爬梯子，需要 n 步爬到顶。每一次只能爬 1 或 2 格，爬到顶一共有多少种不同的方法？</p>
<p>一步步沿着前面提到的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：这里的子问题即“爬到 i 格共有多少种不同的方法（i &lt; n）”；</li>
<li>确定状态：我们通常用一个函数表达式来表示状态。这里我们可以用<code>d(i)</code>来表示“爬到 i 格共有的不同的方法数”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = 1</code>、<code>d(2) = 2</code>；</li>
<li>确定状态转移方程：当我们得知<code>d(i-2)</code>时，再往上爬一次 2 格即可到达 i 格；当我们得知<code>d(i-1)</code>时，再往上爬一次 1 格即可到达 i 格。因此有<code>d(i) = d(i - 1) + d(i - 2)</code>。没有重叠的解法，因为最后一步要么爬 1 格，要么爬 2 格，我们将这两种自然分开了。</li>
</ol>
<p>使用递归，我们写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> climbStairs(n-<span class="number">1</span>) + climbStairs(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Submit 就可以看到红红的 Time Limit Exceeded。计算时间超了，这是因为对于每一个 i，由于递归调用，我们反复求解相同的子问题，使得所作的工作量爆炸性增长。想要节省这些计算，我们可以采用拿空间换时间的方法，用一个大小为 n 的数组来记录子问题的计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n+<span class="number">1</span>; i++)</span><br><span class="line">        fill(i, arr);</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        arr[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        arr[n] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        arr[n] = arr[n-<span class="number">1</span>] + arr[n-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AC，Run Time 5ms。</p>
<p>也可以用递推法来解决，本质是一个 fibonacci。这里借 Discuss 里的解法一用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> one_step_before = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> two_steps_before = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> all_ways = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	all_ways = one_step_before + two_steps_before;</span><br><span class="line">    	two_steps_before = one_step_before;</span><br><span class="line">        one_step_before = all_ways;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all_ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通级"><a href="#普通级" class="headerlink" title="普通级"></a>普通级</h3><p>稍微加点难度，来试一下 LeetCode 的第 198 题 House Robber。</p>
<p>题目：你是一个超高校级的小偷，唯一能阻止你的是你同一夜不能偷相邻的两家，否则警报装置会响。给一个全是非负整数的数组来代表每家有的钱，求你在不惊动警报的基础上今晚的最大收获。</p>
<p>还是一步步沿着动态规划的解题思路来解题：</p>
<ol>
<li>将原问题分解为子问题：假设数组长度为 n，则这里的子问题即“有 i 家可偷时最大收获（i &lt; n）”；</li>
<li>确定状态：用<code>g(i)</code>代表第 i 家有的钱，用<code>d(i)</code>来表示“有 i 家可偷时最大收获”；</li>
<li>确定一些初始状态（边界状态）的值：<code>d(1) = g(1)</code>、<code>d(2) = max(g(1), g(2))</code>；</li>
<li>确定状态转移方程：可以想到，到第 i（i &gt; 2）间屋子时，可能之前偷了第 i-1 间，那这间就不能偷；如果没偷第 i-1 间，那这间可以偷。于是有<code>d(i) = max(d(i-2)+g(i), d(i-1))</code>。</li>
</ol>
<p>用数组来记录偷过第 i 间屋子时最大收获，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fill(d, nums, i);</span><br><span class="line">    <span class="keyword">return</span> d[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] d, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        d[i] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">        d[i] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        d[i] = Math.max(d[i-<span class="number">2</span>]+nums[i], d[i-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Run Time 接近 0，非常理想。</p>
<p>也有非常巧妙的递推方案，空间复杂度 O(1)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prevNo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prevYes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : num) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = prevNo;</span><br><span class="line">        prevNo = Math.max(prevNo, prevYes);</span><br><span class="line">        prevYes = n + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(prevNo, prevYes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="挑战者级"><a href="#挑战者级" class="headerlink" title="挑战者级"></a>挑战者级</h3><p>来试试 LeetCode 的第 646 题 Maximum Length of Pair Chain。这是一道难度为 medium 的题，建议先跳过这一小节，看完“扩展”中的“<a href="http://kyonhuang.top/dynamic-programming/#%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89">最长非降子序列（LIS）</a>”再回来，有助于解决和理解这道题。</p>
<p>题目：给定 n 对数，每一对中前一个数总小于后一个数。现在，我们定义当且仅当<code>b &lt; c</code>时<code>(c, d)</code>可以跟在<code>(a, b)</code>后，来形成一条链。给定一系列对，求出<em>用上述方法形成的链条的最大长度</em>。不需要用完所有的给定对，而且可以以任意顺序选取。</p>
<p>可以看到，这题和 LIS 问题比较相似，但又有一些不同。由于可以以任意顺序选取，而非 LIS 问题中选取最长非降子序列的顺序固定，因此需要对一系列数对进行一个从小到大的排序。</p>
<p>状态转移方程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(i) = max&#123;1, d(j)+1&#125;，其中 j &lt; i，pairs[j][1] &lt; pairs[i][0]</span><br></pre></td></tr></table></figure>

<p>想要求<code>d(i)</code>，就把 i 前面的各个链中，最后一个数对的最大值不大于<code>pairs[i][0]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个链中最后一个数对的最大值都大于<code>pairs[i][0]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(pairs, (a, b) -&gt; (a[<span class="number">1</span>] - b[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> len = pairs.length;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">if</span>(pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>] &amp;&amp; arr[j] + <span class="number">1</span> &gt; arr[i])</span><br><span class="line">                arr[i] = arr[j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; l)</span><br><span class="line">            l = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(n^2)，不是最佳解法。由于根据数对的最大值排好了序，因此可以直接用下列方法来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(pairs, (a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, n = pairs.length, i = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; n) &#123;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="keyword">int</span> curEnd = pairs[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i+<span class="number">1</span> &lt; n &amp;&amp; pairs[i+<span class="number">1</span>][<span class="number">0</span>] &lt;= curEnd) i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具体实现方法总结"><a href="#具体实现方法总结" class="headerlink" title="具体实现方法总结"></a>具体实现方法总结</h2><p>经过以上三个例题的锻炼，一般难度的动态规划问题应该都能解决了。总结一下，动态规划思想具体实现有以下两种方法：</p>
<ol>
<li><p>可以用<strong>带备忘的自顶向下法（top-down with memoization）</strong>的方法计算状态转移方程。此方法仍然按自然的递归形式编写过程，但是用一个数组或者散列表来存储每个子问题的解，当需要时先检查是否已经保存过此解并取用。</p>
</li>
<li><p>还可以采用<strong>递推法</strong>自底向上地计算状态转移方程。递推的关键是边界和计算顺序，将子问题按照规模从小到大进行求解，当求解某个子问题时，其所依赖的更小的子问题都已求解完毕。在多数情况下，递推法的时间复杂度是：状态总数 * 每个状态的决策个数 * 决策时间。如果不同状态的决策个数不同，需具体问题具体分析。注意递归和递推的区别：一个自顶向下，一个自底向上。</p>
</li>
</ol>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="最长非降子序列（LIS）"><a href="#最长非降子序列（LIS）" class="headerlink" title="最长非降子序列（LIS）"></a>最长非降子序列（LIS）</h3><p>给定一个序列<code>A[1]、A[2]、...、A[n]</code>，求其最长非降子序列（LIS，longest increasing subsequence）的长度。这是讲动态规划时基本都会讲到的一个问题。</p>
<p>其最小子问题即求<code>A[1]、A[2]、...、A[i]</code>的最长非降子序列的长度，其中<code>i &lt; N</code>；而状态则定义有<code>d(i)</code>表示前 i 个数中以<code>A[i]</code>结尾的最长非降子序列。</p>
<p>当要考虑初始状态（边界状态）的值时，最好是以一个实际输入为例。假定要求的序列是：<code>5, 3, 4, 8, 6, 7</code>，则有：</p>
<ul>
<li>前 1 个数的 LIS 长度<code>d(1) = 1</code>；</li>
<li>前 2 个数的 LIS 长度<code>d(2) = 1</code>（序列：3；3 前面没有比 3 小的）；</li>
<li>前 3 个数的 LIS 长度<code>d(3) = 2</code>（序列：3，4；4 前面有个比它小的 3，所以<code>d(3)=d(2)+1</code>）；</li>
<li>前 4 个数的 LIS 长度<code>d(1) = 1</code>（序列：3，4，8；8 前面比它小的有 3 个数，所以<code>d(4) = max&#123;d(1),d(2),d(3)&#125;+1 = 3</code>）；</li>
</ul>
<p>由此得到状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(i) = max&#123;1, d(j) + 1&#125;，其中 i &gt; j，A[i] &gt;= A[j]</span><br></pre></td></tr></table></figure>

<p>想要求<code>d(i)</code>，就把 i 前面的各个子序列中，最后一个数不大于<code>A[i]</code>的序列长度加 1，然后取出最大的长度即为<code>d(i)</code>。当然，有可能 i 前面的各个子序列中最后一个数都大于<code>A[i]</code>，那么<code>d(i)=1</code>，即它自身成为一个长度为 1 的子序列。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lis</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt;= A[i])</span><br><span class="line">                d[i] = Math.max(d[i], d[j] + <span class="number">1</span>);</span><br><span class="line">        len = Math.max(d[i], len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 O(n^2)，不是最优解法。可以看看<a target="_blank" rel="noopener" href="https://www.felix021.com/blog/read.php?1587">最长递增子序列 O(NlogN)算法</a>，有点复杂，这里就不多谈了。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1 背包问题是最广为人知的动态规划问题之一，拥有很多变形。</p>
<p>有 n 种物品，每种只有一个。第 i 种物品的体积为 V[i]，价值为 W[i]。选一些物品装到一个容量为 C 的背包，使得背包内物品在总体积不超过 C 的前提下价值尽量大。1 &lt;= n &lt;= 100，1 &lt;= V[i] &lt;= C &lt;= 10000，1 &lt;= W[i] &lt;= 10^6。</p>
<p>将原问题分解为子问题后，状态还是比较好找的。我们可以用<code>d(i, j)</code>来表示前 i 个物品装到剩余体积为 j 的背包里能达到的最大价值。</p>
<p>对于第 i 个物品，可以装进或不装进背包。不装进背包，则背包中物品最大总价值为<code>d(i-1, j)</code>；而如果装进背包，对于前 i-1 个物品的空间就只有 j-V[i] 了。</p>
<p>由此得到状态转移方程：</p>
<p><code>d(i, j) = max&#123;d(i-1, j), d(i-1, j-V[i]) + W[i]&#125;</code></p>
<p>得到状态转移方程后，代码也不难写出了。这里就不贴了，有兴趣可以自己试试。</p>
<h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p>Dijkstra 算法也是以动态规划为基础的。你可以到我《算法》笔记的相关章节对 Dijkstra 算法进行进一步了解：<a target="_blank" rel="noopener" href="https://github.com/bighuang624/Algorithms-notes/blob/master/%E7%AC%94%E8%AE%B0/4.4_%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.md">Algorithms-notes/笔记/4.4 最短路径
</a>（Dijkstra 算法相关内容正在添加中）。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划有着很强的理论性和实践性，可以考验出算法能力，因此经常在各类算法竞赛、面试题中出现。想要完全掌握，光搞定这一篇博客的几个例题远远不够，只有多做经典题目，才能当再碰到动态规划相关题目的时候做到游刃有余。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="写作参考"><a href="#写作参考" class="headerlink" title="写作参考"></a>写作参考</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.hawstein.com/posts/dp-novice-to-advanced.html">动态规划：从新手到专家</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/baidu_28312631/article/details/47418773">教你彻底学会动态规划——入门篇 - CSDN博客</a></li>
<li>《算法竞赛入门经典（第 2 版）》第 9 章</li>
</ul>
<h3 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a29d52cf265da43333e4da7">漫画：什么是动态规划？ - 掘金</a>：可以借助这个漫画来理解动态规划，并了解动态规划在某些背包问题的特例上计算速度的局限性。</li>
<li><a target="_blank" rel="noopener" href="http://www.hawstein.com/posts/dp-knapsack.html">动态规划之背包问题（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189">什么是动态规划？动态规划的意义是什么？ - 知乎</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012829866">javascript背包问题详解 - 个人文章 - SegmentFault</a></li>
</ul>
<h3 id="姊妹篇"><a href="#姊妹篇" class="headerlink" title="姊妹篇"></a>姊妹篇</h3><ul>
<li><a href="http://kyonhuang.top/Greedy-algorithm/">算法一篇通——贪心算法</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Kyon Huang
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://kyonhuang.top/blog/dynamic-programming/" title="算法一篇通——动态规划">https://kyonhuang.top/blog/dynamic-programming/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a>
              <a href="/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a>
              <a href="/blog/tags/DP/" rel="tag"><i class="fa fa-tag"></i> DP</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/new-end-new-start/" rel="prev" title="花旗杯-新的终点，新的起点">
                  <i class="fa fa-chevron-left"></i> 花旗杯-新的终点，新的起点
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/bye2017hello2018/" rel="next" title="Goodbye 2017, hello 2018">
                  Goodbye 2017, hello 2018 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kyon Huang</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blog/js/comments.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/motion.js"></script><script src="/blog/js/next-boot.js"></script>

  
<script src="/blog/js/third-party/search/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
